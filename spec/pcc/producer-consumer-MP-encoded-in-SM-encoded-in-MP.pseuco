intchan[3] read;
intchan[3] write;

struct Kanal3{ 

   boolchan _signalPlatzFrei; 
   boolchan chillPlatzFrei; 
   boolchan wantPlatzFrei; 

   boolchan _signalDatumDa; 
   boolchan chillDatumDa; 
   boolchan wantDatumDa; 

   void cell ( intchan rd , intchan wt , int init, int id) {
      int v = init ; 
      while ( true ) {
         select {
            case rd <! v: 
               println ("............. Aktueller Wert:" + v + " in Zelle " + id + ".");
            case v = <? wt: 
               println ("............. Neuer Wert:" + v + " in Zelle " + id + ".");
         }
      }
   }

   void chillDaemon(boolchan want, boolchan chill, boolchan indicate, string name){
      int count = 0; 
      while (true) {
         select{
            case <? want:{
               count++;
               println("Einer mehr wartet auf " + name + ".");
            }
            case <? indicate: {
               if (count != 0){
                  count--; 
                  chill <! false; 
                  println("Einer weniger wartet auf " + name +".");
               }  
            }
         }
      } 
   }

   void initialize(){
      start cell(read[0],write[0],0,0); 
      start cell(read[1],write[1],0,1);
      start cell(read[2],write[2],0,2);
 
      start chillDaemon(wantDatumDa,chillDatumDa,_signalDatumDa,"Datum");
      start chillDaemon(wantPlatzFrei,chillPlatzFrei,_signalPlatzFrei,"Platz");
   }

   void mpLock(boolchan1 g){
      g <! true;
   } 
   void mpUnlock(boolchan1 g){
      <? g;
   }

   int used = 0; 
   boolchan1 guard; 

   void put(int x){
      mpLock(guard);
      while (!(used < 3)){
         wantPlatzFrei <! true;
         mpUnlock(guard);
         <? chillPlatzFrei; 
         mpLock(guard);  
      } 
      write[used] <! x;
      used++;   
      _signalDatumDa <! true;
      mpUnlock(guard);
   }

   int get(){
      mpLock(guard);
      while (!(used > 0)){
         wantDatumDa <! true;
         mpUnlock(guard);
         <? chillDatumDa; 
         mpLock(guard);  
      } 
      int temp = <? read[0];
      used--;
      for (int j=1 ; j <= used ; j++){
         write[j-1] <! (<? read[j]);
      }
      _signalPlatzFrei <! true;
      mpUnlock(guard);
      return temp;
   }
}

Kanal3 k;

void produce(int id){ 
   while (true) {
       println("Erzeuger " + id + " hat " + id + " produziert.");
       k.put(id);
   }
}
  
void consume(string name){ 
   while (true) {
       int c = k.get();
       println(" Verbraucher " + name + " hat " + c + " konsumiert.");
   }
}

mainAgent{
   k.initialize();

   start produce(1); // Ein Erzeuger. 
   start produce(2); // Zwei Erzeuger. 
   start produce(3); // Drei Erzeuger. 
   start produce(4); // Vier Erzeuger. 
   start produce(5); // Fuenf Erzeuger. 
   
   start consume("A"); // Ein Verbraucher. 
   start consume("B"); // Zwei Verbraucher. 
   start consume("C"); // Drei Verbraucher. 
   start consume("D"); // Vier Verbraucher. 
}

