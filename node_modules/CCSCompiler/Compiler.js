// Generated by CoffeeScript 1.6.3
/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
	The central coordination class for the compile process of PseuCo to CCS.
	You start the compilation process by creating a new PCCCompiler object with the node of your PseuCo tree and call compile() on it. You'll get a CCS tree on success
*/

debugger;
var CCS, PC, PCCApplicationPlaceholderStackElement, PCCApplicationStackElement, PCCBinaryCCSStackElement, PCCBinaryContainer, PCCBinaryStackElement, PCCBinaryTarget, PCCChoiceStackElement, PCCClass, PCCClassStackElement, PCCCompiler, PCCCompilerStack, PCCComposedContainer, PCCCondition, PCCConditionStackElement, PCCConstantContainer, PCCConstructor, PCCContainer, PCCExecutor, PCCExitStackElement, PCCField, PCCGlobal, PCCGlobalStackElement, PCCGlobalVariable, PCCGroupable, PCCInputStackElement, PCCInternalReadOnlyField, PCCLocalVariable, PCCOutputStackElement, PCCParallelStackElement, PCCPrefixStackElement, PCCProcedure, PCCProcedureFrame, PCCProcedureStackElement, PCCProcessDefinitionStackElement, PCCProcessFrame, PCCProcessFrameStackElement, PCCProgramController, PCCRestrictionStackElement, PCCSequenceStackElement, PCCStackElement, PCCStackResult, PCCStackResultContainer, PCCStopStackElement, PCCSystemProcessStackElement, PCCType, PCCUnaryContainer, PCCUnaryStackElement, PCCVariable, PCCVariableContainer, PCCVariableInfo, exports, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _t,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PC = require("PseuCo");

CCS = require("CCS");

PCCCompiler = (function() {
  function PCCCompiler(program) {
    this.program = program;
    this.controller = null;
    this.stack = null;
    this.groupElements = [];
    this.controller = new PCCProgramController(this.program);
    this.systemProcesses = [];
    this.compilingNodes = [];
  }

  PCCCompiler.prototype.compileProgram = function() {
    var cls, global, n, p, usedTypes, _i, _j, _len, _len1, _ref, _ref1;
    this.program.collectClasses(this.controller);
    this.program.collectEnvironment(this.controller);
    this.program.collectAgents(this.controller);
    global = new PCCGlobalStackElement(this.controller.getGlobal());
    this.stack = new PCCCompilerStack(global);
    usedTypes = this.controller.getUsedTypes();
    this.compileReturn();
    this.compileMutex();
    this.compileWaitRoom();
    this.compileArrayManager();
    for (n in usedTypes.arrays) {
      this.compileArrayWithCapacity(n);
    }
    this.compileChannelManager();
    for (n in usedTypes.channels) {
      this.compileChannelWithCapacity(n);
    }
    this.compileAgentTools();
    _ref = this.controller.getAgents();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.emitAgentConstructor(this);
      this.beginSystemProcess();
      this.emitProcessApplication(p.getAgentProcessName(), []);
      this.endSystemProcess();
    }
    _ref1 = this.controller.getAllClasses();
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      cls = _ref1[_j];
      cls.emitConstructor(this);
    }
    this.program.compile(this);
    return new CCS(this.controller.root.collectPDefs(), this._getSystem());
  };

  PCCCompiler.prototype.compile = function() {
    var args, node, res;
    node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.compilingNodes.push(node);
    res = node.compile.apply(node, [this].concat(__slice.call(args)));
    this.compilingNodes.pop();
    return res;
  };

  PCCCompiler.prototype.pushStackElement = function(element) {
    element.pseucoNode = this.compilingNodes[this.compilingNodes.length - 1];
    return this.stack.pushElement(element);
  };

  PCCCompiler.prototype._getSystem = function() {
    var i, system, _i, _ref;
    this.beginSystemProcess();
    this.emitProcessApplication("MainAgent", []);
    this.endSystemProcess();
    system = this.systemProcesses[0];
    for (i = _i = 1, _ref = this.systemProcesses.length; _i < _ref; i = _i += 1) {
      system = new CCSParallel(system, this.systemProcesses[i]);
    }
    return new CCSRestriction(system, ["*", "println"]);
  };

  /*
  		Delegates must implement the following methods:
  		 compilerGetVariable(compiler, identifier)
  		 compilerGetProcedure(compiler, identifier)
  		 compilerHandleNewIdentifierWithDefaultValueCallback(compiler, identifier, callback, context)
  		When these methods are called, the receiver may modify the compiler state by emitting CCS processes, pushing processes, ...
  */


  PCCCompiler.prototype.getVariableWithName = function(name, className, isInternal) {
    if (isInternal) {
      name = PCCVariableInfo.getNameForInternalVariableWithName(name);
    }
    if (className) {
      return this.controller.getClassWithName(className).compilerGetVariable(this, name);
    }
    return this.stack.compilerGetVariable(this, name);
  };

  PCCCompiler.prototype.getProcedureWithName = function(name, className) {
    if (className) {
      return this.controller.getClassWithName(className).compilerGetProcedure(this, name);
    }
    return this.stack.compilerGetProcedure(this, name);
  };

  PCCCompiler.prototype.getClassWithName = function(name) {
    return this.controller.getClassWithName(name);
  };

  PCCCompiler.prototype.getCurrentClass = function() {
    var e, _i, _len, _ref;
    _ref = this.groupElements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (e instanceof PCCClassStackElement) {
        return e.classInfo;
      }
    }
  };

  PCCCompiler.prototype.getCurrentProcedure = function() {
    var e, _i, _len, _ref;
    _ref = this.groupElements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (e instanceof PCCProcedureStackElement) {
        return e.procedure;
      }
    }
  };

  PCCCompiler.prototype.getGlobal = function() {
    return this.controller.getGlobal();
  };

  PCCCompiler.prototype.getFreshContainer = function(ccsType, wish) {
    var res;
    res = this.getProcessFrame().createContainer(ccsType, wish);
    res.pseucoNode = this.compilingNodes[this.compilingNodes.length - 1];
    res.pseucoNode.addCalculusComponent(res.pseucoNode);
    return res;
  };

  PCCCompiler.prototype.handleNewVariableWithDefaultValueCallback = function(variable, callback, context) {
    return this.stack.compilerHandleNewVariableWithDefaultValueCallback(this, variable, callback, context);
  };

  PCCCompiler.prototype._getControlElement = function() {
    return this.stack.getCurrentControlElement();
  };

  PCCCompiler.prototype._handleStackResult = function(resultContainer, controlElement) {
    var result, _i, _len, _ref, _results;
    _ref = resultContainer.results;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      _results.push(result.type === PCCStackResult.TYPE_CCSPROCESS_DEFINITION ? controlElement.compilerPushPDef(result.data) : void 0);
    }
    return _results;
  };

  PCCCompiler.prototype.beginSystemProcess = function() {
    var element;
    element = new PCCSystemProcessStackElement();
    this.groupElements.push(element);
    return this.pushStackElement(element);
  };

  PCCCompiler.prototype.endSystemProcess = function() {
    var element, res;
    element = this.groupElements.pop();
    if (!(element instanceof PCCSystemProcessStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    res = element.removeFromStack();
    return this.systemProcesses.push(res.data);
  };

  PCCCompiler.prototype.emitSystemProcessApplication = function(processName, argumentContainers) {
    this.beginSystemProcess();
    this.emitProcessApplication(processName, argumentContainers);
    return this.endSystemProcess();
  };

  PCCCompiler.prototype.beginProcessGroup = function(groupable, variables) {
    var element, frame;
    frame = new PCCProcessFrame(groupable, variables);
    element = new PCCProcessFrameStackElement(frame);
    this.groupElements.push(element);
    this.pushStackElement(element);
    return frame.emitProcessDefinition(this);
  };

  PCCCompiler.prototype.endProcessGroup = function() {
    var controlElement, frame;
    frame = this.groupElements.pop();
    if (!(frame instanceof PCCProcessFrameStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(frame.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.getProcessFrame = function() {
    return this.stack.getCurrentProcessFrame();
  };

  PCCCompiler.prototype.addProcessGroupFrame = function(nextFrame) {
    this.pushStackElement(new PCCProcessFrameStackElement(nextFrame));
    nextFrame.emitProcessDefinition(this);
    return null;
  };

  PCCCompiler.prototype.emitNewScope = function(derivationFrame) {
    var frame, scope;
    frame = this.getProcessFrame();
    if (!derivationFrame) {
      derivationFrame = frame;
    }
    scope = derivationFrame.createScope();
    scope.emitTransitionFromFrame(this, frame);
    this.addProcessGroupFrame(scope);
    return scope;
  };

  PCCCompiler.prototype.emitNextProcessFrame = function(derivationFrames) {
    var frame, next;
    frame = this.getProcessFrame();
    if (!derivationFrames) {
      derivationFrames = [frame];
    }
    next = PCCProcessFrame.createFollowupFrameForFrames(derivationFrames);
    next.emitTransitionFromFrame(this, frame);
    this.addProcessGroupFrame(next);
    return next;
  };

  PCCCompiler.prototype.emitMergeOfProcessFramesOfPlaceholders = function(placeholders) {
    var followup, frames, p, _i, _len;
    if (placeholders.length === 0) {
      return null;
    }
    frames = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = placeholders.length; _i < _len; _i++) {
        p = placeholders[_i];
        _results.push(p.frame);
      }
      return _results;
    })();
    followup = PCCProcessFrame.createFollowupFrameForFrames(frames);
    for (_i = 0, _len = placeholders.length; _i < _len; _i++) {
      p = placeholders[_i];
      followup.emitCallProcessFromFrame(this, p.frame, p);
    }
    this.addProcessGroupFrame(followup);
    return followup;
  };

  PCCCompiler.prototype.protectContainer = function(container) {
    return this.getProcessFrame().protectContainer(container);
  };

  PCCCompiler.prototype.unprotectContainer = function() {
    return this.getProcessFrame().unprotectContainer();
  };

  PCCCompiler.prototype.getProtectedContainer = function() {
    return this.getProcessFrame().getProtectedContainer();
  };

  PCCCompiler.prototype._silentlyAddProcessDefinition = function(processName, argumentContainers) {
    var element;
    element = new PCCProcessDefinitionStackElement(processName, argumentContainers);
    this.pushStackElement(element);
    return element;
  };

  PCCCompiler.prototype.beginProcessDefinition = function(processName, argumentContainers) {
    var element;
    element = this._silentlyAddProcessDefinition(processName, argumentContainers);
    return this.groupElements.push(element);
  };

  PCCCompiler.prototype.isCurrentProcessCompleted = function() {
    return this.stack.isCurrentProcessCompleted();
  };

  PCCCompiler.prototype.endProcessDefinition = function() {
    var controlElement, def;
    def = this.groupElements.pop();
    if (!(def instanceof PCCProcessDefinitionStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(def.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.beginClass = function(className) {
    var curClass, element;
    this.controller.beginClass(className);
    curClass = this.controller.getClassWithName(className);
    if (!curClass) {
      throw new Error("Tried to begin unknown class!");
    }
    element = new PCCClassStackElement(curClass);
    this.pushStackElement(element);
    return this.groupElements.push(element);
  };

  PCCCompiler.prototype.endClass = function() {
    var cls;
    this.controller.endClass();
    cls = this.groupElements.pop();
    if (!(cls instanceof PCCClassStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    return cls.removeFromStack();
  };

  PCCCompiler.prototype.beginProgram = function() {
    /*
    		throw new Error("Stack already existed before beginning of program!") if @stack != null
    		global = new PCCGlobalStackElement(@controller.getGlobal())
    		@stack = new PCCCompilerStack(global)
    		@groupElements.push(global)
    */

  };

  PCCCompiler.prototype.endProgram = function() {};

  /*
  		global = @groupElements.pop()
  		throw new Error("Unexpected stack element!") if not (global instanceof PCCGlobalStackElement)
  		global.removeFromStack()
  		@stack = null
  */


  PCCCompiler.prototype.beginMainAgent = function() {
    this.controller.beginMainAgent();
    return this.beginProcessGroup(new PCCGroupable("MainAgent"));
  };

  PCCCompiler.prototype.endMainAgent = function() {
    this.controller.endMainAgent();
    return this.endProcessGroup();
  };

  PCCCompiler.prototype.beginProcedure = function(procedureName) {
    var element, frame, procedure;
    this.controller.beginProcedure(procedureName);
    procedure = this.stack.compilerGetProcedure(this, procedureName);
    if (!procedure) {
      throw new Error("Tried to begin unknown procedure!");
    }
    frame = new PCCProcedureFrame(procedure);
    element = new PCCProcedureStackElement(procedure);
    this.pushStackElement(element);
    this.groupElements.push(element);
    return this.addProcessGroupFrame(frame);
  };

  PCCCompiler.prototype.endProcedure = function() {
    var controlElement, proc;
    this.controller.endProcedure();
    proc = this.groupElements.pop();
    if (!(proc instanceof PCCProcedureStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(proc.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.beginStatement = function(statement) {};

  PCCCompiler.prototype.endStatement = function() {};

  PCCCompiler.prototype.beginExpression = function(expression) {};

  PCCCompiler.prototype.endExpression = function() {};

  PCCCompiler.prototype._usingFrames = function() {
    return this.groupElements.length > 1 || (this.groupElements.length > 0 && this.groupElements[0] instanceof PCCProcessFrameStackElement);
  };

  PCCCompiler.prototype.emitStop = function() {
    return this.pushStackElement(new PCCStopStackElement());
  };

  PCCCompiler.prototype.emitExit = function() {
    return this.pushStackElement(new PCCExitStackElement());
  };

  PCCCompiler.prototype.emitProcessApplication = function(processName, argumentContainers) {
    if (argumentContainers == null) {
      argumentContainers = [];
    }
    return this.pushStackElement(new PCCApplicationStackElement(processName, argumentContainers));
  };

  PCCCompiler.prototype.emitOutput = function(channel, specificChannel, valueContainer) {
    return this.pushStackElement(new PCCOutputStackElement(channel, specificChannel, valueContainer));
  };

  PCCCompiler.prototype.emitInput = function(channel, specificChannel, container) {
    return this.pushStackElement(new PCCInputStackElement(channel, specificChannel, container));
  };

  PCCCompiler.prototype.emitCondition = function(condition) {
    return this.pushStackElement(new PCCConditionStackElement(condition));
  };

  PCCCompiler.prototype.emitChoice = function() {
    var res;
    res = new PCCChoiceStackElement();
    this.pushStackElement(res);
    if (this._usingFrames()) {
      this.emitNewScope();
    }
    return res;
  };

  PCCCompiler.prototype.emitParallel = function() {
    var res;
    res = new PCCParallelStackElement();
    this.pushStackElement(res);
    if (this._usingFrames()) {
      this.emitNewScope();
    }
    return res;
  };

  PCCCompiler.prototype.emitSequence = function() {
    var res;
    res = new PCCSequenceStackElement();
    this.pushStackElement(res);
    return res;
  };

  PCCCompiler.prototype.emitRestriction = function(restrictedChannelNames) {
    return this.pushStackElement(new PCCRestrictionStackElement(restrictedChannelNames));
  };

  PCCCompiler.prototype.emitProcessApplicationPlaceholder = function() {
    var ph;
    ph = new PCCApplicationPlaceholderStackElement(this.getProcessFrame());
    this.pushStackElement(ph);
    return ph;
  };

  PCCCompiler.prototype.compileMutex = function() {
    var control, i;
    i = new PCCVariableContainer("i", PCCType.INT);
    this.beginProcessDefinition("Mutex", [i]);
    this.emitInput("lock", i, null);
    this.emitInput("unlock", i, null);
    this.emitProcessApplication("Mutex", [i]);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Mutex_cons", [i]);
    this.emitOutput("mutex_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("Mutex_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitProcessApplication("Mutex", [i]);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Mutex_cons", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileWaitRoom = function() {
    var c, control, control1, control2, control3, i, inner;
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("WaitRoom", [i, c]);
    control1 = this.emitChoice();
    this.emitInput("signal", i, null);
    inner = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "=="));
    this.emitProcessApplication("WaitRoom", [i, c]);
    inner.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("wait", i, null);
    this.emitProcessApplication("WaitRoom", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    inner.setBranchFinished();
    control1.setBranchFinished();
    control2 = this.emitChoice();
    this.emitInput("add", i, null);
    this.emitProcessApplication("WaitRoom", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "+")]);
    control2.setBranchFinished();
    control3 = this.emitSequence();
    this.emitInput("signal_all", i, null);
    this.emitProcessApplication("WaitDistributor", [i, c]);
    control3.setBranchFinished();
    this.emitProcessApplication("WaitRoom", [i, new PCCConstantContainer(0)]);
    control3.setBranchFinished();
    control2.setBranchFinished();
    control1.setBranchFinished();
    this.endProcessDefinition();
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("WaitDistributor", [i, c]);
    control = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<="));
    this.emitExit();
    control.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("wait", i, null);
    this.emitProcessApplication("WaitDistributor", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    control.setBranchFinished();
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("WaitRoom_cons", [i]);
    this.emitOutput("wait_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("WaitRoom_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitProcessApplication("WaitRoom", [i, new PCCConstantContainer(0)]);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("WaitRoom_cons", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileArrayWithCapacity = function(size) {
    var args, control, def, emitAccessors, i, index, j, _i, _j, _k, _ref;
    i = new PCCVariableContainer("i", PCCType.INT);
    args = [i];
    for (j = _i = 0; 0 <= size ? _i < size : _i > size; j = 0 <= size ? ++_i : --_i) {
      args.push(new PCCVariableContainer("v" + j, PCCType.INT));
    }
    this.beginProcessDefinition("Array" + size, args);
    index = new PCCVariableContainer("index", PCCType.INT);
    this.emitInput("array_access", i, index);
    emitAccessors = function(compiler, i, size, j, args) {
      var inner;
      compiler.emitCondition(new PCCBinaryContainer(index, new PCCConstantContainer(j), "=="));
      inner = compiler.emitChoice();
      compiler.emitOutput("array_get", i, args[j + 1]);
      compiler.emitProcessApplication("Array" + size, args);
      inner.setBranchFinished();
      compiler.emitInput("array_set", i, args[j + 1]);
      compiler.emitProcessApplication("Array" + size, args);
      return inner.setBranchFinished();
    };
    for (j = _j = 0, _ref = size - 1; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
      control = this.emitChoice();
      emitAccessors(this, i, size, j, args);
      control.setBranchFinished();
    }
    emitAccessors(this, i, size, size - 1, args);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Array" + size + "_cons", []);
    this.emitInput("array_new", null, i);
    def = new PCCVariableContainer("d", PCCType.VOID);
    this.emitOutput("array" + size + "_create", null, i);
    this.emitInput("array_setDefault", i, def);
    control = this.emitParallel();
    this.emitProcessApplication("Array" + size + "_cons", []);
    control.setBranchFinished();
    args = [i];
    for (j = _k = 0; 0 <= size ? _k < size : _k > size; j = 0 <= size ? ++_k : --_k) {
      args.push(def);
    }
    this.emitProcessApplication("Array" + size, args);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Array" + size + "_cons", []);
  };

  PCCCompiler.prototype.compileArrayManager = function() {
    var i;
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("ArrayManager", [i]);
    this.emitOutput("array_new", null, i);
    this.emitProcessApplication("ArrayManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("ArrayManager", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileChannelWithCapacity = function(capacity) {
    var args, c, control, def, i, j, v, _i, _j, _k;
    if (capacity <= 0) {
      return this.compileUnbufferedChannelCons();
    }
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    args = [i, c];
    for (j = _i = 0; 0 <= capacity ? _i < capacity : _i > capacity; j = 0 <= capacity ? ++_i : --_i) {
      args.push(new PCCVariableContainer("v" + j, PCCType.INT));
    }
    this.beginProcessDefinition("Channel" + capacity, args);
    args[1] = new PCCBinaryContainer(c, new PCCConstantContainer(1), "+");
    for (j = _j = 0; 0 <= capacity ? _j < capacity : _j > capacity; j = 0 <= capacity ? ++_j : --_j) {
      control = this.emitChoice();
      this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(j), "=="));
      v = new PCCVariableContainer("v" + j, PCCType.INT);
      this.emitInput("put", i, v);
      this.emitProcessApplication("Channel" + capacity, args);
      control.setBranchFinished();
    }
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitOutput("receive", i, new PCCVariableContainer("v0", PCCType.INT));
    args.splice(2, 1);
    args.push(new PCCConstantContainer(0));
    args[1] = new PCCBinaryContainer(c, new PCCConstantContainer(1), "-");
    this.emitProcessApplication("Channel" + capacity, args);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Channel" + capacity + "_cons", []);
    this.emitInput("channel_new", null, i);
    this.emitOutput("channel" + capacity + "_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("Channel" + capacity + "_cons", []);
    control.setBranchFinished();
    args = [i, new PCCConstantContainer(0)];
    def = new PCCConstantContainer(0);
    for (j = _k = 0; 0 <= capacity ? _k < capacity : _k > capacity; j = 0 <= capacity ? ++_k : --_k) {
      args.push(def);
    }
    this.emitProcessApplication("Channel" + capacity, args);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Channel" + capacity + "_cons", []);
  };

  PCCCompiler.prototype.compileUnbufferedChannelCons = function() {
    var i;
    i = new PCCVariableContainer("i", PCCType.INT);
    this.beginProcessDefinition("Channel_cons", [i]);
    this.emitOutput("channel_create", null, i);
    this.emitProcessApplication("Channel_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "-")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Channel_cons", [new PCCConstantContainer(-1)]);
  };

  PCCCompiler.prototype.compileChannelManager = function() {
    var i;
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("ChannelManager", [i]);
    this.emitOutput("channel_new", null, i);
    this.emitProcessApplication("ChannelManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("ChannelManager", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileAgentTools = function() {
    var a, c, control, i;
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("AgentManager", [i]);
    this.emitOutput("agent_new", null, i);
    this.emitProcessApplication("AgentManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    this.emitSystemProcessApplication("AgentManager", [new PCCConstantContainer(1)]);
    a = new PCCVariableContainer("a", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("AgentJoiner", [a, c]);
    control = this.emitChoice();
    this.emitInput("join_register", a, null);
    this.emitProcessApplication("AgentJoiner", [a, new PCCBinaryContainer(c, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitInput("agent_terminate", a, null);
    this.emitProcessApplication("JoinDistributor", [a, c]);
    control.setBranchFinished();
    this.endProcessDefinition();
    a = new PCCVariableContainer("a", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("JoinDistributor", [a, c]);
    control = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<="));
    this.emitInput("join_register", a, null);
    this.emitInput("join", a, null);
    this.emitProcessApplication("JoinDistributor", [a, new PCCConstantContainer(0)]);
    control.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("join", a, null);
    this.emitProcessApplication("JoinDistributor", [a, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    control.setBranchFinished();
    return this.endProcessDefinition();
  };

  PCCCompiler.prototype.compileReturn = function() {
    var v;
    this.beginProcessDefinition("Return", []);
    v = new PCCVariableContainer("v", PCCType.INT);
    this.emitInput("return", null, v);
    this.emitOutput("rreturn", null, v);
    this.emitProcessApplication("Return", []);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Return", []);
  };

  return PCCCompiler;

})();

PC.EnvironmentNode.prototype.compilerPushPDef = function(pdef) {
  if (!this.PCCCompilerPDefs) {
    this.PCCCompilerPDefs = [];
  }
  return this.PCCCompilerPDefs.push(pdef);
};

PC.Variable.prototype.compilerPushPDef = PC.EnvironmentNode.prototype.compilerPushPDef;

PC.EnvironmentNode.prototype.collectPDefs = function() {
  var c;
  if (!this.PCCCompilerPDefs) {
    this.PCCCompilerPDefs = [];
  }
  return this.PCCCompilerPDefs.concat(((function() {
    var _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.collectPDefs());
    }
    return _results;
  }).call(this)).concatChildren());
};

PC.Variable.prototype.collectPDefs = function() {
  if (this.PCCCompilerPDefs) {
    return this.PCCCompilerPDefs;
  } else {
    return [];
  }
};

PC.Node.prototype.addCalculusComponent = function(component) {
  if (!this.calculusComponents) {
    this.calculusComponents = [];
  }
  return this.calculusComponents.push(component);
};

PC.Node.prototype.getCalculusComponents = function() {
  if (!this.calculusComponents) {
    this.calculusComponents = [];
  }
  return this.calculusComponents;
};

/*
PCStmtExpression::collectAgents = (env) -> 
	@children[0].collectAgents(env)
PCVariableDeclarator::collectEnvironment = (env, type) ->
	@children.length > 0 and @children[0].collectEnvironment(env)
PCVariableInitializer::collectEnvironment = (env) ->
	!@isArray() and @children[0].collectEnvironment(env)
PCExpression::collectEnvironment = (env) -> c.collectEnvironment(env) for c in @children
PCStartExpression::collectEnvironment = (env) ->
	env instanceof PCCProgramController and env.processProcedureAsAgent(@children[0].getProcedure(env))
*/


PCCConstructor = (function() {
  function PCCConstructor(compiler, delegate, context) {
    this.compiler = compiler;
    this.delegate = delegate;
    this.context = context;
  }

  PCCConstructor.prototype.emit = function() {
    var control, entry, envArgCount, envName, i, recursion, v, variables, vars, _base, _i;
    envName = this.delegate.constructorGetName(this, this.context);
    variables = this.delegate.constructorGetArguments(this, this.compiler, this.context);
    this.compiler.beginProcessGroup(new PCCGroupable(envName + "_cons"), variables);
    entry = this.compiler.getProcessFrame();
    variables = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(this.compiler.getVariableWithName(v.getName(), null, v.isInternal));
      }
      return _results;
    }).call(this);
    envArgCount = this.delegate.constructorProtectEnvironmentArguments(this, this.compiler, variables, this.context);
    vars = [];
    for (i = _i = 0; 0 <= envArgCount ? _i < envArgCount : _i > envArgCount; i = 0 <= envArgCount ? ++_i : --_i) {
      vars.unshift(this.compiler.unprotectContainer());
    }
    recursion = typeof (_base = this.delegate).constructorShouldCallRecursively === "function" ? _base.constructorShouldCallRecursively(this, this.context) : void 0;
    control = null;
    if (recursion) {
      control = this.compiler.emitParallel();
    }
    this.compiler.emitProcessApplication(envName, vars);
    if (recursion) {
      control.setBranchFinished();
      this.delegate.constructorUpdateVariablesForRecursiveCall(this, this.compiler, entry, variables, this.context);
      entry.emitCallProcessFromFrame(this.compiler, this.compiler.getProcessFrame());
      control.setBranchFinished();
    }
    return this.compiler.endProcessGroup();
  };

  return PCCConstructor;

})();

PCCConstructor.emitConstructor = function(compiler, delegate, context) {
  return (new PCCConstructor(compiler, delegate, context)).emit();
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	Manages multiple versions of process frames. A process frame is the set of all arguments, local variables and temporary containers of a compile unit, also called a process groupable (e.g. a procedure) at a specific time.
	Process frames may exist in multiple versions: One version for each CCS process. Because of restrictions of CCS it is not always possible to compile into a single process. This class helps to manage the fragmentation of code into multiple processes.
	Versions are partially ordered.
*/


/*
	Groupable implements:
	 getProcessName()
*/


PCCProcessFrame = (function() {
  /*
  		* @param groupable: An object that implements the «Groupable» interface. All process frames with the same groupable object are in the same process group.
  		* @param variables: An array of PCCVariableInfo objects. The incoming variables that will get passed on transition to the represented process definition.
  		* @param tempTypes: An array of PCTType objects, which represents the values that will get passed as temporary values on transition to the represented process definition.
  		* @param autoInit: By default true. If the created process frame will be followup process frame, the creator of the frame might want to perform its own initialization, which it can communicate through this parameter.
  		
  		
  		Variables:
  			processID: Gives a process frame a unique identifier within the group, which is used to determine a unique name for the created process definition. For scopes the value of this variable is not relevant.
  			containerIndex: The number of issued auto-named PCCVariableContainer objects (using @createContainer).
  			usedContainers: An array of PCCVariableContainer objects that are already in use in the scope of the represented process definition.
  			varTable: A map from PseuCo identifiers (string) to PCCContainer objects which represents the current value of the corresponding identifier.
  			protections: A stack (array) of PCCContainer objects which represent a temporary value.
  			initialVariableCount: The number of incomming variables.
  			variables: An array of PCCVariableInfo objects, which represent the PseuCo variables currently covered by the process frame.
  */

  function PCCProcessFrame(groupable, variables, tempTypes, autoInit) {
    this.groupable = groupable;
    this.variables = variables != null ? variables : [];
    this.tempTypes = tempTypes != null ? tempTypes : [];
    if (autoInit == null) {
      autoInit = true;
    }
    if (autoInit) {
      this._freshInit();
    }
    null;
  }

  PCCProcessFrame.prototype._freshInit = function() {
    var i, v, _i, _len, _ref;
    if (this.groupable.frameCount === void 0) {
      this.groupable.frameCount = 0;
    }
    this.processID = this.groupable.frameCount++;
    this.containerIndex = 0;
    this.usedContainers = [];
    this.varTable = {};
    _ref = this.variables;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      this.varTable[v.getIdentifier()] = this.createContainer(v.getCCSType(), v.getSuggestedContainerName());
    }
    this.protections = (function() {
      var _j, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref1 = this.tempTypes.length; _j < _ref1; i = _j += 1) {
        _results.push(this.createContainer(this.tempTypes[i], "t" + i));
      }
      return _results;
    }).call(this);
    return this.initialVariableCount = this.variables.length;
  };

  PCCProcessFrame.prototype._argumentsForProcessDefinition = function() {
    var args, v;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = this.variables;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(this.varTable[v.getIdentifier()]);
      }
      return _results;
    }).call(this);
    return args.concat(this.protections);
  };

  /*
  		Must be called before new containers get assigned to the variables or temporary values are pushed or popped!
  */


  PCCProcessFrame.prototype.emitProcessDefinition = function(compiler) {
    var args;
    if (this.isScope) {
      return;
    }
    args = this._argumentsForProcessDefinition();
    return compiler._silentlyAddProcessDefinition(this._getProcessName(), args);
  };

  PCCProcessFrame.prototype._getProcessName = function() {
    return "" + (this.groupable.getProcessName()) + (this.processID > 0 ? "_" + this.processID : "");
  };

  PCCProcessFrame.prototype._getProcessArgCount = function() {
    return this.initialVariableCount + this.tempTypes.length;
  };

  PCCProcessFrame.prototype._didAlreadyUseContainerWithIdentifier = function(id) {
    var c, _i, _len, _ref;
    _ref = this.usedContainers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (c.identifier === id) {
        return true;
      }
    }
    return false;
  };

  PCCProcessFrame.prototype.createContainer = function(ccsType, wish) {
    var container, id;
    if (typeof wish === "string" && wish.length > 0 && wish.indexOf("f_") !== 0 && !this._didAlreadyUseContainerWithIdentifier(wish)) {
      id = wish;
    } else {
      id = "f_" + (this.containerIndex++);
    }
    container = new PCCVariableContainer(id, ccsType);
    this.usedContainers.push(container);
    return container;
  };

  PCCProcessFrame.prototype.getContainerForVariable = function(identifier) {
    if (this.varTable[identifier] === void 0) {
      throw new Error("Unknown variable!");
    }
    return this.varTable[identifier];
  };

  PCCProcessFrame.prototype.assignContainerToVariable = function(identifier, container) {
    if (this.varTable[identifier] === void 0) {
      throw new Error("Unknown variable!");
    }
    return this.varTable[identifier] = container;
  };

  PCCProcessFrame.prototype.addLocalVariable = function(variable, container) {
    if (!this.varTable[variable.getIdentifier()]) {
      this.variables.push(variable);
    }
    return this.varTable[variable.getIdentifier()] = container;
  };

  PCCProcessFrame.prototype.protectContainer = function(container) {
    return this.protections.push(container);
  };

  PCCProcessFrame.prototype.unprotectContainer = function() {
    return this.protections.pop();
  };

  /*
  		Returns the last pushed temporary value.
  */


  PCCProcessFrame.prototype.getProtectedContainer = function() {
    if (this.protections.length === 0) {
      throw new Error("No protected containers available");
    }
    return this.protections[this.protections.length - 1];
  };

  PCCProcessFrame.prototype.isContainerLocalVariable = function(container) {
    var c, v, _ref;
    _ref = this.varTable;
    for (v in _ref) {
      c = _ref[v];
      if (container.isEqual(c)) {
        return true;
      }
    }
    return false;
  };

  PCCProcessFrame.prototype.createFollowupFrame = function() {
    return PCCProcessFrame.createFollowupFrameForFrames([this]);
  };

  PCCProcessFrame.prototype._createFollowupFrameAcceptingTempTypes = function(tempTypes) {
    return new PCCProcessFrame(this.groupable, this.variables.slice(0), tempTypes);
  };

  PCCProcessFrame.prototype.getTypesForTemporaryValues = function() {
    var c, _i, _len, _ref, _results;
    _ref = this.protections;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.ccsType);
    }
    return _results;
  };

  PCCProcessFrame.prototype.createScope = function() {
    var res;
    res = new PCCProcessFrame(this.groupable, this.variables.slice(0), this.getTypesForTemporaryValues(), false);
    this._configureVariablesInScope(res);
    return res;
  };

  PCCProcessFrame.prototype._configureVariablesInScope = function(res) {
    res.processID = this.processID;
    res.initialVariableCount = this.variables.length;
    res.parentFrame = this;
    res.isScope = true;
    return null;
  };

  /*
  		Guarantees that it is allowed to transition from »frame« to the receiver of the method call.
  */


  PCCProcessFrame.prototype._checkTransitionConsistency = function(frame) {
    var fail, i, _i, _ref;
    fail = frame.protections.length !== this.tempTypes.length;
    if (frame.groupable !== this.groupable) {
      fail = true;
    }
    fail = this.isScope && this.varTable;
    if (frame.variables.length < this.initialVariableCount) {
      fail = true;
    }
    for (i = _i = 0, _ref = this.initialVariableCount; _i < _ref; i = _i += 1) {
      if (this.variables[i].getIdentifier() !== frame.variables[i].getIdentifier()) {
        fail = true;
        break;
      }
    }
    if (fail) {
      throw new Error("Call consistency is violated!");
    }
    return null;
  };

  PCCProcessFrame.prototype._variablesForTransition = function() {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = this.initialVariableCount; _i < _ref; i = _i += 1) {
      _results.push(this.variables[i]);
    }
    return _results;
  };

  PCCProcessFrame.prototype._argumentsToCallProcessFromFrame = function(frame) {
    var args, v;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = this._variablesForTransition();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(frame.varTable[v.getIdentifier()]);
      }
      return _results;
    }).call(this);
    return args.concat(frame.protections.slice(0, this.tempTypes.length));
  };

  PCCProcessFrame.prototype.emitCallProcessFromFrame = function(compiler, frame, appPlaceholder) {
    var args;
    this._checkTransitionConsistency(frame);
    args = this._argumentsToCallProcessFromFrame(frame);
    return this.emitCallProcessWithArgumentContainers(compiler, args, appPlaceholder);
  };

  PCCProcessFrame.prototype.emitCallProcessWithArgumentContainers = function(compiler, containers, appPlaceholder) {
    if (this.isScope) {
      throw new Error("Illegal operation! This method cannot be used with scopes!");
    }
    if (containers.length !== this._getProcessArgCount()) {
      throw new Error("Number of argument containers does not match number of required arguments");
    }
    if (appPlaceholder) {
      return appPlaceholder.set(this._getProcessName(), containers);
    } else {
      return compiler.emitProcessApplication(this._getProcessName(), containers);
    }
  };

  PCCProcessFrame.prototype._emitScopeTransition = function(compiler, frame) {
    var v, _i, _len, _ref;
    this.containerIndex = frame.containerIndex;
    this.usedContainers = frame.usedContainers.slice(0);
    this.varTable = {};
    _ref = this._variablesForTransition();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      this.varTable[v.getIdentifier()] = frame.varTable[v.getIdentifier()];
    }
    return this.protections = frame.protections.slice(0);
  };

  PCCProcessFrame.prototype.emitTransitionFromFrame = function(compiler, frame) {
    if (this.isScope) {
      this._checkTransitionConsistency(frame);
      return this._emitScopeTransition(compiler, frame);
    } else {
      return this.emitCallProcessFromFrame(compiler, frame);
    }
  };

  return PCCProcessFrame;

})();

PCCProcedureFrame = (function(_super) {
  __extends(PCCProcedureFrame, _super);

  function PCCProcedureFrame(procedure, variables, tempTypes, autoInit) {
    if (!variables) {
      variables = procedure["arguments"];
      if (procedure.isClassProcedure()) {
        variables.unshift(new PCCVariableInfo(null, "i", null, true));
      }
    }
    PCCProcedureFrame.__super__.constructor.call(this, procedure, variables, tempTypes, autoInit);
  }

  PCCProcedureFrame.prototype.getProcedure = function() {
    return this.groupable;
  };

  PCCProcedureFrame.prototype._createFollowupFrameAcceptingTempTypes = function(tempTypes) {
    return new PCCProcedureFrame(this.groupable, this.variables.slice(0), tempTypes);
  };

  PCCProcedureFrame.prototype.createScope = function() {
    var res;
    res = new PCCProcedureFrame(this.groupable, this.variables.slice(0), this.getTypesForTemporaryValues(), false);
    this._configureVariablesInScope(res);
    return res;
  };

  return PCCProcedureFrame;

})(PCCProcessFrame);

/*
	This method creates a new process frame.
	@param frames: The array with the process frames that the new frame should be derived by.
*/


PCCProcessFrame.createFollowupFrameForFrames = function(frames) {
  var closestAncestor, result;
  PCCProcessFrame.checkFramesForConsistency(frames);
  closestAncestor = PCCProcessFrame.findClosesAncestorForFrames(frames);
  result = closestAncestor._createFollowupFrameAcceptingTempTypes(frames[0].getTypesForTemporaryValues());
  result.parentFrame = closestAncestor;
  return result;
};

/*
	Helping methods for creating a new frame.
*/


PCCProcessFrame.checkTempTypesEquality = function(prot1, prot2) {
  var i, _i, _ref;
  if (prot1.length !== prot2.length) {
    return false;
  }
  for (i = _i = 0, _ref = prot1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (!prot1[i].ccsType.isEqual(prot2[i].ccsType)) {
      return false;
    }
  }
  return true;
};

PCCProcessFrame.checkFramesForConsistency = function(frames) {
  var groupable, i, protections, _i, _ref;
  groupable = frames[0].groupable;
  protections = frames[0].protections;
  for (i = _i = 1, _ref = frames.length; _i < _ref; i = _i += 1) {
    if (frames[i].groupable !== groupable || !PCCProcessFrame.checkTempTypesEquality(protections, frames[i].protections)) {
      throw new Error("Inconsistent process frames");
    }
  }
  return null;
};

PCCProcessFrame.prototype.parentFrame = null;

PCCProcessFrame.prototype.mark = function(m) {
  if (!this.marked) {
    this.marked = [];
  }
  return this.marked.push(m);
};

PCCProcessFrame.findClosesAncestorForFrames = function(frames) {
  var closestAncestor, currentFrames, f, i, markedFrames, _i, _j, _len, _ref;
  closestAncestor = null;
  markedFrames = [];
  currentFrames = frames.concat([]);
  while (closestAncestor === null) {
    for (i = _i = 0, _ref = frames.length; _i < _ref; i = _i += 1) {
      if (currentFrames[i] !== null) {
        currentFrames[i].mark(frames[i]);
        markedFrames.push(currentFrames[i]);
        if (currentFrames[i].marked.length === frames.length) {
          closestAncestor = currentFrames[i];
          break;
        }
        currentFrames[i] = currentFrames[i].parentFrame;
      }
    }
  }
  for (_j = 0, _len = markedFrames.length; _j < _len; _j++) {
    f = markedFrames[_j];
    f.marked = null;
  }
  return closestAncestor;
};

PCCProcessFrame.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
  var c;
  c = variable.compileDefaultValue(compiler);
  compiler.getProcessFrame().addLocalVariable(variable, c);
  return variable;
};

PCCProcessFrame.prototype.compilerGetVariable = function(compiler, identifier) {
  var v, _i, _len, _ref;
  _ref = this.variables;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    if (v.getIdentifier() === identifier) {
      return new PCCLocalVariable(v.node, v.getName(), v.type, v.isInternal);
    }
  }
  return null;
};

PCCProcessFrame.prototype.compilerGetProcedure = function(compiler, identifier, instanceContainer) {
  return null;
};

PCCProcedureFrame.prototype.compilerGetProcedure = function(compiler, identifier, instanceContainer) {
  var p;
  p = this.getProcedure();
  if (p.getName() === identifier) {
    return p;
  } else {
    return p.getProcedureWithName(identifier);
  }
};

PCCGroupable = (function() {
  function PCCGroupable(processName) {
    this.processName = processName;
  }

  PCCGroupable.prototype.getProcessName = function() {
    return this.processName;
  };

  return PCCGroupable;

})();

/*
class PCCContainerInfo
	constructor: (@payload, @isLocalVariable) ->


class PCCContainerInfoArray
	constructor: (temporaryItems=[]) -> @infos = (new PCCContainerInfo(c, false) for c in temporaryItems)
	copy: ->
		res = new PCCContainerProtectionArray()
		res.infos = @infos[..]
		res
	getCount: ->
		res = 0
		++res for ci in @infos
		res
	
	# Protecting Containers
	protectContainer: (container, isLocalVariable) ->
		@protections.push(new PCCContainerInfo(container, isLocalVariable))
	unprotectContainer: -> @infos.pop().container
	getContainer: ->
		throw new Error("getProtection: Nothing protected at the moment!") if @infos.length == 0
		@infos[@infos.length-1].payload
	getTemporaryContainers: ->
		res = []
		(res.push(ci.payload) if not ci.isLocalVariable) for ci in @infos
		res
	
	getCCSTypes: ->
		res = new PCCContainerInfoArray()
		res.infos = (new PCCContainerInfo(ci.payload.ccsType, ci.isLocalVariable) for ci in @infos)
		res
		
	getTemporaryTypes: ->
		res = []
		return res if infos.length == 0
		if @infos[0].payload instanceof PCCContainer
			(res.push(ci.payload.ccsType) if not cp.isLocalVariable) for ci in @infos
		else if infos[0].payload instanceof PCCType
			(res.push(ci.payload) if not cp.isLocalVariable) for ci in @infos
		else
			throw new Error("getTemporaryTypes not applicable on payload!")
		res
*/


/*

{version: "1.0", tree: (new PCProgram((new PCDecl(true, (new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("x", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(42))))))))), (new PCMainAgent((new PCStmtBlock((new PCDecl(true, (new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("y", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(7))))))))), (new PCStatement((new PCForStmt((new PCStatement((new PCStmtBlock((new PCStatement((new PCPrintStmt((new PCAdditiveExpression((new PCLiteralExpression("Die Zahl ist ")), "+", (new PCAdditiveExpression((new PCAdditiveExpression((new PCIdentifierExpression("x")), "+", (new PCIdentifierExpression("y")))), "+", (new PCIdentifierExpression("i")))))))))))))), (new PCForInit((new PCDecl(false, (new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("i", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(0))))))))))), (new PCRelationalExpression((new PCIdentifierExpression("i")), "<", (new PCLiteralExpression(parseInt(10))))), (new PCStmtExpression((new PCPostfixExpression((new PCAssignDestination("i")), "++"))))))))))))))}
*/


/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	PCCProgramController manages all variables, classes, procedures and the relationships between each other that occur in a PseuCo program.
*/


PCCGlobal = (function(_super) {
  __extends(PCCGlobal, _super);

  function PCCGlobal(program) {
    PCCGlobal.__super__.constructor.call(this, program, "");
  }

  PCCGlobal.prototype.getVariableClass = function() {
    return PCCGlobalVariable;
  };

  PCCGlobal.prototype.compilerGetVariable = function(compiler, identifier) {
    return this.getVariableWithName(identifier);
  };

  PCCGlobal.prototype.compilerGetProcedure = function(compiler, identifier) {
    return this.getProcedureWithName(identifier);
  };

  PCCGlobal.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
    variable = this.getVariableWithName(variable.getName());
    if (variable === void 0) {
      throw new Error("Unexpected new identifier found!");
    }
    variable.emitConstructor(compiler);
    return variable;
  };

  return PCCGlobal;

})(PC.EnvironmentNode);

PCCClass = (function(_super) {
  __extends(PCCClass, _super);

  function PCCClass() {
    PCCClass.__super__.constructor.apply(this, arguments);
    this.addChild(new PCCInternalReadOnlyField(null, "guard", new PC.Type(PC.Type.MUTEX), true));
  }

  PCCClass.prototype.getAllConditions = function() {
    var n, result, v, _ref;
    result = [];
    _ref = this.variables;
    for (n in _ref) {
      v = _ref[n];
      if (v.type && v.type.kind === PC.Type.CONDITION) {
        result.push(v);
      }
    }
    return result;
  };

  PCCClass.prototype.getVariableClass = function() {
    return PCCField;
  };

  PCCClass.prototype.compilerGetVariable = function(compiler, identifier) {
    return this.getVariableWithName(identifier);
  };

  PCCClass.prototype.compilerGetProcedure = function(compiler, identifier) {
    return this.getProcedureWithName(identifier);
  };

  PCCClass.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
    return this.getVariableWithName(variable.getName());
  };

  PCCClass.prototype.emitEnvironment = function(compiler) {
    var control, i, instance, n, names, v, variables, _i, _ref;
    variables = (function() {
      var _ref, _results;
      _ref = this.variables;
      _results = [];
      for (n in _ref) {
        v = _ref[n];
        _results.push(v);
      }
      return _results;
    }).call(this);
    instance = new PCCVariableInfo(null, "i", this.type, true);
    variables.unshift(instance);
    compiler.beginProcessGroup(new PCCGroupable(this.getEnvProcessName()), variables);
    variables = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(compiler.getVariableWithName(v.getIdentifier()));
      }
      return _results;
    })();
    names = (function() {
      var _results;
      _results = [];
      for (n in this.variables) {
        _results.push(n);
      }
      return _results;
    }).call(this);
    for (i = _i = 0, _ref = names.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      control = compiler.emitChoice();
      this.variables[names[i]].emitAccessors(compiler, variables, variables[0].getContainer(compiler));
      control.setBranchFinished();
    }
    this.variables[names[names.length - 1]].emitAccessors(compiler, variables, variables[0].getContainer(compiler));
    return compiler.endProcessGroup();
  };

  PCCClass.prototype.emitConstructor = function(compiler) {
    var hasVariables, n;
    hasVariables = false;
    for (n in this.variables) {
      hasVariables = true;
      break;
    }
    if (!hasVariables) {
      return;
    }
    this.emitEnvironment(compiler);
    PCCConstructor.emitConstructor(compiler, this);
    return compiler.emitSystemProcessApplication(this.getProcessName(), [new PCCConstantContainer(1)]);
  };

  PCCClass.prototype.constructorGetName = function() {
    return this.getEnvProcessName();
  };

  PCCClass.prototype.constructorGetArguments = function() {
    return [new PCCVariableInfo(null, "next_i", this.type, true)];
  };

  PCCClass.prototype.constructorProtectEnvironmentArguments = function(cons, compiler, variables) {
    var c, instance, n, res, v, _ref;
    instance = variables[0];
    compiler.emitOutput("class_" + (this.getName()) + "_create", null, instance.getContainer(compiler));
    compiler.protectContainer(instance.getContainer(compiler));
    res = 1;
    _ref = this.variables;
    for (n in _ref) {
      v = _ref[n];
      c = v.compileDefaultValue(compiler);
      compiler.protectContainer(c);
      res++;
    }
    return res;
  };

  PCCClass.prototype.constructorShouldCallRecursively = function() {
    return true;
  };

  PCCClass.prototype.constructorUpdateVariablesForRecursiveCall = function(cons, compiler, entry, variables) {
    var instance, new_i;
    instance = variables[0];
    new_i = new PCCBinaryContainer(instance.getContainer(compiler), new PCCConstantContainer(1), "+");
    return instance.setContainer(compiler, new_i);
  };

  PCCClass.prototype.getProcessName = function() {
    return "Env_class_" + (this.getName()) + "_cons";
  };

  PCCClass.prototype.getEnvProcessName = function() {
    return "Env_class_" + (this.getName());
  };

  return PCCClass;

})(PC.Class);

PCCProcedure = (function(_super) {
  __extends(PCCProcedure, _super);

  function PCCProcedure() {
    _ref = PCCProcedure.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PCCProcedure.prototype.getProcessName = function() {
    return "Proc" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getAgentStarterChannel = function() {
    return "start" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getAgentProcessName = function() {
    return "Agent" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getVariableClass = function() {
    return PCCLocalVariable;
  };

  PCCProcedure.prototype.getAllArgumentContainers = function(compiler, explicitArgumentContainers, instanceContainer) {
    var argumentContainers;
    argumentContainers = explicitArgumentContainers.slice(0);
    if (this.isClassProcedure()) {
      if (!instanceContainer) {
        instanceContainer = compiler.getVariableWithName("i", null, true).getContainer(compiler);
      }
      argumentContainers.unshift(instanceContainer);
    } else {
      if (instanceContainer) {
        throw new Error("Illegal instance value");
      }
    }
    return argumentContainers;
  };

  PCCProcedure.prototype.getImplicitAndExplicitArgumentCount = function() {
    var res;
    res = this["arguments"].length;
    if (this.isClassProcedure()) {
      res++;
    }
    return res;
  };

  PCCProcedure.prototype.emitAgentConstructor = function(compiler) {
    var a, args, control1, control2, control3, definitionName, i, j, _i, _ref1;
    definitionName = this.getAgentProcessName();
    compiler.beginProcessDefinition(definitionName, []);
    i = new PCCVariableContainer("i", PCCType.INT);
    compiler.emitInput("agent_new", null, i);
    compiler.emitOutput(this.getAgentStarterChannel(), null, i);
    args = [];
    for (j = _i = 0, _ref1 = this.getImplicitAndExplicitArgumentCount(); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; j = 0 <= _ref1 ? ++_i : --_i) {
      a = new PCCVariableContainer("a" + j, PCCType.VOID);
      compiler.emitInput("start_set_arg", i, a);
      args.push(a);
    }
    control1 = compiler.emitParallel();
    compiler.emitProcessApplication(definitionName, []);
    control1.setBranchFinished();
    control2 = compiler.emitParallel();
    control3 = compiler.emitSequence();
    compiler.emitProcessApplication(this.getProcessName(), args);
    control3.setBranchFinished();
    compiler.emitOutput("agent_terminate", i, null);
    compiler.emitStop();
    control3.setBranchFinished();
    control2.setBranchFinished();
    compiler.emitProcessApplication("AgentJoiner", [i, new PCCConstantContainer(0)]);
    control2.setBranchFinished();
    control1.setBranchFinished();
    return compiler.endProcessDefinition();
  };

  PCCProcedure.prototype.emitExit = function(compiler) {
    var guard;
    if (this.isMonitorProcedure()) {
      guard = compiler.getVariableWithName("guard", null, true);
      compiler.emitOutput("unlock", guard.getContainer(compiler));
    }
    return compiler.emitExit();
  };

  return PCCProcedure;

})(PC.Procedure);

/*
	PCCType represents CCS types, and - if an integer is used as a reference - the referenced CCS type.
*/


PCCType = (function() {
  function PCCType(_type, _className) {
    this._type = _type;
    this._className = _className;
    if (!this._type && this._className) {
      this._type = 1;
    }
  }

  PCCType.prototype.isVoid = function() {
    return this._type === -1;
  };

  PCCType.prototype.isBool = function() {
    return this._type === 0;
  };

  PCCType.prototype.isInt = function() {
    return this._type === 1;
  };

  PCCType.prototype.isString = function() {
    return this._type === 2;
  };

  PCCType.prototype.isArray = function() {
    return this._type instanceof PCCType;
  };

  PCCType.prototype.isClass = function() {
    if (this._className) {
      return true;
    } else {
      return false;
    }
  };

  PCCType.prototype.getClassName = function() {
    if (!this._className) {
      throw new Error("Can't get class name for non-class type!");
    }
    return this._className;
  };

  PCCType.prototype.isEqual = function(type) {
    if (this.isArray()) {
      return type.isArray() && this._type.isEqual(type._type);
    } else {
      return this._type === type._type;
    }
  };

  PCCType.prototype.getSubtype = function() {
    if (!this.isArray()) {
      throw new Error("Cannot get subtype for non-array type!");
    }
    return this._type._type;
  };

  PCCType.prototype.getDefaultContainer = function() {
    if (this.isArray() || this.isClass()) {
      return new PCCConstantContainer(0);
    }
    return new PCCConstantContainer((function() {
      switch (this._type) {
        case 0:
          return false;
        case 1:
          return 0;
        case 2:
          return "";
        default:
          throw new Error("Void does not have a default value");
      }
    }).call(this));
  };

  return PCCType;

})();

PCCType.VOID = new PCCType(-1);

PCCType.BOOL = new PCCType(0);

PCCType.INT = new PCCType(1);

PCCType.STRING = new PCCType(2);

PC.Type.prototype.getCCSType = function() {
  switch (this.kind) {
    case PC.Type.INT:
      return PCCType.INT;
    case PC.Type.BOOL:
      return PCCType.BOOL;
    case PC.Type.STRING:
      return PCCType.STRING;
    case PC.Type.CHANNEL:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.ARRAY:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.MONITOR:
      return PCCType.INT;
    case PC.Type.STRUCTURE:
      return PCCType.INT;
    case PC.Type.MUTEX:
      return PCCType.INT;
    case PC.Type.CONDITION:
      return PCCType.INT;
    case PC.Type.PROCEDURE:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.TYPE:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.MAINAGENT:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.AGENT:
      return PCCType.INT;
    case PC.Type.WILDCARD:
      throw new Error("Unexpected type kind!");
      break;
    default:
      return PCCType.VOID;
  }
};

PC.ArrayType.prototype.getCCSType = function() {
  return new PCCType(this.elementsType.getCCSType());
};

PC.ChannelType.prototype.getCCSType = function() {
  return new PCCType(this.channelledType.getCCSType());
};

PC.ProcedureType.prototype.getCCSType = function() {
  return this.returnType.getCCSType();
};

PC.ProcedureType.prototype.getCCSArgumentTypes = function() {
  var t, _i, _len, _ref1, _results;
  _ref1 = this.argumentTypes;
  _results = [];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    t = _ref1[_i];
    _results.push(t.getCCSType());
  }
  return _results;
};

/*
PCTArrayType::fulfillAssignment = (compiler, container) ->
	result = compiler.getFreshContainer(container.ccsType)
	compiler.emitInput("array_copy", container, result)
	result
*/


PC.ArrayType.prototype.createContainer = function(compiler, containers) {
  var c, i, result, _i, _j, _len, _ref1, _ref2;
  if (containers == null) {
    containers = [];
  }
  result = compiler.getFreshContainer(this.getCCSType());
  compiler.emitInput("array" + this.capacity + "_create", null, result);
  compiler.emitOutput("array_setDefault", result, this.elementsType.getCCSType().getDefaultContainer());
  if (this.elementsType.requiresCustomDefaultContainer()) {
    for (i = _i = _ref1 = containers.length, _ref2 = this.capacity; _i < _ref2; i = _i += 1) {
      containers.push(this.elementsType.createContainer(compiler));
    }
  }
  for (i = _j = 0, _len = containers.length; _j < _len; i = ++_j) {
    c = containers[i];
    compiler.emitOutput("array_access", result, new PCCConstantContainer(i));
    compiler.emitOutput("array_set", result, c);
  }
  return result;
};

PC.Type.prototype.requiresCustomDefaultContainer = function() {
  return this.kind !== PC.Type.INT && this.kind !== PC.Type.BOOL && this.kind !== PC.Type.STRING;
};

PC.Type.prototype.createContainer = function(compiler, container) {
  var result;
  if (container) {
    return container;
  }
  if (this.kind === PC.Type.AGENT) {
    throw new Error("No default value for agents available");
  }
  if (this.kind === PC.Type.VOID) {
    throw new Error("No default value for void available");
  }
  if (this.kind === PC.Type.MUTEX) {
    result = compiler.getFreshContainer(PCCType.INT);
    compiler.emitInput("mutex_create", null, result);
    return result;
  } else if (this.kind === PC.Type.STRING) {
    return new PCCConstantContainer("");
  } else {
    return new PCCConstantContainer(0);
  }
};

PC.ChannelType.prototype.createContainer = function(compiler, container) {
  var buffered, channel, res;
  if (container) {
    return container;
  }
  res = compiler.getFreshContainer(this.getCCSType());
  buffered = this.capacity !== PCChannelType.CAPACITY_UNKNOWN && this.capacity !== 0;
  channel = "channel" + (buffered ? this.capacity : "") + "_create";
  compiler.emitInput(channel, null, res);
  return res;
};

PC.ClassType.prototype.createContainer = function(compiler, container) {
  var result;
  if (container) {
    return container;
  }
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput("class_" + this.identifier + "_create", null, result);
  return result;
};

PCCVariableInfo = (function(_super) {
  __extends(PCCVariableInfo, _super);

  function PCCVariableInfo(node, name, type, isInternal) {
    this.isInternal = isInternal != null ? isInternal : false;
    PCCVariableInfo.__super__.constructor.call(this, node, name, type);
  }

  PCCVariableInfo.prototype.getIdentifier = function() {
    return "" + (this.isInternal ? "#" : "") + (this.getName());
  };

  PCCVariableInfo.prototype.getSuggestedContainerName = function() {
    return this.getName() + (this.isInternal ? "H" : "L");
  };

  return PCCVariableInfo;

})(PC.Variable);

PCCVariableInfo.getNameForInternalVariableWithName = function(name) {
  return "#" + name;
};

PC.Variable.prototype.getSuggestedContainerName = function() {
  return this.getName() + "L";
};

PC.Variable.prototype.getCCSType = function() {
  return this.type.getCCSType();
};

PC.Variable.prototype.compileDefaultValue = function(compiler) {
  if (this.node) {
    return this.node.compileDefaultValue(compiler);
  } else {
    return this.type.createContainer(compiler);
  }
};

PCCVariableInfo.prototype.getCCSType = function() {
  if (this.type || !this.isInternal) {
    return PCCVariableInfo.__super__.getCCSType.apply(this, arguments);
  } else {
    return PCCType.INT;
  }
};

PCCVariable = (function(_super) {
  __extends(PCCVariable, _super);

  function PCCVariable() {
    _ref1 = PCCVariable.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  PCCVariable.prototype.getContainer = function(compiler) {
    throw new Error("Not implemented!");
  };

  PCCVariable.prototype.setContainer = function(compiler, container) {
    throw new Error("Not implemented");
  };

  return PCCVariable;

})(PCCVariableInfo);

PCCGlobalVariable = (function(_super) {
  __extends(PCCGlobalVariable, _super);

  function PCCGlobalVariable() {
    _ref2 = PCCGlobalVariable.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  PCCGlobalVariable.prototype.accessorChannel = function(set) {
    return "env_global_" + (set ? "set" : "get") + "_" + (this.getName());
  };

  PCCGlobalVariable.prototype.getContainer = function(compiler) {
    var result;
    result = compiler.getFreshContainer(this.type.getCCSType());
    compiler.emitInput(this.accessorChannel(false), null, result);
    return result;
  };

  PCCGlobalVariable.prototype.setContainer = function(compiler, container) {
    compiler.emitOutput(this.accessorChannel(true), null, container);
    return null;
  };

  PCCGlobalVariable.prototype.emitAccessors = function(compiler, variables, instance) {
    var c, containers, control, local, v;
    if (instance == null) {
      instance = null;
    }
    local = compiler.getVariableWithName(this.getIdentifier());
    containers = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(v.getContainer(compiler));
      }
      return _results;
    })();
    control = compiler.emitChoice();
    c = local.getContainer(compiler);
    compiler.emitOutput(this.accessorChannel(false), instance, c);
    compiler.emitProcessApplication(this.getEnvProcessName(), containers);
    control.setBranchFinished();
    compiler.emitInput(this.accessorChannel(true), instance, c);
    compiler.emitProcessApplication(this.getEnvProcessName(), containers);
    return control.setBranchFinished();
  };

  PCCGlobalVariable.prototype.emitConstructor = function(compiler) {
    var container;
    compiler.beginProcessGroup(new PCCGroupable(this.getEnvProcessName()), [this]);
    this.emitAccessors(compiler, [compiler.getVariableWithName(this.getName())]);
    compiler.endProcessGroup();
    compiler.beginProcessGroup(this);
    container = this.compileDefaultValue(compiler);
    compiler.emitProcessApplication(this.getEnvProcessName(), [container]);
    compiler.endProcessGroup();
    return compiler.emitSystemProcessApplication(this.getProcessName(), []);
  };

  PCCGlobalVariable.prototype.getProcessName = function() {
    return "Env_global_" + (this.getName()) + "_cons";
  };

  PCCGlobalVariable.prototype.getEnvProcessName = function() {
    return "Env_global_" + (this.getName());
  };

  return PCCGlobalVariable;

})(PCCVariable);

PCCField = (function(_super) {
  __extends(PCCField, _super);

  function PCCField() {
    _ref3 = PCCField.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  PCCField.prototype.accessorChannel = function(set) {
    return "env_class_" + (this.parent.getName()) + "_" + (set ? "set" : "get") + "_" + (this.getName());
  };

  PCCField.prototype.getContainer = function(compiler) {
    var result;
    if (this.getIdentifier() === "#guard") {
      result = compiler.getFreshContainer(PCCType.INT);
      compiler.emitInput("env_class_get_guard", compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    } else {
      result = compiler.getFreshContainer(this.type.getCCSType());
      compiler.emitInput(this.accessorChannel(false), compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    }
    return result;
  };

  PCCField.prototype.setContainer = function(compiler, container) {
    compiler.emitOutput(this.accessorChannel(true), compiler.getVariableWithName("i", null, true).getContainer(compiler), container);
    return null;
  };

  PCCField.prototype.getEnvProcessName = function() {
    return "Env_class_" + (this.parent.getName());
  };

  return PCCField;

})(PCCGlobalVariable);

PCCInternalReadOnlyField = (function(_super) {
  __extends(PCCInternalReadOnlyField, _super);

  function PCCInternalReadOnlyField() {
    _ref4 = PCCInternalReadOnlyField.__super__.constructor.apply(this, arguments);
    return _ref4;
  }

  PCCInternalReadOnlyField.prototype.emitAccessors = function(compiler, variables, instance) {
    var c, containers, local, v;
    local = compiler.getVariableWithName(this.getIdentifier());
    containers = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(v.getContainer(compiler));
      }
      return _results;
    })();
    c = local.getContainer(compiler);
    compiler.emitOutput("env_class_guard", instance, c);
    return compiler.emitProcessApplication(this.getEnvProcessName(), containers);
  };

  PCCInternalReadOnlyField.prototype.getContainer = function(compiler) {
    var result;
    result = compiler.getFreshContainer(PCCType.INT);
    compiler.emitInput("env_class_guard", compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    return result;
  };

  PCCInternalReadOnlyField.prototype.setContainer = function() {
    throw new Error("Setting container for read only variable!");
  };

  return PCCInternalReadOnlyField;

})(PCCField);

PCCCondition = (function(_super) {
  __extends(PCCCondition, _super);

  function PCCCondition(name, expressionNode) {
    this.expressionNode = expressionNode;
    PCCCondition.__super__.constructor.call(this, name, new PC.Type(PC.Type.CONDITION));
  }

  return PCCCondition;

})(PCCField);

PCCLocalVariable = (function(_super) {
  __extends(PCCLocalVariable, _super);

  function PCCLocalVariable() {
    _ref5 = PCCLocalVariable.__super__.constructor.apply(this, arguments);
    return _ref5;
  }

  PCCLocalVariable.prototype.getContainer = function(compiler) {
    return compiler.getProcessFrame().getContainerForVariable(this.getIdentifier());
  };

  PCCLocalVariable.prototype.setContainer = function(compiler, container) {
    return compiler.getProcessFrame().assignContainerToVariable(this.getIdentifier(), container);
  };

  return PCCLocalVariable;

})(PCCVariable);

PCCProgramController = (function(_super) {
  __extends(PCCProgramController, _super);

  function PCCProgramController() {
    PCCProgramController.__super__.constructor.apply(this, arguments);
    this.root = new PCCGlobal();
    this.agents = {};
    this._envStack = this.root;
  }

  PCCProgramController.prototype.processNewClass = function(node, classType) {
    var tnode;
    tnode = new PCCClass(node, classType);
    return this._processNewClass(tnode);
  };

  PCCProgramController.prototype.beginNewProcedure = function(node, procedureName, returnType, args) {
    var tnode;
    tnode = new PCCProcedure(node, procedureName, returnType, args);
    return this._beginNewProcedure(tnode);
  };

  PCCProgramController.prototype.processNewVariable = function(variable) {
    var tnode, varClass;
    varClass = this._envStack.getVariableClass();
    tnode = new varClass(variable.node, variable.getName(), variable.type);
    return this._processNewVariable(tnode);
  };

  PCCProgramController.prototype.processProcedureAsAgent = function(procedure) {
    return this.agents[procedure.getName()] = procedure;
  };

  PCCProgramController.prototype.getAgents = function() {
    var p, proc, res;
    res = [];
    for (p in this.agents) {
      proc = this.agents[p];
      if (proc instanceof PC.Procedure) {
        res.push(proc);
      }
    }
    return res;
  };

  PCCProgramController.prototype.getUsedTypes = function() {
    var res;
    res = {
      arrays: {},
      channels: {}
    };
    this.root.getUsedTypes(res);
    return res;
  };

  return PCCProgramController;

})(PC.EnvironmentController);

PC.EnvironmentNode.prototype.getUsedTypes = function(res) {
  var c, _i, _len, _ref6;
  _ref6 = this.children;
  for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
    c = _ref6[_i];
    c.getUsedTypes(res);
  }
  return null;
};

PC.Variable.prototype.getUsedTypes = function(res) {
  return this.type.getUsedTypes(res);
};

PC.Type.prototype.getUsedTypes = function() {
  return null;
};

PC.ArrayType.prototype.getUsedTypes = function(res) {
  res.arrays[this.capacity] = true;
  this.elementsType.getUsedTypes(res);
  return null;
};

PC.ChannelType.prototype.getUsedTypes = function(res) {
  res.channels[this.getApplicableCapacity()] = true;
  return null;
};

PC.Node.prototype.collectAgents = function(env) {
  var c, _i, _len, _ref6, _results;
  _ref6 = this.children;
  _results = [];
  for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
    c = _ref6[_i];
    _results.push(c.collectAgents(env));
  }
  return _results;
};

_t = PC.Monitor;

_t.prototype.collectAgents = function(env) {
  env.beginClass(this.name);
  _t.__super__.collectAgents.apply(this, arguments);
  return env.endClass();
};

_t = PC.Struct;

_t.prototype.collectAgents = function(env) {
  env.beginClass(this.name);
  _t.__super__.collectAgents.apply(this, arguments);
  return env.endClass();
};

_t = PC.ProcedureDecl;

_t.prototype.collectAgents = function(env) {
  env.beginProcedure(this.name);
  _t.__super__.collectAgents.apply(this, arguments);
  return env.endProcedure();
};

PC.StartExpression.prototype.collectAgents = function(env) {
  return env.processProcedureAsAgent(this.children[0].getProcedure(env));
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	Manages different kinds of containers. Containers basically wrap CCS Expressions.
*/


PCCContainer = (function() {
  function PCCContainer(ccsType) {
    this.ccsType = ccsType;
  }

  PCCContainer.prototype.isReadonly = function() {
    throw new Error("Abstract");
  };

  PCCContainer.prototype.ccsTree = function() {
    throw new Error("Abstract");
  };

  PCCContainer.prototype.isEqual = function(container) {
    throw new Error("Abstract");
  };

  return PCCContainer;

})();

PCCConstantContainer = (function(_super) {
  __extends(PCCConstantContainer, _super);

  function PCCConstantContainer(value) {
    this.value = value;
    if (typeof this.value === "boolean") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (typeof this.value === "number") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (typeof this.value === "string") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.STRING);
    } else {
      throw new Error("Unknown type");
    }
  }

  PCCConstantContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCConstantContainer.prototype.ccsTree = function() {
    return new CCS.ConstantExpression(this.value);
  };

  PCCConstantContainer.prototype.isEqual = function(container) {
    return container instanceof PCCConstantContainer && container.value === this.value;
  };

  return PCCConstantContainer;

})(PCCContainer);

PCCVariableContainer = (function(_super) {
  __extends(PCCVariableContainer, _super);

  function PCCVariableContainer(identifier, ccsType) {
    this.identifier = identifier;
    PCCVariableContainer.__super__.constructor.call(this, ccsType);
  }

  PCCVariableContainer.prototype.isReadonly = function() {
    return false;
  };

  PCCVariableContainer.prototype.ccsTree = function() {
    return new CCS.VariableExpression(this.identifier);
  };

  PCCVariableContainer.prototype.isEqual = function(container) {
    return container instanceof PCCVariableContainer && container.identifier === this.identifier;
  };

  return PCCVariableContainer;

})(PCCContainer);

PCCComposedContainer = (function(_super) {
  __extends(PCCComposedContainer, _super);

  function PCCComposedContainer(ccsType) {
    PCCComposedContainer.__super__.constructor.call(this, ccsType);
  }

  return PCCComposedContainer;

})(PCCContainer);

PCCBinaryContainer = (function(_super) {
  __extends(PCCBinaryContainer, _super);

  function PCCBinaryContainer(leftContainer, rightContainer, operator) {
    this.leftContainer = leftContainer;
    this.rightContainer = rightContainer;
    this.operator = operator;
    if (this.operator === "+" || this.operator === "^") {
      if (this.leftContainer.ccsType.isString() || this.rightContainer.ccsType.isString() || this.operator === "^") {
        this.exp = new CCS.ConcatenatingExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree());
        PCCBinaryContainer.__super__.constructor.call(this, PCCType.STRING);
      } else {
        this.exp = new CCS.AdditiveExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
        PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
      }
    } else if (this.operator === "-") {
      this.exp = new CCS.AdditiveExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator === "*" || this.operator === "/" || this.operator === "%") {
      this.exp = new CCS.MultiplicativeExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator === "<" || this.operator === "<=" || this.operator === ">" || this.operator === ">=") {
      this.exp = new CCS.RelationalExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "==" || this.operator === "!=") {
      this.exp = new CCS.EqualityExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "&&") {
      throw new Error("Not available in CCS");
    } else if (this.operator === "||") {
      throw new Error("Not available in CCS");
    } else {
      throw new Error("Unknown operator");
    }
  }

  PCCBinaryContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCBinaryContainer.prototype.ccsTree = function() {
    return this.exp;
  };

  PCCBinaryContainer.prototype.isEqual = function(container) {
    return container instanceof PCCBinaryContainer && container.operator === this.operator && container.leftContainer.isEqual(this.leftContainer) && container.rightContainer.isEqual(this.rightContainer);
  };

  return PCCBinaryContainer;

})(PCCComposedContainer);

PCCUnaryContainer = (function(_super) {
  __extends(PCCUnaryContainer, _super);

  function PCCUnaryContainer(operator, container) {
    this.operator = operator;
    this.container = container;
    if (this.operator === "!") {
      this.exp = new CCS.EqualityExpression(this.container.ccsTree(), new CCSConstantExpression(false), "==");
      PCCUnaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "-") {
      this.exp = new CCS.AdditiveExpression(new CCSConstantExpression(0), this.container.ccsTree(), "-");
      PCCUnaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator !== "+") {
      throw new Error("Unknown operator");
    }
  }

  PCCUnaryContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCUnaryContainer.prototype.ccsTree = function() {
    return this.exp;
  };

  PCCUnaryContainer.prototype.isEqual = function(container) {
    return container instanceof PCCConstantContainer && container.operator === this.operator && container.container.isEqual(this.container);
  };

  return PCCUnaryContainer;

})(PCCComposedContainer);

/*
PCCContainer.RETURN = -> new PCCVariableContainer("i_r")
PCCContainer.INSTANCE = -> new PCCVariableContainer("i_i")
PCCContainer.GUARD = -> new PCCVariableContainer("i_g")
*/


/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


PCCStackElement = (function() {
  function PCCStackElement() {
    this.parent = null;
  }

  PCCStackElement.prototype.getResult = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.getNext = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.setNext = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.removeNext = function(next) {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.getTopElement = function() {
    var next;
    next = this.getNext();
    if (next === null) {
      return this;
    } else {
      return next.getTopElement();
    }
  };

  PCCStackElement.prototype.getCurrentProcessFrame = function() {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.getCurrentProcessFrame() : void 0;
  };

  PCCStackElement.prototype.getCurrentControlElement = function() {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.getCurrentControlElement() : void 0;
  };

  PCCStackElement.prototype.getResults = function() {
    throw new Error("Not implemented");
  };

  PCCStackElement.prototype.removeFromStack = function() {
    var _ref6;
    this.getStack().setTopElement(this.parent);
    if ((_ref6 = this.parent) != null) {
      _ref6.removeNext(this);
    }
    return this.getResults();
  };

  PCCStackElement.prototype.isCompletedProcess = function() {
    return false;
  };

  PCCStackElement.prototype.createCalculusNode = function() {
    var args, cons, res;
    cons = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    res = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(cons, args, function(){});
    res.pseucoNode = this.pseucoNode;
    if (this.pseucoNode) {
      this.pseucoNode.addCalculusComponent(res);
    }
    return res;
  };

  PCCStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.compilerGetVariable(compiler, identifier) : void 0;
  };

  PCCStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.compilerGetProcedure(compiler, identifier) : void 0;
  };

  PCCStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context) : void 0;
  };

  return PCCStackElement;

})();

PCCUnaryStackElement = (function(_super) {
  __extends(PCCUnaryStackElement, _super);

  function PCCUnaryStackElement() {
    this.next = null;
    PCCUnaryStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCUnaryStackElement.prototype.getResults = function() {
    if (this.next === null) {
      return new PCCStackResultContainer();
    } else {
      return this.next.getResults();
    }
  };

  PCCUnaryStackElement.prototype.getNext = function() {
    return this.next;
  };

  PCCUnaryStackElement.prototype.setNext = function(next) {
    if (this.next !== null) {
      throw new Error("Can't set next twice!");
    }
    next.parent = this;
    return this.next = next;
  };

  PCCUnaryStackElement.prototype.removeNext = function(next) {
    if (this.next !== next) {
      throw new Error("Unknown next");
    }
    next.parent = null;
    return this.next = null;
  };

  return PCCUnaryStackElement;

})(PCCStackElement);

PCCBinaryStackElement = (function(_super) {
  __extends(PCCBinaryStackElement, _super);

  function PCCBinaryStackElement() {
    this.leftStack = null;
    this.rightStack = null;
    this.topStack = null;
    this.target = 0;
    PCCBinaryStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCBinaryStackElement.prototype.getResults = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCBinaryStackElement.prototype.getNext = function() {
    if (this.target === PCCBinaryTarget.LEFT) {
      return this.leftStack;
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      return this.rightStack;
    } else {
      return this.topStack;
    }
  };

  PCCBinaryStackElement.prototype.setNext = function(next) {
    if (next) {
      next.parent = this;
    }
    if (this.target === PCCBinaryTarget.LEFT) {
      if (this.leftStack) {
        throw new Error("Can't set next twice!");
      }
      return this.leftStack = next;
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      if (this.rightStack) {
        throw new Error("Can't set next twice!");
      }
      return this.rightStack = next;
    } else {
      if (this.topStack) {
        throw new Error("Can't set next twice!");
      }
      return this.topStack = next;
    }
  };

  PCCBinaryStackElement.prototype.removeNext = function(next) {
    if (this.next !== this.getNext()) {
      throw new Error("Unknown next");
    }
    return this.setNext(null);
  };

  PCCBinaryStackElement.prototype.setTarget = function(target) {
    if (target < 0 || target > 2) {
      raise(new Error("Illegal target!"));
    }
    if (target === PCCBinaryTarget.TOP && this.topStack) {
      raise(new Error("Left and right target are not allowed once top was modified!"));
    }
    this.target = target;
    this.getStack().setTopElement(this.getTopElement());
    return this.parent.updateBinaryTargets(this);
  };

  PCCBinaryStackElement.prototype.setBranchFinished = function() {
    if (this.target === PCCBinaryTarget.TOP) {
      throw new Error("All branches are already finished!");
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      this.setTarget(PCCBinaryTarget.TOP);
    } else if (this.target === PCCBinaryTarget.LEFT) {
      this.setTarget(PCCBinaryTarget.RIGHT);
    } else {
      throw new Error("Unknown target is currently specified!");
    }
    return null;
  };

  PCCBinaryStackElement.prototype.updateBinaryTargets = function(destination) {
    if (destination === this.leftStack) {
      return this.target = PCCBinaryTarget.LEFT;
    } else if (destination === this.rightStack) {
      return this.target = PCCBinaryTarget.RIGHT;
    } else if (destination === this.topStack) {
      return this.target = PCCBinaryTarget.TOP;
    } else {
      throw new Error("Unknown destination!");
    }
  };

  return PCCBinaryStackElement;

})(PCCStackElement);

PCCBinaryTarget = {};

PCCBinaryTarget.LEFT = 0;

PCCBinaryTarget.RIGHT = 1;

PCCBinaryTarget.TOP = 2;

PCCStackElement.prototype.updateBinaryTargets = function(destination) {
  var _ref6;
  return (_ref6 = this.parent) != null ? _ref6.updateBinaryTargets(this) : void 0;
};

PCCStopStackElement = (function(_super) {
  __extends(PCCStopStackElement, _super);

  function PCCStopStackElement() {
    _ref6 = PCCStopStackElement.__super__.constructor.apply(this, arguments);
    return _ref6;
  }

  PCCStopStackElement.prototype.getResults = function() {
    var more;
    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Stop));
    return more;
  };

  PCCStopStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCStopStackElement;

})(PCCUnaryStackElement);

PCCExitStackElement = (function(_super) {
  __extends(PCCExitStackElement, _super);

  function PCCExitStackElement() {
    _ref7 = PCCExitStackElement.__super__.constructor.apply(this, arguments);
    return _ref7;
  }

  PCCExitStackElement.prototype.getResults = function() {
    var more;
    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Exit));
    return more;
  };

  PCCExitStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCExitStackElement;

})(PCCUnaryStackElement);

PCCPrefixStackElement = (function(_super) {
  __extends(PCCPrefixStackElement, _super);

  function PCCPrefixStackElement(channel, specificChannel) {
    this.channel = channel;
    this.specificChannel = specificChannel;
    PCCPrefixStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCPrefixStackElement.prototype._getChannel = function() {
    return new CCS.Channel(this.channel, this.specificChannel ? this.specificChannel.ccsTree() : null);
  };

  PCCPrefixStackElement.prototype._getAction = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCPrefixStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Prefix, this._getAction(), pRes.data));
    return container;
  };

  PCCPrefixStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCPrefixStackElement;

})(PCCUnaryStackElement);

PCCInputStackElement = (function(_super) {
  __extends(PCCInputStackElement, _super);

  function PCCInputStackElement(channel, specificChannel, container) {
    this.container = container;
    PCCInputStackElement.__super__.constructor.call(this, channel, specificChannel);
  }

  PCCInputStackElement.prototype._getAction = function() {
    return this.createCalculusNode(CCS.Input, this._getChannel(), this.container ? this.container.identifier : null);
  };

  return PCCInputStackElement;

})(PCCPrefixStackElement);

PCCOutputStackElement = (function(_super) {
  __extends(PCCOutputStackElement, _super);

  function PCCOutputStackElement(channel, sepcificChannel, container) {
    this.container = container;
    PCCOutputStackElement.__super__.constructor.call(this, channel, sepcificChannel);
  }

  PCCOutputStackElement.prototype._getAction = function() {
    return this.createCalculusNode(CCS.Output, this._getChannel(), this.container ? this.container.ccsTree() : null);
  };

  return PCCOutputStackElement;

})(PCCPrefixStackElement);

PCCConditionStackElement = (function(_super) {
  __extends(PCCConditionStackElement, _super);

  function PCCConditionStackElement(conditionContainer) {
    this.conditionContainer = conditionContainer;
    PCCConditionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCConditionStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Condition, this.conditionContainer.ccsTree(), pRes.data));
    return container;
  };

  PCCConditionStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCConditionStackElement;

})(PCCUnaryStackElement);

PCCRestrictionStackElement = (function(_super) {
  __extends(PCCRestrictionStackElement, _super);

  function PCCRestrictionStackElement(restrictedChannels) {
    this.restrictedChannels = restrictedChannels;
    PCCRestrictionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCRestrictionStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Restriction, pRes.data, this.restrictedChannels));
    return container;
  };

  PCCRestrictionStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCRestrictionStackElement;

})(PCCUnaryStackElement);

PCCApplicationStackElement = (function(_super) {
  __extends(PCCApplicationStackElement, _super);

  function PCCApplicationStackElement(processName, argContainers) {
    this.processName = processName;
    if (argContainers === void 0) {
      argContainers = [];
    }
    if (argContainers) {
      this.argContainers = argContainers.slice(0);
    }
    PCCApplicationStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCApplicationStackElement.prototype.getResults = function() {
    var c, more, values;
    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    values = (function() {
      var _i, _len, _ref8, _results;
      _ref8 = this.argContainers;
      _results = [];
      for (_i = 0, _len = _ref8.length; _i < _len; _i++) {
        c = _ref8[_i];
        _results.push(c.ccsTree());
      }
      return _results;
    }).call(this);
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.ProcessApplication, this.processName, values));
    return more;
  };

  PCCApplicationStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCApplicationStackElement;

})(PCCUnaryStackElement);

PCCApplicationPlaceholderStackElement = (function(_super) {
  __extends(PCCApplicationPlaceholderStackElement, _super);

  function PCCApplicationPlaceholderStackElement(frame) {
    this.frame = frame;
    PCCApplicationPlaceholderStackElement.__super__.constructor.call(this, null, null);
  }

  PCCApplicationPlaceholderStackElement.prototype.set = function(processName, argContainers) {
    if (argContainers == null) {
      argContainers = [];
    }
    if (this.processName || this.argContainers) {
      throw new Error("Placeholder values can't be set twice!");
    }
    this.processName = processName;
    this.argContainers = argContainers.slice(0);
    return null;
  };

  PCCApplicationPlaceholderStackElement.prototype.getResults = function() {
    if (!this.processName || !this.argContainers) {
      throw new Error("Placeholder without values!");
    }
    return PCCApplicationPlaceholderStackElement.__super__.getResults.apply(this, arguments);
  };

  return PCCApplicationPlaceholderStackElement;

})(PCCApplicationStackElement);

PCCBinaryCCSStackElement = (function(_super) {
  __extends(PCCBinaryCCSStackElement, _super);

  function PCCBinaryCCSStackElement() {
    _ref8 = PCCBinaryCCSStackElement.__super__.constructor.apply(this, arguments);
    return _ref8;
  }

  PCCBinaryCCSStackElement.prototype._createCCSProcess = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCBinaryCCSStackElement.prototype.getResults = function() {
    var left, leftContainer, more, right, rightContainer;
    more = this.topStack ? this.topStack.getResults() : new PCCStackResultContainer();
    leftContainer = this.leftStack.getResults();
    left = leftContainer.getResult();
    if (left.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    rightContainer = this.rightStack.getResults();
    right = rightContainer.getResult();
    if (right.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    rightContainer.removeResult();
    leftContainer.appendContainer(rightContainer);
    leftContainer.appendContainer(more);
    leftContainer.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this._createCCSProcess(left.data, right.data));
    return leftContainer;
  };

  PCCBinaryCCSStackElement.prototype.isCompletedProcess = function() {
    if (this.leftStack && this.rightStack) {
      return this.leftStack.isCompletedProcess() && this.rightStack.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCBinaryCCSStackElement;

})(PCCBinaryStackElement);

PCCChoiceStackElement = (function(_super) {
  __extends(PCCChoiceStackElement, _super);

  function PCCChoiceStackElement() {
    _ref9 = PCCChoiceStackElement.__super__.constructor.apply(this, arguments);
    return _ref9;
  }

  PCCChoiceStackElement.prototype._createCCSProcess = function(left, right) {
    return this.createCalculusNode(CCS.Choice, left, right);
  };

  return PCCChoiceStackElement;

})(PCCBinaryCCSStackElement);

PCCParallelStackElement = (function(_super) {
  __extends(PCCParallelStackElement, _super);

  function PCCParallelStackElement() {
    _ref10 = PCCParallelStackElement.__super__.constructor.apply(this, arguments);
    return _ref10;
  }

  PCCParallelStackElement.prototype._createCCSProcess = function(left, right) {
    return this.createCalculusNode(CCS.Parallel, left, right);
  };

  return PCCParallelStackElement;

})(PCCBinaryCCSStackElement);

PCCSequenceStackElement = (function(_super) {
  __extends(PCCSequenceStackElement, _super);

  function PCCSequenceStackElement() {
    _ref11 = PCCSequenceStackElement.__super__.constructor.apply(this, arguments);
    return _ref11;
  }

  PCCSequenceStackElement.prototype._createCCSProcess = function(left, right) {
    return this.createCalculusNode(CCS.Sequence, left, right);
  };

  return PCCSequenceStackElement;

})(PCCBinaryCCSStackElement);

PCCSystemProcessStackElement = (function(_super) {
  __extends(PCCSystemProcessStackElement, _super);

  function PCCSystemProcessStackElement() {
    _ref12 = PCCSystemProcessStackElement.__super__.constructor.apply(this, arguments);
    return _ref12;
  }

  PCCSystemProcessStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    return pRes;
  };

  return PCCSystemProcessStackElement;

})(PCCUnaryStackElement);

PCCProcessDefinitionStackElement = (function(_super) {
  __extends(PCCProcessDefinitionStackElement, _super);

  function PCCProcessDefinitionStackElement(processName, argContainers) {
    this.processName = processName;
    if (argContainers == null) {
      argContainers = [];
    }
    this.argContainers = argContainers.slice(0);
    PCCProcessDefinitionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcessDefinitionStackElement.prototype.getResults = function() {
    var argNames, c, container, def, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    argNames = (function() {
      var _i, _len, _ref13, _results;
      _ref13 = this.argContainers;
      _results = [];
      for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
        c = _ref13[_i];
        _results.push(c.identifier);
      }
      return _results;
    }).call(this);
    def = this.createCalculusNode(CCS.ProcessDefinition, this.processName, pRes.data, argNames);
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS_DEFINITION, def);
    return container;
  };

  return PCCProcessDefinitionStackElement;

})(PCCUnaryStackElement);

PCCProcessFrameStackElement = (function(_super) {
  __extends(PCCProcessFrameStackElement, _super);

  function PCCProcessFrameStackElement(frame) {
    this.frame = frame;
    PCCProcessFrameStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcessFrameStackElement.prototype.getCurrentProcessFrame = function() {
    return this.frame;
  };

  PCCProcessFrameStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;
    result = this.frame.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;
    result = this.frame.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;
    result = this.frame.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCProcessFrameStackElement;

})(PCCUnaryStackElement);

PCCClassStackElement = (function(_super) {
  __extends(PCCClassStackElement, _super);

  function PCCClassStackElement(classInfo) {
    this.classInfo = classInfo;
    PCCClassStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCClassStackElement.prototype.getCurrentControlElement = function() {
    return this.classInfo;
  };

  PCCClassStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;
    result = this.classInfo.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCClassStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;
    result = this.classInfo.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCClassStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;
    result = this.classInfo.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCClassStackElement;

})(PCCUnaryStackElement);

PCCGlobalStackElement = (function(_super) {
  __extends(PCCGlobalStackElement, _super);

  function PCCGlobalStackElement(global) {
    this.global = global;
    PCCGlobalStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCGlobalStackElement.prototype.getCurrentControlElement = function() {
    return this.global;
  };

  PCCGlobalStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;
    result = this.global.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCGlobalStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;
    result = this.global.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCGlobalStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;
    result = this.global.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCGlobalStackElement;

})(PCCUnaryStackElement);

PCCProcedureStackElement = (function(_super) {
  __extends(PCCProcedureStackElement, _super);

  function PCCProcedureStackElement(procedure) {
    this.procedure = procedure;
    PCCProcedureStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcedureStackElement.prototype.getCurrentControlElement = function() {
    return this.procedure;
  };

  return PCCProcedureStackElement;

})(PCCUnaryStackElement);

PCCCompilerStack = (function() {
  function PCCCompilerStack(initialElement) {
    this.topElement = initialElement;
    this.topElement.__PCCCompilerStack = this;
    this.topElement.getStack = function() {
      return this.__PCCCompilerStack;
    };
  }

  PCCCompilerStack.prototype.setTopElement = function(e) {
    return this.topElement = e;
  };

  PCCCompilerStack.prototype.getCurrentProcessFrame = function() {
    return this.topElement.getCurrentProcessFrame();
  };

  PCCCompilerStack.prototype.getCurrentControlElement = function() {
    return this.topElement.getCurrentControlElement();
  };

  PCCCompilerStack.prototype.pushElement = function(e) {
    this.topElement.setNext(e);
    return this.topElement = e;
  };

  PCCCompilerStack.prototype.isCurrentProcessCompleted = function() {
    return this.topElement.isCompletedProcess();
  };

  PCCCompilerStack.prototype.compilerGetVariable = function(compiler, identifier) {
    var _ref13;
    return (_ref13 = this.topElement) != null ? _ref13.compilerGetVariable(compiler, identifier) : void 0;
  };

  PCCCompilerStack.prototype.compilerGetProcedure = function(compiler, identifier) {
    var _ref13;
    return (_ref13 = this.topElement) != null ? _ref13.compilerGetProcedure(compiler, identifier) : void 0;
  };

  PCCCompilerStack.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var _ref13;
    return (_ref13 = this.topElement) != null ? _ref13.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context) : void 0;
  };

  return PCCCompilerStack;

})();

PCCStackElement.prototype.getStack = function() {
  return this.parent.getStack();
};

PCCStackResult = (function() {
  function PCCStackResult(type, data) {
    this.type = type;
    this.data = data;
  }

  return PCCStackResult;

})();

PCCStackResultContainer = (function() {
  function PCCStackResultContainer() {
    this.results = [];
  }

  PCCStackResultContainer.prototype.addResult = function(type, data) {
    return this.results.unshift(new PCCStackResult(type, data));
  };

  PCCStackResultContainer.prototype.replaceResult = function(type, data) {
    return this.results[0] = new PCCStackResult(type, data);
  };

  PCCStackResultContainer.prototype.getResult = function() {
    return this.results[0];
  };

  PCCStackResultContainer.prototype.removeResult = function() {
    return this.results.shift();
  };

  PCCStackResultContainer.prototype.appendContainer = function(container) {
    return this.results = this.results.concat(container.results);
  };

  return PCCStackResultContainer;

})();

PCCStackResult.TYPE_UNSPECIFIC = 0;

PCCStackResult.TYPE_CCSPROCESS = 1;

PCCStackResult.TYPE_CCSPROCESS_DEFINITION = 2;

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


PC.Node.prototype.compile = function(compiler) {
  throw new Error("Abstract method!");
};

PC.Node.prototype._childrenCompile = function(compiler) {
  var c, _i, _len, _ref13, _results;
  _ref13 = this.children;
  _results = [];
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    _results.push(compiler.compile(c));
  }
  return _results;
};

PC.Program.prototype.compile = function(compiler) {
  compiler.beginProgram();
  this._childrenCompile(compiler);
  return compiler.endProgram();
};

PC.MainAgent.prototype.compile = function(compiler) {
  compiler.beginMainAgent();
  this._childrenCompile(compiler);
  compiler.emitStop();
  return compiler.endMainAgent();
};

PC.ProcedureDecl.prototype.compile = function(compiler) {
  var guard, proc;
  compiler.beginProcedure(this.name);
  proc = compiler.getProcedureWithName(this.name);
  if (proc.isMonitorProcedure()) {
    guard = compiler.getVariableWithName("guard", null, true);
    compiler.emitOutput("lock", guard.getContainer(compiler));
  }
  compiler.compile(this.getBody());
  proc.emitExit(compiler);
  compiler.endProcedure();
  return [];
};

PC.FormalParameter.prototype.compile = function(compiler) {
  throw new Error("Not implemented!");
};

PC.Monitor.prototype.compile = function(compiler) {
  compiler.beginClass(this.name);
  this._childrenCompile(compiler);
  return compiler.endClass();
};

PC.Struct.prototype.compile = function(compiler) {
  compiler.beginClass(this.name);
  this._childrenCompile(compiler);
  return compiler.endClass();
};

PC.ConditionDecl.prototype.compile = function(compiler) {
  var context, variable;
  context = {
    target: this,
    compiler: compiler
  };
  variable = new PCCVariableInfo(this, this.name, new PC.Type(PC.Type.CONDITION));
  compiler.handleNewVariableWithDefaultValueCallback(variable);
  return [];
};

PC.ConditionDecl.prototype.compileDefaultValue = function(compiler) {
  var result;
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput("wait_create", null, result);
  return result;
};

PC.Decl.prototype.compile = function(compiler) {
  var type, vd, _i, _len, _ref13;
  type = this.children[0];
  _ref13 = this.getDeclarators();
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    vd = _ref13[_i];
    compiler.compile(vd);
  }
  return [];
};

PC.VariableDeclarator.prototype.compile = function(compiler) {
  var context, variable;
  context = {
    target: this,
    compiler: compiler
  };
  variable = new PCCVariableInfo(this, this.name, this.getTypeNode().getType(compiler).type);
  return compiler.handleNewVariableWithDefaultValueCallback(variable);
};

PC.VariableDeclarator.prototype.compileDefaultValue = function(compiler) {
  var type;
  type = this.getTypeNode().getType(compiler).type;
  if (this.getInitializer()) {
    return compiler.compile(this.getInitializer(), type);
  } else {
    return type.createContainer(compiler);
  }
};

PC.VariableInitializer.prototype.compile = function(compiler, type) {
  var c, cc;
  if (this.isArray()) {
    cc = (function() {
      var _i, _len, _ref13, _results;
      _ref13 = this.children;
      _results = [];
      for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
        c = _ref13[_i];
        _results.push(compiler.compile(c, type.elementsType));
      }
      return _results;
    }).call(this);
    return type.createContainer(compiler, cc);
  } else {
    return type.createContainer(compiler, compiler.compile(this.children[0]));
  }
};

PC.Expression.prototype.compile = function(compiler) {
  throw new Error("Not implemented!");
};

PC.Expression.prototype.getValueForArrayAtIndex = function(compiler, instanceContainer, indexContainer) {
  var result;
  compiler.emitOutput("array_access", instanceContainer, indexContainer);
  result = compiler.getFreshContainer(instanceContainer.ccsType.getSubtype());
  compiler.emitInput("array_get", instanceContainer, result);
  return result;
};

PC.StartExpression.prototype.compile = function(compiler) {
  return this.children[0].compileSend(compiler);
};

PC.AssignExpression.prototype.compile = function(compiler) {
  var c;
  c = compiler.compile(this.getExpression());
  if (this.operator === "+=") {
    c = new PCCBinaryContainer(compiler.compile(this.getDestination()), c, "+");
  } else if (this.operator === "*=") {
    c = new PCCBinaryContainer(compiler.compile(this.getDestination()), c, "*");
  } else if (this.operator === "/=") {
    c = new PCCBinaryContainer(compiler.compile(this.getDestination()), c, "/");
  } else if (this.operator !== "=") {
    throw new Error("Unknown assign operator");
  }
  this.getDestination().assignContainer(compiler, c);
  return c;
};

PC.AssignDestination.prototype.compile = function(compiler) {
  var arrayIndexCount, i, res, v, _i;
  arrayIndexCount = this.children.length;
  v = compiler.getVariableWithName(this.identifier, null);
  res = v.getContainer(compiler);
  for (i = _i = 0; _i < arrayIndexCount; i = _i += 1) {
    res = this.getValueForArrayAtIndex(compiler, ai, compiler.compile(this.children[i]));
  }
  return res;
};

PC.AssignDestination.prototype.setValueForArrayAtIndex = function(compiler, instanceContainer, indexContainer, valueContainer) {
  compiler.emitOutput("array_access", instanceContainer, indexContainer);
  compiler.emitOutput("array_set", instanceContainer, valueContainer);
  return valueContainer;
};

PC.AssignDestination.prototype.assignContainer = function(compiler, c) {
  var ai, arrayIndexCount, i, v, _i, _ref13;
  arrayIndexCount = this.children.length;
  v = compiler.getVariableWithName(this.identifier, null);
  if (arrayIndexCount === 0) {
    return v.setContainer(compiler, c);
  } else {
    ai = v.getContainer(compiler);
    for (i = _i = 0, _ref13 = arrayIndexCount - 2; _i <= _ref13; i = _i += 1) {
      ai = this.getValueForArrayAtIndex(compiler, ai, compiler.compile(this.children[i]));
    }
    return this.setValueForArrayAtIndex(compiler, ai, compiler.compile(this.children[arrayIndexCount - 1]), c);
  }
};

PC.SendExpression.prototype.compile = function(compiler) {
  var c, control, p1, p2, v;
  c = compiler.compile(this.children[0]);
  v = compiler.compile(this.children[1]);
  if (this.children[0].getType(compiler).capacity <= 0) {
    control = compiler.emitChoice();
    compiler.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">="));
    compiler.emitOutput("put", c, v);
    p1 = compiler.emitProcessApplicationPlaceholder();
    control.setBranchFinished();
    compiler.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<"));
    compiler.emitOutput("receive", c, v);
    p2 = compiler.emitProcessApplicationPlaceholder();
    control.setBranchFinished();
    compiler.emitMergeOfProcessFramesOfPlaceholders([p1, p2]);
  } else {
    compiler.emitOutput("put", c, v);
  }
  return v;
};

PC.ConditionalExpression.prototype.compile = function(compiler) {
  var b, c, control, lp, rp;
  b = compiler.compile(this.children[0]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  c = compiler.compile(this.children[1]);
  compiler.protectContainer(c);
  lp = compiler.emitProcessApplicationPlaceholder();
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  c = compiler.compile(this.children[2]);
  compiler.protectContainer(c);
  rp = compiler.emitProcessApplicationPlaceholder();
  compiler.emitMergeOfProcessFramesOfPlaceholders([lp, rp]);
  return compiler.unprotectContainer();
};

PC.OrExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, "||");
};

PC.AndExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, "&&");
};

PC.EqualityExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.RelationalExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.AdditiveExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.MultiplicativeExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.UnaryExpression.prototype.compile = function(compiler) {
  return new PCCUnaryContainer(this.operator, compiler.compile(this.children[0]));
};

PC.PostfixExpression.prototype.compile = function(compiler) {
  var c, op;
  op = (function() {
    if (this.operator === "++") {
      return "+";
    } else if (this.operator === "--") {
      return "-";
    } else {
      throw new Error("Unknown postfix operator");
    }
  }).call(this);
  c = new PCCBinaryContainer(compiler.compile(this.children[0]), new PCCConstantContainer(1), op);
  this.children[0].assignContainer(compiler, c);
  return c;
};

PC.ReceiveExpression.prototype.compile = function(compiler) {
  var c, res;
  c = compiler.compile(this.children[0]);
  res = compiler.getFreshContainer(c.ccsType.getSubtype());
  compiler.emitInput("receive", c, res);
  return res;
};

PC.ProcedureCall.prototype.compile = function(compiler, instanceContainer, className) {
  var args, c, control, proc, res, _i, _j, _len, _len1, _ref13, _ref14;
  proc = compiler.getProcedureWithName(this.procedureName, className);
  if (instanceContainer) {
    compiler.protectContainer(instanceContainer);
  }
  _ref13 = this.children;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    compiler.protectContainer(compiler.compile(c));
  }
  control = compiler.emitSequence();
  args = [];
  _ref14 = this.children;
  for (_j = 0, _len1 = _ref14.length; _j < _len1; _j++) {
    c = _ref14[_j];
    args.unshift(compiler.unprotectContainer());
  }
  if (instanceContainer) {
    instanceContainer = compiler.unprotectContainer();
  }
  args = proc.getAllArgumentContainers(compiler, args, instanceContainer);
  compiler.emitProcessApplication(proc.getProcessName(), args);
  control.setBranchFinished();
  if (proc.returnType.kind !== PC.Type.VOID) {
    res = compiler.getFreshContainer(proc.returnType.getCCSType());
    compiler.emitInput("rreturn", null, res);
    return res;
  } else {
    return null;
  }
};

PC.ProcedureCall.prototype.compileSend = function(compiler, instanceContainer, className) {
  var args, c, proc, result, _i, _j, _k, _len, _len1, _len2, _ref13, _ref14;
  proc = compiler.getProcedureWithName(this.procedureName, className);
  if (instanceContainer) {
    compiler.protectContainer(instanceContainer);
  }
  _ref13 = this.children;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    compiler.protectContainer(compiler.compile(c));
  }
  args = [];
  _ref14 = this.children;
  for (_j = 0, _len1 = _ref14.length; _j < _len1; _j++) {
    c = _ref14[_j];
    args.unshift(compiler.unprotectContainer());
  }
  if (instanceContainer) {
    instanceContainer = compiler.unprotectContainer();
  }
  args = proc.getAllArgumentContainers(compiler, args, instanceContainer);
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput(proc.getAgentStarterChannel(), null, result);
  for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
    c = args[_k];
    compiler.emitOutput("start_set_arg", result, c);
  }
  return result;
};

PC.ClassCall.prototype.compile = function(compiler) {
  var className;
  className = this.children[0].getType(compiler).identifier;
  return compiler.compile(this.children[1], compiler.compile(this.children[0]), className);
};

PC.ClassCall.prototype.compileSend = function(compiler) {
  var className;
  className = this.children[0].getType(compiler).identifier;
  return this.children[1].compileSend(compiler, compiler.compile(this.children[0]), className);
};

PC.ArrayExpression.prototype.compile = function(compiler) {
  var a, res, t;
  a = compiler.compile(this.children[0]);
  compiler.protectContainer(a);
  t = compiler.compile(this.children[1]);
  a = compiler.unprotectContainer();
  compiler.emitOutput("array_access", a, t);
  res = compiler.getFreshContainer(this.children[0].getType(compiler).type);
  compiler.emitInput("array_get", a, res);
  return res;
};

PC.LiteralExpression.prototype.compile = function(compiler) {
  return new PCCConstantContainer(this.value);
};

PC.IdentifierExpression.prototype.compile = function(compiler) {
  var v;
  v = compiler.getVariableWithName(this.identifier, null);
  return v.getContainer(compiler);
};

PC.Statement.prototype.compile = function(compiler, loopEntry) {
  return compiler.compile(this.children[0], loopEntry);
};

PC.BreakStmt.prototype.compile = function(compiler, loopEntry) {
  return [compiler.emitProcessApplicationPlaceholder()];
};

PC.ContinueStmt.prototype.compile = function(compiler, loopEntry) {
  loopEntry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  return [];
};

PC.StmtBlock.prototype.compile = function(compiler, loopEntry) {
  var breaks, c, statusQuo;
  statusQuo = compiler.getProcessFrame();
  compiler.emitNewScope();
  breaks = ((function() {
    var _i, _len, _ref13, _results;
    _ref13 = this.children;
    _results = [];
    for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
      c = _ref13[_i];
      _results.push(compiler.compile(c, loopEntry));
    }
    return _results;
  }).call(this)).concatChildren();
  compiler.emitNewScope(statusQuo);
  return breaks;
};

PC.StmtExpression.prototype.compile = function(compiler, loopEntry) {
  compiler.compile(this.children[0]);
  return [];
};

PC.SelectStmt.prototype.compile = function(compiler, loopEntry) {
  var breaks, control, i, placeholders, _i, _ref13;
  if (this.children.length === 0) {
    return;
  }
  placeholders = [];
  breaks = [];
  for (i = _i = 0, _ref13 = this.children.length - 1; _i < _ref13; i = _i += 1) {
    control = compiler.emitChoice();
    breaks.concat(compiler.compile(this.children[i], loopEntry));
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
    control.setBranchFinished();
  }
  breaks.concat(compiler.compile(this.children[this.children.length - 1], loopEntry));
  placeholders.push(compiler.emitProcessApplicationPlaceholder());
  compiler.emitMergeOfProcessFramesOfPlaceholders(placeholders);
  return breaks;
};

PC.Case.prototype.compile = function(compiler, loopEntry) {
  var cond;
  cond = this.getCondition();
  if (cond) {
    compiler.compile(cond);
  }
  return compiler.compile(this.getExecution(), loopEntry);
};

PC.IfStmt.prototype.compile = function(compiler, loopEntry) {
  var b, breaks, control, placeholders;
  placeholders = [];
  b = compiler.compile(this.children[0]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  breaks = compiler.compile(this.children[1], loopEntry);
  if (!compiler.isCurrentProcessCompleted()) {
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
  }
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  if (this.children.length === 3) {
    breaks = breaks.concat(compiler.compile(this.children[2], loopEntry));
  }
  if (!compiler.isCurrentProcessCompleted()) {
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
  }
  control.setBranchFinished();
  compiler.emitMergeOfProcessFramesOfPlaceholders(placeholders);
  return breaks;
};

PC.WhileStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, _i, _len;
  entry = compiler.emitNextProcessFrame();
  b = compiler.compile(this.children[0]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  breaks = compiler.compile(this.children[1], entry);
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  out = compiler.emitNextProcessFrame();
  for (_i = 0, _len = breaks.length; _i < _len; _i++) {
    b = breaks[_i];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PC.DoStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, statusQuo, _i, _len;
  statusQuo = compiler.getProcessFrame();
  entry = compiler.emitNextProcessFrame();
  breaks = compiler.compile(this.children[0], entry);
  b = compiler.compile(this.children[1]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  breaks.push(compiler.emitProcessApplicationPlaceholder());
  control.setBranchFinished();
  out = compiler.emitNextProcessFrame([statusQuo]);
  for (_i = 0, _len = breaks.length; _i < _len; _i++) {
    b = breaks[_i];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PC.ForStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, statusQuo, u, _i, _j, _len, _len1, _ref13;
  statusQuo = compiler.getProcessFrame();
  if (this.init) {
    compiler.emitNewScope();
    compiler.compile(this.init);
  }
  entry = compiler.emitNextProcessFrame();
  breaks = [];
  control = null;
  if (this.expression) {
    b = compiler.compile(this.expression);
    control = compiler.emitChoice();
    compiler.emitCondition(new PCCUnaryContainer("!", b));
    breaks.push(compiler.emitProcessApplicationPlaceholder());
    control.setBranchFinished();
    compiler.emitCondition(b);
  }
  breaks = breaks.concat(compiler.compile(this.body, entry));
  _ref13 = this.update;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    u = _ref13[_i];
    compiler.compile(u);
  }
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  if (control) {
    control.setBranchFinished();
  }
  out = compiler.emitNextProcessFrame([statusQuo]);
  for (_j = 0, _len1 = breaks.length; _j < _len1; _j++) {
    b = breaks[_j];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PC.ForInit.prototype.compile = function(compiler) {
  var c, _i, _len, _ref13;
  _ref13 = this.children;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    compiler.compile(c);
  }
  return [];
};

PC.ReturnStmt.prototype.compile = function(compiler, loopEntry) {
  var res;
  if (this.children.length === 1) {
    res = compiler.compile(this.children[0]);
    compiler.emitOutput("return", null, res);
  }
  compiler.getCurrentProcedure().emitExit(compiler);
  return [];
};

PC.PrimitiveStmt.prototype.compile = function(compiler, loopEntry) {
  var b, c, cond, control, entry, g, v, vars, _i, _len;
  switch (this.kind) {
    case PC.PrimitiveStmt.JOIN:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("join_register", c, null);
      compiler.emitOutput("join", c, null);
      break;
    case PC.PrimitiveStmt.LOCK:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("lock", c, null);
      break;
    case PC.PrimitiveStmt.UNLOCK:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("unlock", c, null);
      break;
    case PC.PrimitiveStmt.WAIT:
      if (!(this.children[0] instanceof PCIdentifierExpression)) {
        throw new Error("Unexpected expression!");
      }
      cond = compiler.getVariableWithName(this.children[0].identifier);
      entry = compiler.emitNextProcessFrame();
      b = compiler.compile(cond.node.getExpression());
      control = compiler.emitChoice();
      compiler.emitCondition(new PCCUnaryContainer("!", b));
      c = cond.getContainer(compiler);
      compiler.emitOutput("add", c, null);
      g = compiler.getVariableWithName("guard", null, true).getContainer(compiler);
      compiler.emitOutput("unlock", g, null);
      compiler.emitOutput("wait", c, null);
      compiler.emitOutput("lock", g, null);
      entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
      control.setBranchFinished();
      compiler.emitCondition(b);
      break;
    case PC.PrimitiveStmt.SIGNAL:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("signal", c, null);
      break;
    case PC.PrimitiveStmt.SIGNAL_ALL:
      c = this.children.length > 0 ? compiler.compile(this.children[0], loopEntry) : null;
      vars = [];
      if (c) {
        if (!(this.children[0] instanceof PC.IdentifierExpression)) {
          throw new Error("Unexpected expression!");
        }
        vars = [compiler.getVariableWithName(this.children[0].identifier)];
      } else {
        vars = compiler.getCurrentClass().getAllConditions();
      }
      for (_i = 0, _len = vars.length; _i < _len; _i++) {
        v = vars[_i];
        c = v.getContainer(compiler);
        compiler.emitOutput("signal_all", c, null);
      }
  }
  return [];
};

PC.PrintStmt.prototype.compile = function(compiler, loopEntry) {
  var i, out, _i, _ref13;
  if (this.children.length === 0) {
    return;
  }
  out = compiler.compile(this.children[0]);
  for (i = _i = 1, _ref13 = this.children.length; _i < _ref13; i = _i += 1) {
    out = new PCCBinaryContainer(out, compiler.compile(this.children[i]), "+");
  }
  compiler.emitOutput("println", null, out);
  return [];
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


PCCExecutor = (function(_super) {
  __extends(PCCExecutor, _super);

  function PCCExecutor() {
    _ref13 = PCCExecutor.__super__.constructor.apply(this, arguments);
    return _ref13;
  }

  PCCExecutor.prototype._printStep = function(step) {
    if (step.action.channel.name === "println" && step.action.isOutputAction() && step.action.expression) {
      return this._output("" + (step.action.expression.evaluate()));
    }
  };

  PCCExecutor.prototype._printExecutionIntro = function() {
    return this._output("<i>Starting CCS execution.</i>");
  };

  PCCExecutor.prototype._printExecutionSummary = function() {
    var elapsedMS, perStep;
    elapsedMS = (new Date()).getTime() - this.executionStart.getTime();
    perStep = Math.round(elapsedMS / this.stepCount * 100) / 100;
    return this._output("<i>Finished CCS execution after performing " + this.stepCount + " steps in " + (elapsedMS / 1000) + " seconds (" + perStep + "ms per step).<\/i> \n-------------------------------------------------------------------------------------------");
  };

  return PCCExecutor;

})(CCS.Executor);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


exports = module && module.exports ? module.exports : {};

exports["Compiler"] = PCCCompiler;

exports["Constructor"] = PCCConstructor;

exports["StackElement"] = PCCStackElement;

exports["UnaryStackElement"] = PCCUnaryStackElement;

exports["BinaryStackElement"] = PCCBinaryStackElement;

exports["StopStackElement"] = PCCStopStackElement;

exports["ExitStackElement"] = PCCExitStackElement;

exports["PrefixStackElement"] = PCCPrefixStackElement;

exports["InputStackElement"] = PCCInputStackElement;

exports["OutputStackElement"] = PCCOutputStackElement;

exports["ConditionStackElement"] = PCCConditionStackElement;

exports["RestrictionStackElement"] = PCCRestrictionStackElement;

exports["ApplicationStackElement"] = PCCApplicationStackElement;

exports["ApplicationPlaceholderStackElement"] = PCCApplicationPlaceholderStackElement;

exports["BinaryCCSStackElement"] = PCCBinaryCCSStackElement;

exports["ChoiceStackElement"] = PCCChoiceStackElement;

exports["ParallelStackElement"] = PCCParallelStackElement;

exports["SequenceStackElement"] = PCCSequenceStackElement;

exports["SystemProcessStackElement"] = PCCSystemProcessStackElement;

exports["ProcessDefinitionStackElement"] = PCCProcessDefinitionStackElement;

exports["ProcessFrameStackElement"] = PCCProcessFrameStackElement;

exports["ClassStackElement"] = PCCClassStackElement;

exports["GlobalStackElement"] = PCCGlobalStackElement;

exports["ProcedureStackElement"] = PCCProcedureStackElement;

exports["CompilerStack"] = PCCCompilerStack;

exports["StackResult"] = PCCStackResult;

exports["StackResultContainer"] = PCCStackResultContainer;

exports["Container"] = PCCContainer;

exports["ConstantContainer"] = PCCConstantContainer;

exports["VariableContainer"] = PCCVariableContainer;

exports["ComposedContainer"] = PCCComposedContainer;

exports["BinaryContainer"] = PCCBinaryContainer;

exports["UnaryContainer"] = PCCUnaryContainer;

exports["Executor"] = PCCExecutor;

exports["PCCProcessFrame"] = PCCProcessFrame;

exports["PCCProcedureFrame"] = PCCProcedureFrame;

exports["PCCGroupable"] = PCCGroupable;

exports["PCCGlobal"] = PCCGlobal;

exports["PCCClass"] = PCCClass;

exports["PCCProcedure"] = PCCProcedure;

exports["PCCType"] = PCCType;

exports["PCCVariableInfo"] = PCCVariableInfo;

exports["PCCVariable"] = PCCVariable;

exports["PCCGlobalVariable"] = PCCGlobalVariable;

exports["PCCField"] = PCCField;

exports["PCCInternalReadOnlyField"] = PCCInternalReadOnlyField;

exports["PCCCondition"] = PCCCondition;

exports["PCCLocalVariable"] = PCCLocalVariable;

exports["PCCProgramController"] = PCCProgramController;
