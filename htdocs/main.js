(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var $$, CCS, PC, PCC, UI, UIAppController, UICCSConsole, UICCSEditor, UICCSHistory, UIClickRecognizer, UIConsole, UIEditorState, UIError, UIEventRecognizer, UIExecutor, UIID, UILoad, UILog, UIPseuCoEditor, UIPseuCoHack, UITabBar, UIWarn, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CCS = require("CCS");

PC = require("PseuCo");

PCC = require("CCSCompiler");

UIEditorState = {
  possible: 0,
  invalid: 1,
  valid: 2
};

UIID = {
  fileLabel: null,
  fileTitle: null,
  fileType: null,
  fileDropDownButton: null,
  fileAdd: null,
  pseucoField: null,
  pseucoJSField: null,
  hresizer: null,
  ccsField: null,
  vresizer: null,
  tabBar: null,
  console: null
};

UI = {
  console: null,
  toolTabBar: null,
  history: null,
  executor: null,
  app: null
};

$$ = function(id) {
  return UIID[id][0];
};

UILoad = function() {
  UIID = {
    fileLabel: $("#fileLabel"),
    fileTitle: $("#fileTitle"),
    fileType: $("#fileType"),
    fileDropDownButton: $("#fileDropDownButton"),
    fileAdd: $("#fileAdd"),
    pseucoField: $("#pseuco_field"),
    pseucoJSField: $("#pseucojs_field"),
    hresizer: $("#hresizer"),
    ccsField: $("#ccs_field"),
    vresizer: $("#vresizer"),
    tabBar: $("#tabBar"),
    tabContent: $("#tabContent"),
    console: $("#console"),
    history: $("#history"),
    runButton: $("#ccsRun")
  };
  UI.console = new UIConsole($$("console"));
  UI.toolTabBar = new UITabBar($$("tabBar"), $$("tabContent"));
  UI.history = new UICCSHistory($$("history"));
  UI.executor = new UIExecutor($$("runButton"));
  UI.pseuCoEditor = new UIPseuCoEditor($$("pseucoField"));
  UI.ccsEditor = new UICCSEditor($$("ccsField"));
  return UI.app = new UIAppController(UI.pseuCoEditor, UI.ccsEditor, UI.executor, UI.console, UI.history);
};

UILog = function(msg) {
  return UI.console.log(msg);
};

UIWarn = function(msg) {
  return UI.console.warn(msg);
};

UIError = function(msg) {
  return UI.console.error(msg);
};

registerLoadCallback(UILoad);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UITabBar = (function() {
  function UITabBar(bar, content) {
    var li, ref, _i, _len, _ref;
    this.bar = bar;
    this.content = content;
    this.bar.parentNode._tabBar = this;
    this.barItems = [];
    this.contentItems = [];
    this.activeContent = null;
    _ref = this.bar.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      li = _ref[_i];
      if (li.nodeName === "LI") {
        ref = li.dataset.tabContent;
        if (!ref) {
          throw new Error("Missing content reference!");
        }
        content = $("#" + ref)[0];
        if (!content) {
          throw new Error("Missing content node!");
        }
        $(li).on("click", function(event) {
          return this.getTabBar()._handleItemClick(event);
        });
        this.barItems.push(li);
        this.contentItems.push(content);
      }
    }
    this.setItemAtIndex(1);
  }

  UITabBar.prototype.scrollTo = function(x, y) {
    this.content.scrollLeft = x;
    return this.content.scrollTop = y;
  };

  UITabBar.prototype._handleItemClick = function(event) {
    var i;
    i = this.barItems.indexOf(event.target);
    return this.setItemAtIndex(i);
  };

  UITabBar.prototype.setItemAtIndex = function(i) {
    if (this.activeContent) {
      this.activeContent.style.display = "";
    }
    this.activeContent = this.contentItems[i];
    return this.activeContent.style.display = "block";
  };

  UITabBar.prototype.getIndexForContent = function(node) {
    var i;
    i = this.contentItems.indexOf(node);
    if (i === -1) {
      if (node.parentNode) {
        return this.getIndexForContent(node.parentNode);
      } else {
        return -1;
      }
    } else {
      return i;
    }
  };

  return UITabBar;

})();

Element.prototype.getTabBar = function() {
  var _ref;
  if (this._tabBar) {
    return this._tabBar;
  } else {
    return (_ref = this.parentNode) != null ? _ref.getTabBar() : void 0;
  }
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UIConsole = (function() {
  function UIConsole(div) {
    div.innerHTML = "";
    this.ul = document.createElement("UL");
    div.appendChild(this.ul);
  }

  UIConsole.prototype.addLine = function(str, cssClass) {
    var bar, node;
    str = str.replace(/\n/g, "<br />");
    str = str.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
    node = document.createElement("LI");
    cssClass = cssClass ? "log " + cssClass : "log";
    node.setAttribute("CLASS", cssClass);
    node.innerHTML = str;
    this.ul.appendChild(node);
    this.ul.getTabBar().scrollTo(0, this.ul.offsetHeight);
    bar = this.ul.getTabBar();
    bar.setItemAtIndex(bar.getIndexForContent(this.ul));
    UI.app.didUpdateConsole(this);
    return node;
  };

  UIConsole.prototype.log = function(msg) {
    return this.addLine(msg);
  };

  UIConsole.prototype.warn = function(msg) {
    return this.addLine(msg, "warning");
  };

  UIConsole.prototype.error = function(msg) {
    return this.addLine(msg, "error");
  };

  UIConsole.prototype.clear = function() {
    return this.ul.innerHTML = "";
  };

  return UIConsole;

})();

UICCSConsole = (function(_super) {
  __extends(UICCSConsole, _super);

  function UICCSConsole() {
    _ref = UICCSConsole.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  UICCSConsole.prototype.addOutput = function(action) {
    return this.addLine("&gt;&gt;&gt; " + (action.toString()));
  };

  UICCSConsole.prototype.addInput = function(action) {
    return this.addLine("&lt;&lt;&lt; " + (action.toString()));
  };

  return UICCSConsole;

})(UIConsole);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UICCSHistory = (function() {
  function UICCSHistory(container) {
    this.container = container;
  }

  UICCSHistory.prototype.appDidResetCCS = function(app, system) {
    this.clear();
    this.system = system;
    return this._addState(null);
  };

  UICCSHistory.prototype.clear = function() {
    this.system = null;
    return this.container.innerHTML = "";
  };

  UICCSHistory.prototype.performStep = function(step) {
    if (!step) {
      throw new Error("Step must not be null!");
    }
    this.system = step.perform();
    this._addState(step);
    return this.system;
  };

  UICCSHistory.prototype._addState = function(step) {
    var action, details, li, system;
    action = "";
    if (step) {
      action = step.action.transferDescription();
      details = "";
      if (step.actionDetails) {
        details = step.actionDetails;
      }
      if (details.length > 0) {
        details = " <span class=\"action_detail\">(" + details + ")</span>";
      }
      action = "<span class=\"h_action\">" + action + details + "</span>";
    }
    system = "<span class=\"h_ccs\">" + (this.system.toString()) + "</span>";
    li = document.createElement("LI");
    li.innerHTML = action + system;
    if (this.container.hasChildNodes()) {
      return this.container.insertBefore(li, this.container.firstChild);
    } else {
      return this.container.appendChild(li);
    }
  };

  return UICCSHistory;

})();

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	Delegate methods:
	recognizerShouldBeginRecognising()
	recognizerDidChangeState()
*/


UIEventRecognizer = (function() {
  function UIEventRecognizer(nodes, delegate) {
    this.nodes = nodes;
    this.delegate = delegate;
    this.setEnabled(true);
    this.state = UIEventRecognizer.POSSIBLE;
  }

  UIEventRecognizer.prototype.setEnabled = function(enabled) {
    if (enabled === this.enabled) {
      return;
    }
    this.nabled = enabled;
    if (this.enabled) {
      return this._enable();
    } else {
      return this._disable();
    }
  };

  UIEventRecognizer.prototype._enable = function() {
    throw new Error("Not implemented!");
  };

  UIEventRecognizer.prototype._disable = function() {
    throw new Error("Not implemented!");
  };

  return UIEventRecognizer;

})();

UIEventRecognizer.POSSIBLE = 0;

UIEventRecognizer.BEGAN = 1;

UIEventRecognizer.CHANGED = 2;

UIEventRecognizer.ENDED = 3;

UIEventRecognizer.RECOGNIZED = 3;

UIClickRecognizer = (function(_super) {
  __extends(UIClickRecognizer, _super);

  function UIClickRecognizer() {
    UIClickRecognizer.__super__.constructor.apply(this, arguments);
    this.requiredClicks = 1;
  }

  UIClickRecognizer.prototype._enable = function() {
    return this.nodes.on("click", function(event) {});
  };

  return UIClickRecognizer;

})(UIEventRecognizer);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UIExecutor = (function() {
  function UIExecutor(button) {
    this.button = button;
    this.button.__executor = this;
    $(this.button).on("click", function(event) {
      return event.target.__executor.execute();
    });
  }

  UIExecutor.prototype._enableButton = function() {
    return this.button.removeAttribute("DISABLED");
  };

  UIExecutor.prototype._disableButton = function() {
    return this.button.setAttribute("DISABLED", "disabled");
  };

  UIExecutor.prototype.setButtonEnabled = function(enabled) {
    if (enabled) {
      return this._enableButton();
    } else {
      return this._disableButton();
    }
  };

  UIExecutor.prototype.appWillChangeCCS = function(app) {
    return this.setButtonEnabled(false);
  };

  UIExecutor.prototype.appDidChangeCCS = function(app) {
    return this.setButtonEnabled(app.ccs ? true : false);
  };

  UIExecutor.prototype.executorPrint = function(exec, msg) {
    return UILog(msg);
  };

  UIExecutor.prototype.executorDidPerformStep = function(exec, step, system) {};

  UIExecutor.prototype.execute = function() {
    this.executor = new PCC.Executor(UI.app.ccs, this);
    return this.executor.execute();
  };

  return UIExecutor;

})();

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UIAppController = (function() {
  function UIAppController(pseuCoEditor, ccsEditor, executor, console, history) {
    this.pseuCoEditor = pseuCoEditor;
    this.ccsEditor = ccsEditor;
    this.executor = executor;
    this.console = console;
    this.history = history;
    this.observers = [this.pseuCoEditor, this.ccsEditor, this.executor, this.console, this.history];
    this.stepObservers = [this.console, this.history];
  }

  UIAppController.prototype.didChangeEditorState = function(editor) {
    var o, _i, _len, _ref1;
    _ref1 = this.observers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appDidChangeEditorState === "function") {
        o.appDidChangeEditorState(this, editor);
      }
    }
    return null;
  };

  UIAppController.prototype.didUpdateConsole = function(console) {
    var o, _i, _len, _ref1;
    _ref1 = this.observers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appDidUpdateConsole === "function") {
        o.appDidUpdateConsole(this, console);
      }
    }
    return null;
  };

  UIAppController.prototype.willChangeCCS = function(newCCS) {
    var o, _i, _len, _ref1;
    _ref1 = this.observers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appWillChangeCCS === "function") {
        o.appWillChangeCCS(this, newCCS);
      }
    }
    return null;
  };

  UIAppController.prototype.didChangeCCS = function(newCCS) {
    var o, _i, _len, _ref1;
    _ref1 = this.observers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appDidChangeCCS === "function") {
        o.appDidChangeCCS(this, newCCS);
      }
    }
    return null;
  };

  UIAppController.prototype.setCCS = function(newCCS) {
    this.willChangeCCS(newCCS);
    this.ccs = newCCS;
    this.system = null;
    return this.didChangeCCS(newCCS);
  };

  UIAppController.prototype.resetCCS = function() {
    var o, _i, _len, _ref1;
    this.system = this.ccs.system.copy();
    _ref1 = this.observers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appDidResetCCS === "function") {
        o.appDidResetCCS(this, this.system);
      }
    }
    return this.system;
  };

  UIAppController.prototype.willPerformStep = function(step) {
    var o, _i, _len, _ref1;
    _ref1 = this.stepObservers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appWillPerformStep === "function") {
        o.appWillPerformStep(this, step);
      }
    }
    return null;
  };

  UIAppController.prototype.didPerformStep = function(step) {
    var o, _i, _len, _ref1;
    _ref1 = this.stepObservers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      o = _ref1[_i];
      if (typeof o.appDidPerformStep === "function") {
        o.appDidPerformStep(this, step);
      }
    }
    return null;
  };

  UIAppController.prototype.performStep = function(step) {
    if (!this.ccs) {
      throw new Error("Cannot perform step when no CCS is available!");
    }
    this.willPerformStep(step);
    this.system = this.history.performStep(step);
    if (step.action.channel.name === "println" && step.action.isOutputAction() && step.action.expression) {
      UILog("" + (step.action.expression.evaluate()));
    }
    return this.didPerformStep(step);
  };

  UIAppController.prototype.willOpenDocument = function(document) {};

  UIAppController.prototype.didOpenDocument = function(document) {};

  return UIAppController;

})();

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UIPseuCoEditor = (function() {
  function UIPseuCoEditor(editor) {
    var handler;
    this.editor = editor;
    this.editor._editorController = this;
    handler = function() {
      return this._editorController.handleChange();
    };
    $(this.editor).on("blur", handler);
    $(this.editor).on("input", handler);
    this.state = UIEditorState.possible;
    this.tree = null;
  }

  UIPseuCoEditor.prototype.handleChange = function() {
    return this.setText(this.editor.value);
  };

  UIPseuCoEditor.prototype.setText = function(text) {
    var col, e;
    this._setState(UIEditorState.possible);
    try {
      this.tree = PC.parser.parse(text);
      return this._setState(UIEditorState.valid);
    } catch (_error) {
      e = _error;
      col = e.column ? ", column " + e.column : "";
      UIError("Line " + e.line + col + ": " + e.message);
      this.tree = null;
      return this._setState(UIEditorState.invalid);
    }
  };

  UIPseuCoEditor.prototype.setTree = function(program) {};

  UIPseuCoEditor.prototype._setState = function(state) {
    this.state = state;
    return UI.app.didChangeEditorState(this);
  };

  return UIPseuCoEditor;

})();

UIPseuCoHack = (function(_super) {
  __extends(UIPseuCoHack, _super);

  function UIPseuCoHack(editor, jsField) {
    var handler;
    this.editor = editor;
    this.jsField = jsField;
    this.editor.__hack = this;
    $(this.editor).on("dblclick", function(event) {
      this.__hack.jsField.style.display = "block";
      return this.__hack.jsField.focus();
    });
    this.jsField.__hack = this;
    handler = function() {
      this.style.display = "none";
      return this.__hack.handleJS();
    };
    $(this.jsField).on("blur", handler);
    $(this.jsField).on("input", handler);
  }

  UIPseuCoHack.prototype.handleJS = function() {
    var col, e, js, obj;
    js = this.jsField.value;
    if (js.search(/[^ \t\n\r]/) === -1) {
      this._setState(UIEditorState.possible);
      this.tree = null;
    }
    try {
      obj = eval("__t = " + js);
      if (obj) {
        this.tree = obj.tree;
        this.editor.value = this.tree.toString();
        return this._setState(UIEditorState.valid);
      }
    } catch (_error) {
      e = _error;
      col = e.column ? ", column " + e.column : "";
      UIError("Line " + e.line + col + ": " + e.message);
      this.tree = null;
      this.editor.value = "";
      return this._setState(UIEditorState.invalid);
    }
  };

  return UIPseuCoHack;

})(UIPseuCoEditor);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


UICCSEditor = (function() {
  function UICCSEditor(textarea) {
    this.textarea = textarea;
  }

  UICCSEditor.prototype.appDidChangeEditorState = function(app, editor) {
    var ccs, compiler;
    if (editor !== app.pseuCoEditor || editor.state !== UIEditorState.valid) {
      return;
    }
    compiler = new PCC.Compiler(editor.tree);
    ccs = compiler.compileProgram();
    return app.setCCS(ccs);
  };

  UICCSEditor.prototype.appDidChangeCCS = function(app, newCCS) {
    return this.textarea.value = newCCS.toString();
  };

  return UICCSEditor;

})();

},{"CCS":2,"CCSCompiler":3,"PseuCo":4}],2:[function(require,module,exports){
CCSParser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "CCS": parse_CCS,
        "Process": parse_Process,
        "Restriction": parse_Restriction,
        "Sequence": parse_Sequence,
        "Parallel": parse_Parallel,
        "Choice": parse_Choice,
        "Prefix": parse_Prefix,
        "Condition": parse_Condition,
        "Input": parse_Input,
        "Output": parse_Output,
        "SimpleAction": parse_SimpleAction,
        "Action": parse_Action,
        "Trivial": parse_Trivial,
        "name": parse_name,
        "identifier": parse_identifier,
        "channel": parse_channel,
        "int": parse_int,
        "_": parse__,
        "__": parse___,
        "expression": parse_expression,
        "equalityExpression": parse_equalityExpression,
        "relationalExpression": parse_relationalExpression,
        "concatenatingExpression": parse_concatenatingExpression,
        "additiveExpression": parse_additiveExpression,
        "multiplicativeExpression": parse_multiplicativeExpression,
        "primaryExpression": parse_primaryExpression,
        "exp_identifier": parse_exp_identifier,
        "exp_boolean": parse_exp_boolean,
        "exp_integer": parse_exp_integer,
        "exp_string": parse_exp_string,
        "exp_escapeSequence": parse_exp_escapeSequence,
        "___": parse____
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = { offset: 0, line: 1, column: 1, seenCR: false };
      var reportFailures = 0;
      var rightmostFailuresPos = { offset: 0, line: 1, column: 1, seenCR: false };
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function clone(object) {
        var result = {};
        for (var key in object) {
          result[key] = object[key];
        }
        return result;
      }
      
      function advance(pos, n) {
        var endOffset = pos.offset + n;
        
        for (var offset = pos.offset; offset < endOffset; offset++) {
          var ch = input.charAt(offset);
          if (ch === "\n") {
            if (!pos.seenCR) { pos.line++; }
            pos.column = 1;
            pos.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            pos.line++;
            pos.column = 1;
            pos.seenCR = true;
          } else {
            pos.column++;
            pos.seenCR = false;
          }
        }
        
        pos.offset += n;
      }
      
      function matchFailed(failure) {
        if (pos.offset < rightmostFailuresPos.offset) {
          return;
        }
        
        if (pos.offset > rightmostFailuresPos.offset) {
          rightmostFailuresPos = clone(pos);
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0;
        var pos0;
        
        pos0 = clone(pos);
        result0 = parse_CCS();
        if (result0 !== null) {
          result0 = (function(offset, line, column, C) { return C; })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_CCS() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = [];
        result1 = parse_Process();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_Process();
        }
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_Restriction();
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, PDefs, System) { 
        		                                	var defs = [];
        		                                  	for (var i = 0; i < PDefs.length; i++) {
        		                                  		defs.push(PDefs[i]);
        		                                  	}
        		                                  	return new CCS(defs, System);
        		                                })(pos0.offset, pos0.line, pos0.column, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Process() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
        var pos0, pos1, pos2, pos3, pos4, pos5;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_name();
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              pos2 = clone(pos);
              pos3 = clone(pos);
              if (input.charCodeAt(pos.offset) === 91) {
                result3 = "[";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"[\"");
                }
              }
              if (result3 !== null) {
                result4 = parse__();
                if (result4 !== null) {
                  result5 = parse_identifier();
                  if (result5 !== null) {
                    result6 = [];
                    pos4 = clone(pos);
                    pos5 = clone(pos);
                    result7 = parse__();
                    if (result7 !== null) {
                      if (input.charCodeAt(pos.offset) === 44) {
                        result8 = ",";
                        advance(pos, 1);
                      } else {
                        result8 = null;
                        if (reportFailures === 0) {
                          matchFailed("\",\"");
                        }
                      }
                      if (result8 !== null) {
                        result9 = parse__();
                        if (result9 !== null) {
                          result10 = parse_identifier();
                          if (result10 !== null) {
                            result7 = [result7, result8, result9, result10];
                          } else {
                            result7 = null;
                            pos = clone(pos5);
                          }
                        } else {
                          result7 = null;
                          pos = clone(pos5);
                        }
                      } else {
                        result7 = null;
                        pos = clone(pos5);
                      }
                    } else {
                      result7 = null;
                      pos = clone(pos5);
                    }
                    if (result7 !== null) {
                      result7 = (function(offset, line, column, v2) { return v2; })(pos4.offset, pos4.line, pos4.column, result7[3]);
                    }
                    if (result7 === null) {
                      pos = clone(pos4);
                    }
                    while (result7 !== null) {
                      result6.push(result7);
                      pos4 = clone(pos);
                      pos5 = clone(pos);
                      result7 = parse__();
                      if (result7 !== null) {
                        if (input.charCodeAt(pos.offset) === 44) {
                          result8 = ",";
                          advance(pos, 1);
                        } else {
                          result8 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (result8 !== null) {
                          result9 = parse__();
                          if (result9 !== null) {
                            result10 = parse_identifier();
                            if (result10 !== null) {
                              result7 = [result7, result8, result9, result10];
                            } else {
                              result7 = null;
                              pos = clone(pos5);
                            }
                          } else {
                            result7 = null;
                            pos = clone(pos5);
                          }
                        } else {
                          result7 = null;
                          pos = clone(pos5);
                        }
                      } else {
                        result7 = null;
                        pos = clone(pos5);
                      }
                      if (result7 !== null) {
                        result7 = (function(offset, line, column, v2) { return v2; })(pos4.offset, pos4.line, pos4.column, result7[3]);
                      }
                      if (result7 === null) {
                        pos = clone(pos4);
                      }
                    }
                    if (result6 !== null) {
                      result7 = parse__();
                      if (result7 !== null) {
                        if (input.charCodeAt(pos.offset) === 93) {
                          result8 = "]";
                          advance(pos, 1);
                        } else {
                          result8 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"]\"");
                          }
                        }
                        if (result8 !== null) {
                          result9 = parse__();
                          if (result9 !== null) {
                            result3 = [result3, result4, result5, result6, result7, result8, result9];
                          } else {
                            result3 = null;
                            pos = clone(pos3);
                          }
                        } else {
                          result3 = null;
                          pos = clone(pos3);
                        }
                      } else {
                        result3 = null;
                        pos = clone(pos3);
                      }
                    } else {
                      result3 = null;
                      pos = clone(pos3);
                    }
                  } else {
                    result3 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
              if (result3 !== null) {
                result3 = (function(offset, line, column, v, vs) { vs.unshift(v); return vs; })(pos2.offset, pos2.line, pos2.column, result3[2], result3[3]);
              }
              if (result3 === null) {
                pos = clone(pos2);
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                if (input.substr(pos.offset, 2) === ":=") {
                  result4 = ":=";
                  advance(pos, 2);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":=\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_Restriction();
                  if (result5 !== null) {
                    result6 = parse___();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos.offset) === 10) {
                        result7 = "\n";
                        advance(pos, 1);
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\n\"");
                        }
                      }
                      if (result7 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                      } else {
                        result0 = null;
                        pos = clone(pos1);
                      }
                    } else {
                      result0 = null;
                      pos = clone(pos1);
                    }
                  } else {
                    result0 = null;
                    pos = clone(pos1);
                  }
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, n, params, P) { 
        		                                  return new CCSProcessDefinition(n.name, P, params == "" ? null : params);
        		                                })(pos0.offset, pos0.line, pos0.column, result0[1], result0[3], result0[5]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Restriction() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;
        var pos0, pos1, pos2, pos3, pos4, pos5, pos6, pos7;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_Sequence();
          if (result1 !== null) {
            pos2 = clone(pos);
            pos3 = clone(pos);
            result2 = parse__();
            if (result2 !== null) {
              if (input.charCodeAt(pos.offset) === 92) {
                result3 = "\\";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\\"");
                }
              }
              if (result3 !== null) {
                result4 = parse__();
                if (result4 !== null) {
                  if (input.charCodeAt(pos.offset) === 123) {
                    result5 = "{";
                    advance(pos, 1);
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"{\"");
                    }
                  }
                  if (result5 !== null) {
                    pos4 = clone(pos);
                    pos5 = clone(pos);
                    result6 = parse__();
                    if (result6 !== null) {
                      result7 = parse_channel();
                      if (result7 === null) {
                        if (input.charCodeAt(pos.offset) === 42) {
                          result7 = "*";
                          advance(pos, 1);
                        } else {
                          result7 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"*\"");
                          }
                        }
                      }
                      if (result7 !== null) {
                        result8 = [];
                        pos6 = clone(pos);
                        pos7 = clone(pos);
                        result9 = parse__();
                        if (result9 !== null) {
                          if (input.charCodeAt(pos.offset) === 44) {
                            result10 = ",";
                            advance(pos, 1);
                          } else {
                            result10 = null;
                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }
                          if (result10 !== null) {
                            result11 = parse__();
                            if (result11 !== null) {
                              result12 = parse_channel();
                              if (result12 !== null) {
                                result9 = [result9, result10, result11, result12];
                              } else {
                                result9 = null;
                                pos = clone(pos7);
                              }
                            } else {
                              result9 = null;
                              pos = clone(pos7);
                            }
                          } else {
                            result9 = null;
                            pos = clone(pos7);
                          }
                        } else {
                          result9 = null;
                          pos = clone(pos7);
                        }
                        if (result9 !== null) {
                          result9 = (function(offset, line, column, a2) { return a2; })(pos6.offset, pos6.line, pos6.column, result9[3]);
                        }
                        if (result9 === null) {
                          pos = clone(pos6);
                        }
                        while (result9 !== null) {
                          result8.push(result9);
                          pos6 = clone(pos);
                          pos7 = clone(pos);
                          result9 = parse__();
                          if (result9 !== null) {
                            if (input.charCodeAt(pos.offset) === 44) {
                              result10 = ",";
                              advance(pos, 1);
                            } else {
                              result10 = null;
                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                            if (result10 !== null) {
                              result11 = parse__();
                              if (result11 !== null) {
                                result12 = parse_channel();
                                if (result12 !== null) {
                                  result9 = [result9, result10, result11, result12];
                                } else {
                                  result9 = null;
                                  pos = clone(pos7);
                                }
                              } else {
                                result9 = null;
                                pos = clone(pos7);
                              }
                            } else {
                              result9 = null;
                              pos = clone(pos7);
                            }
                          } else {
                            result9 = null;
                            pos = clone(pos7);
                          }
                          if (result9 !== null) {
                            result9 = (function(offset, line, column, a2) { return a2; })(pos6.offset, pos6.line, pos6.column, result9[3]);
                          }
                          if (result9 === null) {
                            pos = clone(pos6);
                          }
                        }
                        if (result8 !== null) {
                          result6 = [result6, result7, result8];
                        } else {
                          result6 = null;
                          pos = clone(pos5);
                        }
                      } else {
                        result6 = null;
                        pos = clone(pos5);
                      }
                    } else {
                      result6 = null;
                      pos = clone(pos5);
                    }
                    if (result6 !== null) {
                      result6 = (function(offset, line, column, a1, as2) { as2.unshift(a1); return as2; })(pos4.offset, pos4.line, pos4.column, result6[1], result6[2]);
                    }
                    if (result6 === null) {
                      pos = clone(pos4);
                    }
                    result6 = result6 !== null ? result6 : "";
                    if (result6 !== null) {
                      result7 = parse__();
                      if (result7 !== null) {
                        if (input.charCodeAt(pos.offset) === 125) {
                          result8 = "}";
                          advance(pos, 1);
                        } else {
                          result8 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"}\"");
                          }
                        }
                        if (result8 !== null) {
                          result2 = [result2, result3, result4, result5, result6, result7, result8];
                        } else {
                          result2 = null;
                          pos = clone(pos3);
                        }
                      } else {
                        result2 = null;
                        pos = clone(pos3);
                      }
                    } else {
                      result2 = null;
                      pos = clone(pos3);
                    }
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
            if (result2 !== null) {
              result2 = (function(offset, line, column, as) { return  as; })(pos2.offset, pos2.line, pos2.column, result2[4]);
            }
            if (result2 === null) {
              pos = clone(pos2);
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, P, res) {
          											return res == "" ? P : new CCSRestriction(P, res);
          										})(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Sequence() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_Parallel();
          if (result1 !== null) {
            result2 = [];
            pos2 = clone(pos);
            pos3 = clone(pos);
            result3 = parse__();
            if (result3 !== null) {
              if (input.charCodeAt(pos.offset) === 59) {
                result4 = ";";
                advance(pos, 1);
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\";\"");
                }
              }
              if (result4 !== null) {
                result5 = parse_Parallel();
                if (result5 !== null) {
                  result3 = [result3, result4, result5];
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
            } else {
              result3 = null;
              pos = clone(pos3);
            }
            if (result3 !== null) {
              result3 = (function(offset, line, column, Q) { return Q; })(pos2.offset, pos2.line, pos2.column, result3[2]);
            }
            if (result3 === null) {
              pos = clone(pos2);
            }
            while (result3 !== null) {
              result2.push(result3);
              pos2 = clone(pos);
              pos3 = clone(pos);
              result3 = parse__();
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 59) {
                  result4 = ";";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_Parallel();
                  if (result5 !== null) {
                    result3 = [result3, result4, result5];
                  } else {
                    result3 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
              if (result3 !== null) {
                result3 = (function(offset, line, column, Q) { return Q; })(pos2.offset, pos2.line, pos2.column, result3[2]);
              }
              if (result3 === null) {
                pos = clone(pos2);
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, P, Ps) {
        		                                  Ps.unshift(P);
        		                                  while(Ps.length > 1){
        		                                    var p = Ps.shift();
        		                                    var q = Ps.shift();
        		                                    Ps.unshift(new CCSSequence(p,q));
        		                                  }
        		                                  return Ps[0];
        		                                })(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Parallel() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_Choice();
          if (result1 !== null) {
            result2 = [];
            pos2 = clone(pos);
            pos3 = clone(pos);
            result3 = parse__();
            if (result3 !== null) {
              if (input.charCodeAt(pos.offset) === 124) {
                result4 = "|";
                advance(pos, 1);
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"|\"");
                }
              }
              if (result4 !== null) {
                result5 = parse_Choice();
                if (result5 !== null) {
                  result3 = [result3, result4, result5];
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
            } else {
              result3 = null;
              pos = clone(pos3);
            }
            if (result3 !== null) {
              result3 = (function(offset, line, column, Q) { return Q; })(pos2.offset, pos2.line, pos2.column, result3[2]);
            }
            if (result3 === null) {
              pos = clone(pos2);
            }
            while (result3 !== null) {
              result2.push(result3);
              pos2 = clone(pos);
              pos3 = clone(pos);
              result3 = parse__();
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 124) {
                  result4 = "|";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"|\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_Choice();
                  if (result5 !== null) {
                    result3 = [result3, result4, result5];
                  } else {
                    result3 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
              if (result3 !== null) {
                result3 = (function(offset, line, column, Q) { return Q; })(pos2.offset, pos2.line, pos2.column, result3[2]);
              }
              if (result3 === null) {
                pos = clone(pos2);
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, P, Ps) {
        		                                  Ps.unshift(P);
        		                                  while(Ps.length > 1){
        		                                    var p = Ps.shift();
        		                                    var q = Ps.shift();
        		                                    Ps.unshift(new CCSParallel(p,q));
        		                                  }
        		                                  return Ps[0];
        		                                })(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Choice() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          result1 = parse_Prefix();
          if (result1 !== null) {
            result2 = [];
            pos2 = clone(pos);
            pos3 = clone(pos);
            result3 = parse__();
            if (result3 !== null) {
              if (input.charCodeAt(pos.offset) === 43) {
                result4 = "+";
                advance(pos, 1);
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (result4 !== null) {
                result5 = parse_Prefix();
                if (result5 !== null) {
                  result3 = [result3, result4, result5];
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
            } else {
              result3 = null;
              pos = clone(pos3);
            }
            if (result3 !== null) {
              result3 = (function(offset, line, column, Q) { return Q; })(pos2.offset, pos2.line, pos2.column, result3[2]);
            }
            if (result3 === null) {
              pos = clone(pos2);
            }
            while (result3 !== null) {
              result2.push(result3);
              pos2 = clone(pos);
              pos3 = clone(pos);
              result3 = parse__();
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 43) {
                  result4 = "+";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result4 !== null) {
                  result5 = parse_Prefix();
                  if (result5 !== null) {
                    result3 = [result3, result4, result5];
                  } else {
                    result3 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
              if (result3 !== null) {
                result3 = (function(offset, line, column, Q) { return Q; })(pos2.offset, pos2.line, pos2.column, result3[2]);
              }
              if (result3 === null) {
                pos = clone(pos2);
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, P, Ps) {
        									    Ps.unshift(P);
        									    while(Ps.length > 1){
        									      var p = Ps.shift();
        									      var q = Ps.shift();
        									      Ps.unshift(new CCSChoice(p,q));
        									    }
        									    return Ps[0];
        									  })(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Prefix() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        result0 = parse_Condition();
        if (result0 === null) {
          pos0 = clone(pos);
          pos1 = clone(pos);
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_Input();
            if (result1 === null) {
              result1 = parse_Output();
              if (result1 === null) {
                result1 = parse_SimpleAction();
              }
            }
            if (result1 !== null) {
              result2 = parse__();
              if (result2 !== null) {
                if (input.charCodeAt(pos.offset) === 46) {
                  result3 = ".";
                  advance(pos, 1);
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result3 !== null) {
                  result4 = parse_Prefix();
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = clone(pos1);
                  }
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, A, P) { 
          										return new CCSPrefix(A, P); 
          									})(pos0.offset, pos0.line, pos0.column, result0[1], result0[4]);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            result0 = parse_Trivial();
          }
        }
        return result0;
      }
      
      function parse_Condition() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9;
        var pos0, pos1;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos.offset, 4) === "when") {
            result1 = "when";
            advance(pos, 4);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"when\"");
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              if (input.charCodeAt(pos.offset) === 40) {
                result3 = "(";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result3 !== null) {
                result4 = parse__();
                if (result4 !== null) {
                  result5 = parse_expression();
                  if (result5 !== null) {
                    result6 = parse__();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos.offset) === 41) {
                        result7 = ")";
                        advance(pos, 1);
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\")\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse__();
                        if (result8 !== null) {
                          result9 = parse_Prefix();
                          if (result9 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                          } else {
                            result0 = null;
                            pos = clone(pos1);
                          }
                        } else {
                          result0 = null;
                          pos = clone(pos1);
                        }
                      } else {
                        result0 = null;
                        pos = clone(pos1);
                      }
                    } else {
                      result0 = null;
                      pos = clone(pos1);
                    }
                  } else {
                    result0 = null;
                    pos = clone(pos1);
                  }
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, e, P) {
        	  									return new CCSCondition(e, P);
        	  								})(pos0.offset, pos0.line, pos0.column, result0[5], result0[9]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Input() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_Action();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 63) {
              result2 = "?";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (result2 !== null) {
              pos2 = clone(pos);
              pos3 = clone(pos);
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_identifier();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
              if (result3 !== null) {
                result3 = (function(offset, line, column, t) { return t; })(pos2.offset, pos2.line, pos2.column, result3[1]);
              }
              if (result3 === null) {
                pos = clone(pos2);
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, a, v) { 
        	  									return new CCSInput(a, v); 
        	  								})(pos0.offset, pos0.line, pos0.column, result0[0], result0[3]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Output() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_Action();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 33) {
              result2 = "!";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
            if (result2 !== null) {
              pos2 = clone(pos);
              pos3 = clone(pos);
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_expression();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = clone(pos3);
                }
              } else {
                result3 = null;
                pos = clone(pos3);
              }
              if (result3 !== null) {
                result3 = (function(offset, line, column, t) { return t; })(pos2.offset, pos2.line, pos2.column, result3[1]);
              }
              if (result3 === null) {
                pos = clone(pos2);
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, a, e) { 
        	  									return new CCSOutput(a, (e == "") ? null : e); 
        	  								})(pos0.offset, pos0.line, pos0.column, result0[0], result0[3]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_SimpleAction() {
        var result0;
        var pos0;
        
        pos0 = clone(pos);
        result0 = parse_Action();
        if (result0 !== null) {
          result0 = (function(offset, line, column, a) { 
        	                                	return new CCSSimpleAction(a); 
        	                                })(pos0.offset, pos0.line, pos0.column, result0);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Action() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_channel();
        if (result0 !== null) {
          pos2 = clone(pos);
          pos3 = clone(pos);
          if (input.charCodeAt(pos.offset) === 40) {
            result1 = "(";
            advance(pos, 1);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_expression();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (input.charCodeAt(pos.offset) === 41) {
                result3 = ")";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\")\"");
                }
              }
              if (result3 !== null) {
                result1 = [result1, result2, result3];
              } else {
                result1 = null;
                pos = clone(pos3);
              }
            } else {
              result1 = null;
              pos = clone(pos3);
            }
          } else {
            result1 = null;
            pos = clone(pos3);
          }
          if (result1 !== null) {
            result1 = (function(offset, line, column, e) { return e; })(pos2.offset, pos2.line, pos2.column, result1[1]);
          }
          if (result1 === null) {
            pos = clone(pos2);
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, c, e) {
          										if (e == "") e = null;
          										return new CCSChannel(c, e);
          									})(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_Trivial() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
        var pos0, pos1, pos2, pos3, pos4, pos5;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse__();
        if (result0 !== null) {
          if (input.charCodeAt(pos.offset) === 40) {
            result1 = "(";
            advance(pos, 1);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_Restriction();
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 41) {
                  result4 = ")";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, P) { 
          										return P; 
          									})(pos0.offset, pos0.line, pos0.column, result0[2]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          pos1 = clone(pos);
          result0 = parse__();
          if (result0 !== null) {
            if (input.charCodeAt(pos.offset) === 48) {
              result1 = "0";
              advance(pos, 1);
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"0\"");
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) { 
            										return new CCSStop(); 
            									})(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            pos1 = clone(pos);
            result0 = parse__();
            if (result0 !== null) {
              if (input.charCodeAt(pos.offset) === 49) {
                result1 = "1";
                advance(pos, 1);
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"1\"");
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
            if (result0 !== null) {
              result0 = (function(offset, line, column) { 
              										return new CCSExit(); 
              									})(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
            if (result0 === null) {
              pos0 = clone(pos);
              pos1 = clone(pos);
              result0 = parse__();
              if (result0 !== null) {
                result1 = parse_name();
                if (result1 !== null) {
                  pos2 = clone(pos);
                  pos3 = clone(pos);
                  result2 = parse__();
                  if (result2 !== null) {
                    if (input.charCodeAt(pos.offset) === 91) {
                      result3 = "[";
                      advance(pos, 1);
                    } else {
                      result3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"[\"");
                      }
                    }
                    if (result3 !== null) {
                      result4 = parse__();
                      if (result4 !== null) {
                        result5 = parse_expression();
                        if (result5 !== null) {
                          result6 = [];
                          pos4 = clone(pos);
                          pos5 = clone(pos);
                          result7 = parse__();
                          if (result7 !== null) {
                            if (input.charCodeAt(pos.offset) === 44) {
                              result8 = ",";
                              advance(pos, 1);
                            } else {
                              result8 = null;
                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                            if (result8 !== null) {
                              result9 = parse__();
                              if (result9 !== null) {
                                result10 = parse_expression();
                                if (result10 !== null) {
                                  result7 = [result7, result8, result9, result10];
                                } else {
                                  result7 = null;
                                  pos = clone(pos5);
                                }
                              } else {
                                result7 = null;
                                pos = clone(pos5);
                              }
                            } else {
                              result7 = null;
                              pos = clone(pos5);
                            }
                          } else {
                            result7 = null;
                            pos = clone(pos5);
                          }
                          if (result7 !== null) {
                            result7 = (function(offset, line, column, e1) { return e1; })(pos4.offset, pos4.line, pos4.column, result7[3]);
                          }
                          if (result7 === null) {
                            pos = clone(pos4);
                          }
                          while (result7 !== null) {
                            result6.push(result7);
                            pos4 = clone(pos);
                            pos5 = clone(pos);
                            result7 = parse__();
                            if (result7 !== null) {
                              if (input.charCodeAt(pos.offset) === 44) {
                                result8 = ",";
                                advance(pos, 1);
                              } else {
                                result8 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\",\"");
                                }
                              }
                              if (result8 !== null) {
                                result9 = parse__();
                                if (result9 !== null) {
                                  result10 = parse_expression();
                                  if (result10 !== null) {
                                    result7 = [result7, result8, result9, result10];
                                  } else {
                                    result7 = null;
                                    pos = clone(pos5);
                                  }
                                } else {
                                  result7 = null;
                                  pos = clone(pos5);
                                }
                              } else {
                                result7 = null;
                                pos = clone(pos5);
                              }
                            } else {
                              result7 = null;
                              pos = clone(pos5);
                            }
                            if (result7 !== null) {
                              result7 = (function(offset, line, column, e1) { return e1; })(pos4.offset, pos4.line, pos4.column, result7[3]);
                            }
                            if (result7 === null) {
                              pos = clone(pos4);
                            }
                          }
                          if (result6 !== null) {
                            result7 = parse__();
                            if (result7 !== null) {
                              if (input.charCodeAt(pos.offset) === 93) {
                                result8 = "]";
                                advance(pos, 1);
                              } else {
                                result8 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"]\"");
                                }
                              }
                              if (result8 !== null) {
                                result2 = [result2, result3, result4, result5, result6, result7, result8];
                              } else {
                                result2 = null;
                                pos = clone(pos3);
                              }
                            } else {
                              result2 = null;
                              pos = clone(pos3);
                            }
                          } else {
                            result2 = null;
                            pos = clone(pos3);
                          }
                        } else {
                          result2 = null;
                          pos = clone(pos3);
                        }
                      } else {
                        result2 = null;
                        pos = clone(pos3);
                      }
                    } else {
                      result2 = null;
                      pos = clone(pos3);
                    }
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                  if (result2 !== null) {
                    result2 = (function(offset, line, column, e, es) { es.unshift(e); return es; })(pos2.offset, pos2.line, pos2.column, result2[3], result2[4]);
                  }
                  if (result2 === null) {
                    pos = clone(pos2);
                  }
                  result2 = result2 !== null ? result2 : "";
                  if (result2 !== null) {
                    result0 = [result0, result1, result2];
                  } else {
                    result0 = null;
                    pos = clone(pos1);
                  }
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
              if (result0 !== null) {
                result0 = (function(offset, line, column, n, args) { 
                                                		return new CCSProcessApplication(n.name, (typeof args == "string" ? null : args));
                                              	})(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
              }
              if (result0 === null) {
                pos = clone(pos0);
              }
            }
          }
        }
        return result0;
      }
      
      function parse_name() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[A-Z]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Za-z0-9_]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Za-z0-9_]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, first, rest) { return {name: first + rest.join(''), line: line, column: column}; })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("name");
        }
        return result0;
      }
      
      function parse_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[a-z]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Za-z0-9_]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Za-z0-9_]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, first, rest) { return first + rest.join(''); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_channel() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[a-z]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Za-z0-9_]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Za-z0-9_]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, first, rest) { return first + rest.join(''); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("channel");
        }
        return result0;
      }
      
      function parse_int() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        if (input.charCodeAt(pos.offset) === 48) {
          result0 = "0";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return 0; })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          pos1 = clone(pos);
          if (/^[1-9]/.test(input.charAt(pos.offset))) {
            result0 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column, first, rest) { return parseInt(first + rest.join('')); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("integer");
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[' '\n\r\t]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[' '\\n\\r\\t]");
          }
        }
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          pos1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 35) {
            result0 = "#";
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"#\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[^\n]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\n]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[^\n]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\n]");
                }
              }
            }
            if (result1 !== null) {
              if (input.charCodeAt(pos.offset) === 10) {
                result2 = "\n";
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\n\"");
                }
              }
              if (result2 !== null) {
                result3 = parse__();
                if (result3 !== null) {
                  result0 = [result0, result1, result2, result3];
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            result0 = parse___();
            if (result0 !== null) {
              result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[' '\t]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[' '\\t]");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          pos1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 35) {
            result0 = "#";
            advance(pos, 1);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"#\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[^\n]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\n]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[^\n]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\n]");
                }
              }
            }
            if (result1 !== null) {
              if (input.charCodeAt(pos.offset) === 10) {
                result2 = "\n";
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\n\"");
                }
              }
              if (result2 !== null) {
                result3 = parse___();
                if (result3 !== null) {
                  result0 = [result0, result1, result2, result3];
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
          if (result0 === null) {
            pos0 = clone(pos);
            pos1 = clone(pos);
            if (input.charCodeAt(pos.offset) === 35) {
              result0 = "#";
              advance(pos, 1);
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"#\"");
              }
            }
            if (result0 !== null) {
              result1 = [];
              if (/^[^\n]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\n]");
                }
              }
              while (result2 !== null) {
                result1.push(result2);
                if (/^[^\n]/.test(input.charAt(pos.offset))) {
                  result2 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\n]");
                  }
                }
              }
              if (result1 !== null) {
                pos2 = clone(pos);
                reportFailures++;
                if (/^[\S\s]/.test(input.charAt(pos.offset))) {
                  result2 = input.charAt(pos.offset);
                  advance(pos, 1);
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^]");
                  }
                }
                reportFailures--;
                if (result2 === null) {
                  result2 = "";
                } else {
                  result2 = null;
                  pos = clone(pos2);
                }
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
              } else {
                result0 = null;
                pos = clone(pos1);
              }
            } else {
              result0 = null;
              pos = clone(pos1);
            }
            if (result0 !== null) {
              result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
            }
            if (result0 === null) {
              pos = clone(pos0);
            }
            if (result0 === null) {
              pos0 = clone(pos);
              result0 = [];
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inline whitespace");
        }
        return result0;
      }
      
      function parse_expression() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse____();
        if (result0 !== null) {
          result1 = parse_equalityExpression();
          if (result1 !== null) {
            result2 = parse____();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, result) { return result; })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_equalityExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_relationalExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = clone(pos);
          pos3 = clone(pos);
          result2 = parse____();
          if (result2 !== null) {
            if (input.substr(pos.offset, 2) === "==") {
              result3 = "==";
              advance(pos, 2);
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"==\"");
              }
            }
            if (result3 === null) {
              if (input.substr(pos.offset, 2) === "!=") {
                result3 = "!=";
                advance(pos, 2);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!=\"");
                }
              }
            }
            if (result3 !== null) {
              result4 = parse____();
              if (result4 !== null) {
                result5 = parse_relationalExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
          } else {
            result2 = null;
            pos = clone(pos3);
          }
          if (result2 !== null) {
            result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
          }
          if (result2 === null) {
            pos = clone(pos2);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = clone(pos);
            pos3 = clone(pos);
            result2 = parse____();
            if (result2 !== null) {
              if (input.substr(pos.offset, 2) === "==") {
                result3 = "==";
                advance(pos, 2);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"==\"");
                }
              }
              if (result3 === null) {
                if (input.substr(pos.offset, 2) === "!=") {
                  result3 = "!=";
                  advance(pos, 2);
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"!=\"");
                  }
                }
              }
              if (result3 !== null) {
                result4 = parse____();
                if (result4 !== null) {
                  result5 = parse_relationalExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
            if (result2 !== null) {
              result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
            }
            if (result2 === null) {
              pos = clone(pos2);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, left, equal) { 
         			while (equal.length > 0) {
         				t = equal.shift();
         				left = new CCSEqualityExpression(left, t[1], t[0]);
         			}
         			return left;
         		})(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_relationalExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3, pos4;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_concatenatingExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = clone(pos);
          pos3 = clone(pos);
          result2 = parse____();
          if (result2 !== null) {
            pos4 = clone(pos);
            if (input.charCodeAt(pos.offset) === 60) {
              result3 = "<";
              advance(pos, 1);
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"<\"");
              }
            }
            if (result3 !== null) {
              if (input.charCodeAt(pos.offset) === 61) {
                result4 = "=";
                advance(pos, 1);
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (result4 !== null) {
                result3 = [result3, result4];
              } else {
                result3 = null;
                pos = clone(pos4);
              }
            } else {
              result3 = null;
              pos = clone(pos4);
            }
            if (result3 === null) {
              pos4 = clone(pos);
              if (input.charCodeAt(pos.offset) === 62) {
                result3 = ">";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\">\"");
                }
              }
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 61) {
                  result4 = "=";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = clone(pos4);
                }
              } else {
                result3 = null;
                pos = clone(pos4);
              }
              if (result3 === null) {
                if (input.charCodeAt(pos.offset) === 60) {
                  result3 = "<";
                  advance(pos, 1);
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"<\"");
                  }
                }
                if (result3 === null) {
                  if (input.charCodeAt(pos.offset) === 62) {
                    result3 = ">";
                    advance(pos, 1);
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\">\"");
                    }
                  }
                }
              }
            }
            if (result3 !== null) {
              result4 = parse____();
              if (result4 !== null) {
                result5 = parse_concatenatingExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
          } else {
            result2 = null;
            pos = clone(pos3);
          }
          if (result2 !== null) {
            result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
          }
          if (result2 === null) {
            pos = clone(pos2);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = clone(pos);
            pos3 = clone(pos);
            result2 = parse____();
            if (result2 !== null) {
              pos4 = clone(pos);
              if (input.charCodeAt(pos.offset) === 60) {
                result3 = "<";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (result3 !== null) {
                if (input.charCodeAt(pos.offset) === 61) {
                  result4 = "=";
                  advance(pos, 1);
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = clone(pos4);
                }
              } else {
                result3 = null;
                pos = clone(pos4);
              }
              if (result3 === null) {
                pos4 = clone(pos);
                if (input.charCodeAt(pos.offset) === 62) {
                  result3 = ">";
                  advance(pos, 1);
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">\"");
                  }
                }
                if (result3 !== null) {
                  if (input.charCodeAt(pos.offset) === 61) {
                    result4 = "=";
                    advance(pos, 1);
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }
                  if (result4 !== null) {
                    result3 = [result3, result4];
                  } else {
                    result3 = null;
                    pos = clone(pos4);
                  }
                } else {
                  result3 = null;
                  pos = clone(pos4);
                }
                if (result3 === null) {
                  if (input.charCodeAt(pos.offset) === 60) {
                    result3 = "<";
                    advance(pos, 1);
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"<\"");
                    }
                  }
                  if (result3 === null) {
                    if (input.charCodeAt(pos.offset) === 62) {
                      result3 = ">";
                      advance(pos, 1);
                    } else {
                      result3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\">\"");
                      }
                    }
                  }
                }
              }
              if (result3 !== null) {
                result4 = parse____();
                if (result4 !== null) {
                  result5 = parse_concatenatingExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
            if (result2 !== null) {
              result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
            }
            if (result2 === null) {
              pos = clone(pos2);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, left, relational) { 
         			while (relational.length > 0) {
         				t = relational.shift();
         				left = new CCSEqualityExpression(left, t[1], t[0]);
         			}
         			return left;
         		})(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_concatenatingExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_additiveExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = clone(pos);
          pos3 = clone(pos);
          result2 = parse____();
          if (result2 !== null) {
            if (input.charCodeAt(pos.offset) === 94) {
              result3 = "^";
              advance(pos, 1);
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"^\"");
              }
            }
            if (result3 !== null) {
              result4 = parse____();
              if (result4 !== null) {
                result5 = parse_additiveExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
          } else {
            result2 = null;
            pos = clone(pos3);
          }
          if (result2 !== null) {
            result2 = (function(offset, line, column, right) { return right; })(pos2.offset, pos2.line, pos2.column, result2[3]);
          }
          if (result2 === null) {
            pos = clone(pos2);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = clone(pos);
            pos3 = clone(pos);
            result2 = parse____();
            if (result2 !== null) {
              if (input.charCodeAt(pos.offset) === 94) {
                result3 = "^";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"^\"");
                }
              }
              if (result3 !== null) {
                result4 = parse____();
                if (result4 !== null) {
                  result5 = parse_additiveExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
            if (result2 !== null) {
              result2 = (function(offset, line, column, right) { return right; })(pos2.offset, pos2.line, pos2.column, result2[3]);
            }
            if (result2 === null) {
              pos = clone(pos2);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, left, concat) { 
         			while (concat.length > 0) {
         				t = concat.shift();
         				left = new CCSConcatenatingExpression(left, t);
         			}
         			return left;
         		})(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_additiveExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_multiplicativeExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = clone(pos);
          pos3 = clone(pos);
          result2 = parse____();
          if (result2 !== null) {
            if (input.charCodeAt(pos.offset) === 43) {
              result3 = "+";
              advance(pos, 1);
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (result3 === null) {
              if (input.charCodeAt(pos.offset) === 45) {
                result3 = "-";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
            }
            if (result3 !== null) {
              result4 = parse____();
              if (result4 !== null) {
                result5 = parse_multiplicativeExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
          } else {
            result2 = null;
            pos = clone(pos3);
          }
          if (result2 !== null) {
            result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
          }
          if (result2 === null) {
            pos = clone(pos2);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = clone(pos);
            pos3 = clone(pos);
            result2 = parse____();
            if (result2 !== null) {
              if (input.charCodeAt(pos.offset) === 43) {
                result3 = "+";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (result3 === null) {
                if (input.charCodeAt(pos.offset) === 45) {
                  result3 = "-";
                  advance(pos, 1);
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
              }
              if (result3 !== null) {
                result4 = parse____();
                if (result4 !== null) {
                  result5 = parse_multiplicativeExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
            if (result2 !== null) {
              result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
            }
            if (result2 === null) {
              pos = clone(pos2);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, left, addition) {
         			while (addition.length > 0) {
         				t = addition.shift();
         				left = new CCSAdditiveExpression(left, t[1], t[0]);
         			}
         			return left;
         		})(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_multiplicativeExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2, pos3;
        
        pos0 = clone(pos);
        pos1 = clone(pos);
        result0 = parse_primaryExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = clone(pos);
          pos3 = clone(pos);
          result2 = parse____();
          if (result2 !== null) {
            if (input.charCodeAt(pos.offset) === 42) {
              result3 = "*";
              advance(pos, 1);
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"*\"");
              }
            }
            if (result3 === null) {
              if (input.charCodeAt(pos.offset) === 47) {
                result3 = "/";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/\"");
                }
              }
            }
            if (result3 !== null) {
              result4 = parse____();
              if (result4 !== null) {
                result5 = parse_primaryExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
          } else {
            result2 = null;
            pos = clone(pos3);
          }
          if (result2 !== null) {
            result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
          }
          if (result2 === null) {
            pos = clone(pos2);
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = clone(pos);
            pos3 = clone(pos);
            result2 = parse____();
            if (result2 !== null) {
              if (input.charCodeAt(pos.offset) === 42) {
                result3 = "*";
                advance(pos, 1);
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"*\"");
                }
              }
              if (result3 === null) {
                if (input.charCodeAt(pos.offset) === 47) {
                  result3 = "/";
                  advance(pos, 1);
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"/\"");
                  }
                }
              }
              if (result3 !== null) {
                result4 = parse____();
                if (result4 !== null) {
                  result5 = parse_primaryExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = clone(pos3);
                  }
                } else {
                  result2 = null;
                  pos = clone(pos3);
                }
              } else {
                result2 = null;
                pos = clone(pos3);
              }
            } else {
              result2 = null;
              pos = clone(pos3);
            }
            if (result2 !== null) {
              result2 = (function(offset, line, column, op, right) { return [op, right]; })(pos2.offset, pos2.line, pos2.column, result2[1], result2[3]);
            }
            if (result2 === null) {
              pos = clone(pos2);
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, left, multiplication) {
         			while (multiplication.length > 0) {
         				t = multiplication.shift();
         				left = new CCSMultiplicativeExpression(left, t[1], t[0]);
         			}
         			return left;
         		})(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse_primaryExpression() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        result0 = parse_exp_boolean();
        if (result0 === null) {
          result0 = parse_exp_integer();
          if (result0 === null) {
            result0 = parse_exp_string();
            if (result0 === null) {
              result0 = parse_exp_identifier();
              if (result0 === null) {
                pos0 = clone(pos);
                pos1 = clone(pos);
                if (input.charCodeAt(pos.offset) === 40) {
                  result0 = "(";
                  advance(pos, 1);
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"(\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse____();
                  if (result1 !== null) {
                    result2 = parse_equalityExpression();
                    if (result2 !== null) {
                      result3 = parse____();
                      if (result3 !== null) {
                        if (input.charCodeAt(pos.offset) === 41) {
                          result4 = ")";
                          advance(pos, 1);
                        } else {
                          result4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\")\"");
                          }
                        }
                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = clone(pos1);
                        }
                      } else {
                        result0 = null;
                        pos = clone(pos1);
                      }
                    } else {
                      result0 = null;
                      pos = clone(pos1);
                    }
                  } else {
                    result0 = null;
                    pos = clone(pos1);
                  }
                } else {
                  result0 = null;
                  pos = clone(pos1);
                }
                if (result0 !== null) {
                  result0 = (function(offset, line, column, equality) { return equality; })(pos0.offset, pos0.line, pos0.column, result0[2]);
                }
                if (result0 === null) {
                  pos = clone(pos0);
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_exp_identifier() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (/^[a-z]/.test(input.charAt(pos.offset))) {
          result0 = input.charAt(pos.offset);
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Za-z0-9_]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[A-Za-z0-9_]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Za-z0-9_]");
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, first, rest) { return new CCSVariableExpression(first + rest.join('')); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_exp_boolean() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = clone(pos);
        if (input.substr(pos.offset, 4) === "true") {
          result0 = "true";
          advance(pos, 4);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"true\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) { return new CCSConstantExpression(true); })(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          if (input.substr(pos.offset, 5) === "false") {
            result0 = "false";
            advance(pos, 5);
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"false\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset, line, column) { return new CCSConstantExpression(false); })(pos0.offset, pos0.line, pos0.column);
          }
          if (result0 === null) {
            pos = clone(pos0);
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("boolean literal");
        }
        return result0;
      }
      
      function parse_exp_integer() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.charCodeAt(pos.offset) === 45) {
          result0 = "-";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos.offset))) {
            result2 = input.charAt(pos.offset);
            advance(pos, 1);
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, minus, digits) { return new CCSConstantExpression(parseInt(minus + digits.join(""))); })(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("integer literal");
        }
        return result0;
      }
      
      function parse_exp_string() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = clone(pos);
        pos1 = clone(pos);
        if (input.charCodeAt(pos.offset) === 34) {
          result0 = "\"";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_exp_escapeSequence();
          if (result2 === null) {
            if (/^[^"]/.test(input.charAt(pos.offset))) {
              result2 = input.charAt(pos.offset);
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[^\"]");
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_exp_escapeSequence();
            if (result2 === null) {
              if (/^[^"]/.test(input.charAt(pos.offset))) {
                result2 = input.charAt(pos.offset);
                advance(pos, 1);
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\"]");
                }
              }
            }
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos.offset) === 34) {
              result2 = "\"";
              advance(pos, 1);
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = clone(pos1);
            }
          } else {
            result0 = null;
            pos = clone(pos1);
          }
        } else {
          result0 = null;
          pos = clone(pos1);
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column, s) { return new CCSConstantExpression((s.join ? s.join("") : "")); })(pos0.offset, pos0.line, pos0.column, result0[1]);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("string literal");
        }
        return result0;
      }
      
      function parse_exp_escapeSequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = clone(pos);
        if (input.charCodeAt(pos.offset) === 92) {
          result0 = "\\";
          advance(pos, 1);
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          pos1 = clone(pos);
          if (input.charCodeAt(pos.offset) === 116) {
            result1 = "t";
            advance(pos, 1);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"t\"");
            }
          }
          if (result1 !== null) {
            result1 = (function(offset, line, column) { return '\\t'; })(pos1.offset, pos1.line, pos1.column);
          }
          if (result1 === null) {
            pos = clone(pos1);
          }
          if (result1 === null) {
            pos1 = clone(pos);
            if (input.charCodeAt(pos.offset) === 110) {
              result1 = "n";
              advance(pos, 1);
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"n\"");
              }
            }
            if (result1 !== null) {
              result1 = (function(offset, line, column) { return '\\n'; })(pos1.offset, pos1.line, pos1.column);
            }
            if (result1 === null) {
              pos = clone(pos1);
            }
            if (result1 === null) {
              pos1 = clone(pos);
              if (input.charCodeAt(pos.offset) === 114) {
                result1 = "r";
                advance(pos, 1);
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"r\"");
                }
              }
              if (result1 !== null) {
                result1 = (function(offset, line, column) { return '\\r'; })(pos1.offset, pos1.line, pos1.column);
              }
              if (result1 === null) {
                pos = clone(pos1);
              }
              if (result1 === null) {
                pos1 = clone(pos);
                if (input.charCodeAt(pos.offset) === 34) {
                  result1 = "\"";
                  advance(pos, 1);
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                if (result1 !== null) {
                  result1 = (function(offset, line, column) { return '\\"'; })(pos1.offset, pos1.line, pos1.column);
                }
                if (result1 === null) {
                  pos = clone(pos1);
                }
                if (result1 === null) {
                  pos1 = clone(pos);
                  if (input.charCodeAt(pos.offset) === 92) {
                    result1 = "\\";
                    advance(pos, 1);
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\\\"");
                    }
                  }
                  if (result1 !== null) {
                    result1 = (function(offset, line, column) { return '\\\\'; })(pos1.offset, pos1.line, pos1.column);
                  }
                  if (result1 === null) {
                    pos = clone(pos1);
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = clone(pos0);
          }
        } else {
          result0 = null;
          pos = clone(pos0);
        }
        return result0;
      }
      
      function parse____() {
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = clone(pos);
        result0 = [];
        if (input.charCodeAt(pos.offset) === 32) {
          result1 = " ";
          advance(pos, 1);
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (input.charCodeAt(pos.offset) === 32) {
            result1 = " ";
            advance(pos, 1);
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, line, column) {})(pos0.offset, pos0.line, pos0.column);
        }
        if (result0 === null) {
          pos = clone(pos0);
        }
        if (result0 === null) {
          pos0 = clone(pos);
          result0 = [];
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos.offset === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos.offset < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos.offset === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos.offset !== input.length) {
        var offset = Math.max(pos.offset, rightmostFailuresPos.offset);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = pos.offset > rightmostFailuresPos.offset ? pos : rightmostFailuresPos;
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
// Generated by CoffeeScript 1.6.3
/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var ActionSets, CCS, CCSAction, CCSAdditiveExpression, CCSBaseStep, CCSChannel, CCSChoice, CCSChoiceLRule, CCSChoiceRRule, CCSConcatenatingExpression, CCSCondRule, CCSCondition, CCSConstantExpression, CCSEqualityExpression, CCSExecutor, CCSExecutorCopyOnPerformStepPolicy, CCSExecutorDefaultStepPicker, CCSExecutorStepCountPerExecutionUnit, CCSExit, CCSExitChannel, CCSExitRule, CCSExpression, CCSGetMostGeneralType, CCSInput, CCSInputRule, CCSInputStep, CCSInternalActionCreate, CCSInternalChannel, CCSMatch, CCSMatchRule, CCSMultiplicativeExpression, CCSOutput, CCSOutputRule, CCSParLRule, CCSParRRule, CCSParallel, CCSPrefix, CCSPrefixRule, CCSProcess, CCSProcessApplication, CCSProcessDefinition, CCSRecRule, CCSRelationalExpression, CCSResRule, CCSRestriction, CCSSeq1Rule, CCSSeq2Rule, CCSSequence, CCSSimpleAction, CCSStep, CCSStop, CCSSyncExitRule, CCSSyncRule, CCSTypeChannel, CCSTypeUnknown, CCSTypeValue, CCSUIChannel, CCSVariableExpression, DP, DS, DSteps, ObjID, exports, _DEBUG, _ref, _ref1, _ref2, _ref3,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CCSInternalChannel = "\u03c4";

CCSExitChannel = "\u03b4";

CCSUIChannel = "\u03c8";

ObjID = 1;

_DEBUG = [];

DSteps = [];

DS = function() {
  var i, s, _i, _len;
  console.log(ccs.system.toString());
  DSteps = ccs.getPossibleSteps();
  for (i = _i = 0, _len = DSteps.length; _i < _len; i = ++_i) {
    s = DSteps[i];
    console.log("\"" + i + "\": " + (s.toString()));
  }
  return null;
};

DP = function(i) {
  ccs.performStep(DSteps[i]);
  return DS();
};

CCSTypeUnknown = 0;

CCSTypeChannel = 1;

CCSTypeValue = 2;

CCSGetMostGeneralType = function(t1, t2) {
  if (t2 === CCSTypeUnknown) {
    return t1;
  }
  if (t1 === CCSTypeUnknown) {
    return t2;
  }
  if (t1 === t2) {
    return t1;
  }
  throw new Error("Incopatible Types: " + t1 + " and " + t2 + "!");
};

CCS = (function() {
  function CCS(processDefinitions, system) {
    var pd, _i, _len, _ref;
    this.processDefinitions = processDefinitions;
    this.system = system;
    this.system.setCCS(this);
    _ref = this.processDefinitions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pd = _ref[_i];
      pd.setCCS(this);
      pd.computeArgTypes();
    }
  }

  CCS.prototype.getProcessDefinition = function(name, argCount) {
    var pd, result, _i, _len, _ref;
    result = null;
    _ref = this.processDefinitions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pd = _ref[_i];
      if (pd.name === name && argCount === pd.getArgCount()) {
        result = pd;
      }
    }
    return result;
  };

  CCS.prototype.getPossibleSteps = function(copyOnPerform) {
    return this.system.getPossibleSteps(copyOnPerform);
  };

  CCS.prototype.toString = function(expressionOnly) {
    var process;
    if (expressionOnly) {
      return this.system.toString();
    } else {
      return "" + (((function() {
        var _i, _len, _ref, _results;
        _ref = this.processDefinitions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          process = _ref[_i];
          _results.push(process.toString());
        }
        return _results;
      }).call(this)).join("")) + "\n" + (this.system.toString());
    }
  };

  return CCS;

})();

CCSProcessDefinition = (function() {
  function CCSProcessDefinition(name, process, params) {
    var p;
    this.name = name;
    this.process = process;
    this.params = params;
    if (this.params) {
      this.types = (function() {
        var _i, _len, _ref, _results;
        _ref = this.params;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(CCSTypeUnknown);
        }
        return _results;
      }).call(this);
    }
  }

  CCSProcessDefinition.prototype.getArgCount = function() {
    if (this.params) {
      return this.params.length;
    } else {
      return 0;
    }
  };

  CCSProcessDefinition.prototype.setCCS = function(ccs) {
    return this.process.setCCS(ccs);
  };

  CCSProcessDefinition.prototype.computeArgTypes = function() {
    var x;
    if (!this.params) {
      return null;
    }
    return this.types = (function() {
      var _i, _len, _ref, _results;
      _ref = this.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(this.process.getTypeOfIdentifier(x, CCSTypeUnknown));
      }
      return _results;
    }).call(this);
  };

  CCSProcessDefinition.prototype.toString = function() {
    var result, _ref;
    result = this.name;
    if (((_ref = this.params) != null ? _ref.length : void 0) > 0) {
      result += "[" + (this.params.join(", ")) + "]";
    }
    result += " := " + (this.process.toString()) + "\n";
    return result;
  };

  return CCSProcessDefinition;

})();

CCSProcess = (function() {
  function CCSProcess() {
    var subprocesses;
    subprocesses = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.subprocesses = subprocesses;
    this.__id = ObjID++;
  }

  CCSProcess.prototype.setCCS = function(ccs) {
    var p, _i, _len, _ref, _results;
    this.ccs = ccs;
    _ref = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(p.setCCS(this.ccs));
    }
    return _results;
  };

  CCSProcess.prototype._setCCS = function(ccs) {
    this.ccs = ccs;
    if (!this.ccs) {
      throw "no ccs";
    }
    return this;
  };

  CCSProcess.prototype.getLeft = function() {
    return this.subprocesses[0];
  };

  CCSProcess.prototype.getRight = function() {
    return this.subprocesses[1];
  };

  CCSProcess.prototype.setLeft = function(left) {
    return this.subprocesses[0] = left;
  };

  CCSProcess.prototype.setRight = function(right) {
    return this.subprocesses[1] = right;
  };

  CCSProcess.prototype.replaceVariable = function(varName, exp) {
    var p, _i, _len, _ref, _results;
    _ref = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(p.replaceVariable(varName, exp));
    }
    return _results;
  };

  CCSProcess.prototype.replaceVariableWithValue = function(varName, val) {
    return this.replaceVariable(varName, new CCSConstantExpression(val));
  };

  CCSProcess.prototype.replaceChannelName = function(old, newID) {
    var p, _i, _len, _ref, _results;
    _ref = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(p.replaceChannelName(old, newID));
    }
    return _results;
  };

  CCSProcess.prototype.getTypeOfIdentifier = function(identifier, type) {
    var p, t, _i, _len, _ref;
    _ref = (function() {
      var _j, _len, _ref, _results;
      _ref = this.subprocesses;
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        p = _ref[_j];
        _results.push(p.getTypeOfIdentifier(identifier, type));
      }
      return _results;
    }).call(this);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      type = CCSGetMostGeneralType(type, t);
    }
    return type;
  };

  CCSProcess.prototype.getApplicapleRules = function() {
    return [];
  };

  CCSProcess.prototype.getPossibleSteps = function(copyOnPerform) {
    var rule;
    if (!copyOnPerform) {
      copyOnPerform = false;
    }
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.getApplicapleRules();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _results.push(rule.getPossibleSteps(this, copyOnPerform));
      }
      return _results;
    }).call(this)).concatChildren();
  };

  CCSProcess.prototype.needsBracketsForSubprocess = function(process) {
    return (this.getPrecedence != null) && (process.getPrecedence != null) && process.getPrecedence() < this.getPrecedence();
  };

  CCSProcess.prototype.stringForSubprocess = function(process) {
    if (this.needsBracketsForSubprocess(process)) {
      return "(" + (process.toString()) + ")";
    } else {
      return "" + (process.toString());
    }
  };

  CCSProcess.prototype.getPrefixes = function() {
    var p;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.subprocesses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.getPrefixes());
      }
      return _results;
    }).call(this)).concatChildren();
  };

  CCSProcess.prototype.getExits = function() {
    var p;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.subprocesses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.getExits());
      }
      return _results;
    }).call(this)).concatChildren();
  };

  return CCSProcess;

})();

CCSStop = (function(_super) {
  __extends(CCSStop, _super);

  function CCSStop() {
    _ref = CCSStop.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  CCSStop.prototype.getPrecedence = function() {
    return 12;
  };

  CCSStop.prototype.toString = function() {
    return "0";
  };

  CCSStop.prototype.copy = function() {
    return (new CCSStop())._setCCS(this.ccs);
  };

  return CCSStop;

})(CCSProcess);

CCSExit = (function(_super) {
  __extends(CCSExit, _super);

  function CCSExit() {
    _ref1 = CCSExit.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  CCSExit.prototype.getPrecedence = function() {
    return 12;
  };

  CCSExit.prototype.getApplicapleRules = function() {
    return [CCSExitRule];
  };

  CCSExit.prototype.getExits = function() {
    return [this];
  };

  CCSExit.prototype.toString = function() {
    return "1";
  };

  CCSExit.prototype.copy = function() {
    return (new CCSExit())._setCCS(this.ccs);
  };

  return CCSExit;

})(CCSProcess);

CCSProcessApplication = (function(_super) {
  __extends(CCSProcessApplication, _super);

  function CCSProcessApplication(processName, valuesToPass) {
    this.processName = processName;
    this.valuesToPass = valuesToPass != null ? valuesToPass : [];
    CCSProcessApplication.__super__.constructor.call(this);
  }

  CCSProcessApplication.prototype.getArgCount = function() {
    return this.valuesToPass.length;
  };

  CCSProcessApplication.prototype.getProcess = function() {
    var i, id, pd, _i, _ref2;
    if (this.process) {
      return this.process;
    }
    pd = this.ccs.getProcessDefinition(this.processName, this.getArgCount());
    this.process = pd.process.copy();
    if (pd.params) {
      for (i = _i = 0, _ref2 = pd.params.length - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        id = pd.params[i];
        if (pd.types[i] === CCSTypeChannel) {
          this.process.replaceChannelName(id, this.valuesToPass[i].variableName);
        } else {
          this.process.replaceVariable(id, this.valuesToPass[i]);
        }
      }
    }
    return this.process;
  };

  CCSProcessApplication.prototype.getPrecedence = function() {
    return 12;
  };

  CCSProcessApplication.prototype.getTypeOfIdentifier = function(identifier, type) {
    var i, pd, _i, _ref2;
    pd = this.ccs.getProcessDefinition(this.processName, this.getArgCount());
    if (pd.params) {
      for (i = _i = 0, _ref2 = pd.params.length - 1; _i <= _ref2; i = _i += 1) {
        type = this.valuesToPass[i].getTypeOfIdentifier(identifier, type);
        type = CCSGetMostGeneralType(type, pd.types[i]);
      }
    }
    return type;
  };

  CCSProcessApplication.prototype.getApplicapleRules = function() {
    return [CCSRecRule];
  };

  CCSProcessApplication.prototype.getPrefixes = function() {
    return this.getProcess().getPrefixes();
  };

  CCSProcessApplication.prototype.getExits = function() {
    if (this.process) {
      return this.process.getExits();
    } else {
      return [];
    }
  };

  CCSProcessApplication.prototype.replaceVariable = function(varName, exp) {
    var e;
    return this.valuesToPass = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.valuesToPass;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        e = _ref2[_i];
        _results.push(e.replaceVariable(varName, exp));
      }
      return _results;
    }).call(this);
  };

  CCSProcessApplication.prototype.replaceChannelName = function(old, newID) {
    var e, _i, _len, _ref2, _results;
    _ref2 = this.valuesToPass;
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      e = _ref2[_i];
      _results.push(e.replaceChannelName(old, newID));
    }
    return _results;
  };

  /*getProxy: -> 	# ToDo: cache result
  		pd = @ccs.getProcessDefinition(@processName, @getArgCount())
  		new ProcessApplicationProxy(@, pd.process.copy())
  */


  CCSProcessApplication.prototype.toString = function() {
    var e, result;
    result = this.processName;
    if (this.getArgCount() > 0) {
      result += "[" + (((function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.valuesToPass;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          e = _ref2[_i];
          _results.push(e.toString());
        }
        return _results;
      }).call(this)).join(", ")) + "]";
    }
    return result;
  };

  CCSProcessApplication.prototype.copy = function() {
    var v;
    return (new CCSProcessApplication(this.processName, (function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.valuesToPass;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        v = _ref2[_i];
        _results.push(v.copy());
      }
      return _results;
    }).call(this)))._setCCS(this.ccs);
  };

  return CCSProcessApplication;

})(CCSProcess);

CCSPrefix = (function(_super) {
  __extends(CCSPrefix, _super);

  function CCSPrefix(action, process) {
    this.action = action;
    CCSPrefix.__super__.constructor.call(this, process);
  }

  CCSPrefix.prototype.getPrecedence = function() {
    return 12;
  };

  CCSPrefix.prototype.getApplicapleRules = function() {
    return [CCSPrefixRule, CCSOutputRule, CCSInputRule];
  };

  CCSPrefix.prototype.getProcess = function() {
    return this.subprocesses[0];
  };

  CCSPrefix.prototype.replaceVariable = function(varName, exp) {
    if (this.action.replaceVariable(varName, exp)) {
      return CCSPrefix.__super__.replaceVariable.call(this, varName, exp);
    }
  };

  CCSPrefix.prototype.replaceChannelName = function(old, newID) {
    if (this.action.replaceChannelName(old, newID)) {
      return CCSPrefix.__super__.replaceChannelName.call(this, old, newID);
    }
  };

  CCSPrefix.prototype.getPrefixes = function() {
    return [this];
  };

  CCSPrefix.prototype.getTypeOfIdentifier = function(identifier, type) {
    type = this.action.getTypeOfIdentifier(identifier, type);
    if (this.action.isInputAction() && this.action.variable === identifier) {
      CCSPrefix.__super__.getTypeOfIdentifier.call(this, identifier, CCSTypeValue);
      return type;
    } else {
      return CCSPrefix.__super__.getTypeOfIdentifier.call(this, identifier, type);
    }
  };

  CCSPrefix.prototype.toString = function() {
    return "" + (this.action.toString()) + "." + (this.stringForSubprocess(this.getProcess()));
  };

  CCSPrefix.prototype.copy = function() {
    return (new CCSPrefix(this.action.copy(), this.getProcess().copy()))._setCCS(this.ccs);
  };

  return CCSPrefix;

})(CCSProcess);

CCSCondition = (function(_super) {
  __extends(CCSCondition, _super);

  function CCSCondition(expression, process) {
    this.expression = expression;
    CCSCondition.__super__.constructor.call(this, process);
  }

  CCSCondition.prototype.getPrecedence = function() {
    return 12;
  };

  CCSCondition.prototype.getApplicapleRules = function() {
    return [CCSCondRule];
  };

  CCSCondition.prototype.getProcess = function() {
    return this.subprocesses[0];
  };

  CCSCondition.prototype.getTypeOfIdentifier = function(identifier, type) {
    type = this.expression.getTypeOfIdentifier(identifier, type);
    return CCSCondition.__super__.getTypeOfIdentifier.call(this, identifier, type);
  };

  CCSCondition.prototype.replaceVariable = function(varName, exp) {
    this.expression = this.expression.replaceVariable(varName, exp);
    return CCSCondition.__super__.replaceVariable.call(this, varName, exp);
  };

  CCSCondition.prototype.toString = function() {
    return "when (" + (this.expression.toString()) + ") " + (this.stringForSubprocess(this.getProcess()));
  };

  CCSCondition.prototype.copy = function() {
    return (new CCSCondition(this.expression.copy(), this.getProcess().copy()))._setCCS(this.ccs);
  };

  return CCSCondition;

})(CCSProcess);

CCSChoice = (function(_super) {
  __extends(CCSChoice, _super);

  function CCSChoice(left, right) {
    CCSChoice.__super__.constructor.call(this, left, right);
  }

  CCSChoice.prototype.getPrecedence = function() {
    return 9;
  };

  CCSChoice.prototype.getApplicapleRules = function() {
    return [CCSChoiceLRule, CCSChoiceRRule];
  };

  CCSChoice.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getLeft())) + " + " + (this.stringForSubprocess(this.getRight()));
  };

  CCSChoice.prototype.copy = function() {
    return (new CCSChoice(this.getLeft().copy(), this.getRight().copy()))._setCCS(this.ccs);
  };

  return CCSChoice;

})(CCSProcess);

CCSParallel = (function(_super) {
  __extends(CCSParallel, _super);

  function CCSParallel(left, right) {
    CCSParallel.__super__.constructor.call(this, left, right);
  }

  CCSParallel.prototype.getPrecedence = function() {
    return 6;
  };

  CCSParallel.prototype.getApplicapleRules = function() {
    return [CCSParLRule, CCSParRRule, CCSSyncRule, CCSSyncExitRule];
  };

  CCSParallel.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getLeft())) + " | " + (this.stringForSubprocess(this.getRight()));
  };

  CCSParallel.prototype.copy = function() {
    return (new CCSParallel(this.getLeft().copy(), this.getRight().copy()))._setCCS(this.ccs);
  };

  return CCSParallel;

})(CCSProcess);

CCSSequence = (function(_super) {
  __extends(CCSSequence, _super);

  function CCSSequence(left, right) {
    CCSSequence.__super__.constructor.call(this, left, right);
  }

  CCSSequence.prototype.getPrecedence = function() {
    return 3;
  };

  CCSSequence.prototype.getApplicapleRules = function() {
    return [CCSSeq1Rule, CCSSeq2Rule];
  };

  CCSSequence.prototype.getPrefixes = function() {
    return this.getLeft().getPrefixes();
  };

  CCSSequence.prototype.getExits = function() {
    return this.getLeft().getExits();
  };

  CCSSequence.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getLeft())) + " ; " + (this.stringForSubprocess(this.getRight()));
  };

  CCSSequence.prototype.copy = function() {
    return (new CCSSequence(this.getLeft().copy(), this.getRight().copy()))._setCCS(this.ccs);
  };

  return CCSSequence;

})(CCSProcess);

CCSRestriction = (function(_super) {
  __extends(CCSRestriction, _super);

  function CCSRestriction(process, restrictedChannels) {
    this.restrictedChannels = restrictedChannels;
    CCSRestriction.__super__.constructor.call(this, process);
  }

  CCSRestriction.prototype.getPrecedence = function() {
    return 1;
  };

  CCSRestriction.prototype.getApplicapleRules = function() {
    return [CCSResRule];
  };

  CCSRestriction.prototype.getProcess = function() {
    return this.subprocesses[0];
  };

  CCSRestriction.prototype.setProcess = function(process) {
    return this.subprocesses[0] = process;
  };

  CCSRestriction.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getProcess())) + " \\ {" + (this.restrictedChannels.join(", ")) + "}";
  };

  CCSRestriction.prototype.copy = function() {
    return (new CCSRestriction(this.getProcess().copy(), this.restrictedChannels))._setCCS(this.ccs);
  };

  return CCSRestriction;

})(CCSProcess);

CCSChannel = (function() {
  function CCSChannel(name, expression) {
    this.name = name;
    this.expression = expression != null ? expression : null;
  }

  CCSChannel.prototype.isEqual = function(channel) {
    if (channel.name !== this.name) {
      return false;
    }
    if (!channel.expression && !this.expression) {
      return true;
    }
    if (!channel.expression || !this.expression) {
      return false;
    }
    return channel.expression.evaluate() === this.expression.evaluate();
  };

  CCSChannel.prototype.replaceVariable = function(varName, exp) {
    if (this.expression) {
      this.expression = this.expression.replaceVariable(varName, exp);
    }
    return null;
  };

  CCSChannel.prototype.replaceChannelName = function(old, newID) {
    if (this.name === old) {
      this.name = newID;
    }
    return null;
  };

  CCSChannel.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this.name === identifier) {
      type = CCSGetMostGeneralType(type, CCSTypeChannel);
    }
    if (this.expression) {
      type = this.expression.getTypeOfIdentifier(identifier, type);
    }
    return type;
  };

  CCSChannel.prototype.toString = function() {
    var result;
    result = "" + this.name;
    if (this.expression) {
      if (this.expression.isEvaluatable()) {
        result += "(" + (this.expression.evaluate()) + ")";
      } else {
        result += "(" + (this.expression.toString()) + ")";
      }
    }
    return result;
  };

  CCSChannel.prototype.copy = function() {
    var _ref2;
    return new CCSChannel(this.name, (_ref2 = this.expression) != null ? _ref2.copy() : void 0);
  };

  return CCSChannel;

})();

/*
class CCSInternalChannel extends CCSChannel
	constructor: (name) ->
		if name != CCSInternalChannel or name != CCSExitChannel
			throw new Error("Only internal channel names are allowed!")
		super name, null
	isEqual: (channel) -> channel.name == @name and channel.expression == null
	replaceVariable: (varName, exp) -> null
	replaceChannelName: (old, newID) -> null
	getTypeOfIdentifier: (identifier, type) -> type
	toString: -> @name
*/


CCSAction = (function() {
  function CCSAction(channel) {
    this.channel = channel;
    if (this.channel === "i") {
      if (!this.isSimpleAction()) {
        throw new Error("Internal channel i is only allowed as simple action!");
      }
      this.channel = CCSInternalChannel;
    } else if (this.channel === "e") {
      if (!this.isSimpleAction()) {
        throw new Error("Exit channel e is only allowed as simple action!");
      }
      this.channel = CCSExitChannel;
    }
  }

  CCSAction.prototype.isSimpleAction = function() {
    return false;
  };

  CCSAction.prototype.isInputAction = function() {
    return false;
  };

  CCSAction.prototype.isMatchAction = function() {
    return false;
  };

  CCSAction.prototype.isOutputAction = function() {
    return false;
  };

  CCSAction.prototype.toString = function() {
    return this.channel.toString();
  };

  CCSAction.prototype.transferDescription = function() {
    return this.channel.toString();
  };

  CCSAction.prototype.isSyncableWithAction = function(action) {
    return false;
  };

  CCSAction.prototype.replaceVariable = function(varName, exp) {
    this.channel.replaceVariable(varName, exp);
    return true;
  };

  CCSAction.prototype.replaceChannelName = function(old, newID) {
    return this.channel.replaceChannelName(old, newID);
  };

  CCSAction.prototype.getTypeOfIdentifier = function(identifier, type) {
    return this.channel.getTypeOfIdentifier(identifier, type);
  };

  return CCSAction;

})();

CCSSimpleAction = (function(_super) {
  __extends(CCSSimpleAction, _super);

  function CCSSimpleAction() {
    _ref2 = CCSSimpleAction.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  CCSSimpleAction.prototype.isSimpleAction = function() {
    return true;
  };

  CCSSimpleAction.prototype.supportsValuePassing = function() {
    return false;
  };

  CCSSimpleAction.prototype.copy = function() {
    return new CCSSimpleAction(this.channel.copy());
  };

  return CCSSimpleAction;

})(CCSAction);

CCSInternalActionCreate = function(name) {
  if (name !== CCSInternalChannel && name !== CCSExitChannel) {
    throw new Error("Only internal channel names are allowed!");
  }
  return new CCSSimpleAction(new CCSChannel(name, null));
};

CCSInput = (function(_super) {
  __extends(CCSInput, _super);

  function CCSInput(channel, variable, range) {
    this.variable = variable;
    this.range = range;
    CCSInput.__super__.constructor.call(this, channel);
  }

  CCSInput.prototype.isInputAction = function() {
    return true;
  };

  CCSInput.prototype.supportsValuePassing = function() {
    return typeof this.variable === "string" && this.variable.length > 0;
  };

  CCSInput.prototype.isSyncableWithAction = function(action) {
    return (action != null ? action.isOutputAction() : void 0) && action.channel.isEqual(this.channel) && action.supportsValuePassing() === this.supportsValuePassing();
  };

  CCSInput.prototype.replaceVariable = function(varName, exp) {
    CCSInput.__super__.replaceVariable.call(this, varName, exp);
    return this.variable !== varName;
  };

  CCSInput.prototype.toString = function() {
    return "" + CCSInput.__super__.toString.apply(this, arguments) + "?" + (this.supportsValuePassing() ? this.variable : "");
  };

  CCSInput.prototype.transferDescription = function(inputValue) {
    if (this.supportsValuePassing() && (inputValue === null || inputValue === void 0)) {
      throw new Error("CCSInput.transferDescription needs an input value as argument if it supports value passing!");
    }
    return "" + CCSInput.__super__.transferDescription.apply(this, arguments) + (this.supportsValuePassing() ? ": " + inputValue : "");
  };

  CCSInput.prototype.copy = function() {
    return new CCSInput(this.channel.copy(), this.variable, this.range);
  };

  return CCSInput;

})(CCSAction);

CCSMatch = (function(_super) {
  __extends(CCSMatch, _super);

  function CCSMatch(channel, expression) {
    this.expression = expression;
    CCSMatch.__super__.constructor.call(this, channel);
  }

  CCSMatch.prototype.isMatchAction = function() {
    return true;
  };

  CCSMatch.prototype.supportsValuePassing = function() {
    return true;
  };

  CCSMatch.prototype.isSyncableWithAction = function(action) {
    return (action != null ? action.isOutputAction() : void 0) && action.channel.isEqual(this.channel) && action.supportsValuePassing() && action.expression.evaluate() === this.expression.evaluate();
  };

  CCSMatch.prototype.replaceVariable = function(varName, exp) {
    CCSMatch.__super__.replaceVariable.call(this, varName, exp);
    this.expression = this.expression.replaceVariable(varName, exp);
    return true;
  };

  CCSMatch.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this.expression) {
      type = this.expression.getTypeOfIdentifier(identifier, type);
    }
    return CCSMatch.__super__.getTypeOfIdentifier.call(this, identifier, type);
  };

  CCSMatch.prototype.toString = function() {
    return "" + CCSMatch.__super__.toString.apply(this, arguments) + "?=" + (this.expression ? this.expression.toString() : "");
  };

  CCSMatch.prototype.transferDescription = function() {
    throw new Error("Currently unsupported action");
  };

  CCSMatch.prototype.copy = function() {
    var _ref3;
    return new CCSMatch(this.channel.copy(), (_ref3 = this.expression) != null ? _ref3.copy() : void 0);
  };

  return CCSMatch;

})(CCSAction);

CCSOutput = (function(_super) {
  __extends(CCSOutput, _super);

  function CCSOutput(channel, expression) {
    this.expression = expression;
    CCSOutput.__super__.constructor.call(this, channel);
  }

  CCSOutput.prototype.isOutputAction = function() {
    return true;
  };

  CCSOutput.prototype.supportsValuePassing = function() {
    return this.expression instanceof CCSExpression;
  };

  CCSOutput.prototype.isSyncableWithAction = function(action) {
    if ((action != null ? action.isInputAction() : void 0) || action.isMatchAction()) {
      return action.isSyncableWithAction(this);
    } else {
      return false;
    }
  };

  CCSOutput.prototype.replaceVariable = function(varName, exp) {
    CCSOutput.__super__.replaceVariable.call(this, varName, exp);
    if (this.expression) {
      this.expression = this.expression.replaceVariable(varName, exp);
    }
    return true;
  };

  CCSOutput.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this.expression) {
      type = this.expression.getTypeOfIdentifier(identifier, type);
    }
    return CCSOutput.__super__.getTypeOfIdentifier.call(this, identifier, type);
  };

  CCSOutput.prototype.toString = function() {
    return "" + CCSOutput.__super__.toString.apply(this, arguments) + "!" + (this.expression ? this.expression.toString() : "");
  };

  CCSOutput.prototype.transferDescription = function() {
    return "" + CCSOutput.__super__.transferDescription.apply(this, arguments) + (this.expression ? ": " + this.expression.evaluate() : "");
  };

  CCSOutput.prototype.copy = function() {
    var _ref3;
    return new CCSOutput(this.channel.copy(), (_ref3 = this.expression) != null ? _ref3.copy() : void 0);
  };

  return CCSOutput;

})(CCSAction);

CCSExpression = (function() {
  function CCSExpression() {
    var subExps;
    subExps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.subExps = subExps;
  }

  CCSExpression.prototype.getLeft = function() {
    return this.subExps[0];
  };

  CCSExpression.prototype.getRight = function() {
    return this.subExps[1];
  };

  CCSExpression.prototype.replaceVariable = function(varName, exp) {
    var e;
    this.subExps = (function() {
      var _i, _len, _ref3, _results;
      _ref3 = this.subExps;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        e = _ref3[_i];
        _results.push(e.replaceVariable(varName, exp));
      }
      return _results;
    }).call(this);
    return this;
  };

  CCSExpression.prototype.replaceChannelName = function(old, newID) {
    return null;
  };

  CCSExpression.prototype.usesIdentifier = function(identifier) {
    return this._childrenUseIdentifier(identifier);
  };

  CCSExpression.prototype._childrenUseIdentifier = function(identifier) {
    var e, result, _i, _len, _ref3;
    result = false;
    _ref3 = this.subExps;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      e = _ref3[_i];
      result || e.usesIdentifier();
    }
    return result;
  };

  CCSExpression.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this._childrenUseIdentifier(identifier)) {
      type = CCSGetMostGeneralType(type, CCSTypeValue);
    }
    return type;
  };

  CCSExpression.prototype.evaluate = function() {
    throw new Error("Abstract method!");
  };

  CCSExpression.prototype.isEvaluatable = function() {
    return false;
  };

  CCSExpression.prototype.typeOfEvaluation = function() {
    throw new Error("Abstract method!");
  };

  CCSExpression.prototype.needsBracketsForSubExp = function(exp) {
    return (this.getPrecedence != null) && (exp.getPrecedence != null) && exp.getPrecedence() < this.getPrecedence();
  };

  CCSExpression.prototype.stringForSubExp = function(exp) {
    if (this.needsBracketsForSubExp(exp)) {
      return "(" + (exp.toString()) + ")";
    } else {
      return "" + (exp.toString());
    }
  };

  CCSExpression.prototype.toString = function() {
    throw new Error("Abstract method not implemented!");
  };

  CCSExpression.prototype.copy = function() {
    throw new Error("Abstract method not implemented!");
  };

  return CCSExpression;

})();

CCSConstantExpression = (function(_super) {
  __extends(CCSConstantExpression, _super);

  function CCSConstantExpression(value) {
    this.value = value;
    CCSConstantExpression.__super__.constructor.call(this);
  }

  CCSConstantExpression.prototype.getPrecedence = function() {
    return 18;
  };

  CCSConstantExpression.prototype.evaluate = function() {
    return CCSConstantExpression.valueToString(this.value);
  };

  CCSConstantExpression.prototype.isEvaluatable = function() {
    return true;
  };

  CCSConstantExpression.prototype.typeOfEvaluation = function() {
    return typeof this.value;
  };

  CCSConstantExpression.prototype.toString = function() {
    if (typeof this.value === "string") {
      return '"' + this.value + '"';
    } else {
      return "" + this.value;
    }
  };

  CCSConstantExpression.prototype.copy = function() {
    return new CCSConstantExpression(this.value);
  };

  return CCSConstantExpression;

})(CCSExpression);

CCSConstantExpression.valueToString = function(value) {
  if (typeof value === "boolean") {
    value = (value === true ? "1" : "0");
  }
  return value = "" + value;
};

CCSVariableExpression = (function(_super) {
  __extends(CCSVariableExpression, _super);

  function CCSVariableExpression(variableName) {
    this.variableName = variableName;
    CCSVariableExpression.__super__.constructor.call(this);
  }

  CCSVariableExpression.prototype.getPrecedence = function() {
    return 18;
  };

  CCSVariableExpression.prototype.usesIdentifier = function(identifier) {
    return identifier === this.variableName;
  };

  CCSVariableExpression.prototype.replaceVariable = function(varName, exp) {
    if (varName === this.variableName) {
      return exp;
    } else {
      return this;
    }
  };

  CCSVariableExpression.prototype.replaceChannelName = function(old, newID) {
    if (this.variableName === old) {
      return this.variableName = newID;
    }
  };

  CCSVariableExpression.prototype.evaluate = function() {
    throw new Error('Unbound identifier!');
  };

  CCSVariableExpression.prototype.typeOfEvaluation = function() {
    throw new Error('Unbound identifier!');
  };

  CCSVariableExpression.prototype.isEvaluatable = function() {
    return false;
  };

  CCSVariableExpression.prototype.toString = function() {
    return this.variableName;
  };

  CCSVariableExpression.prototype.copy = function() {
    return new CCSVariableExpression(this.variableName);
  };

  return CCSVariableExpression;

})(CCSExpression);

CCSAdditiveExpression = (function(_super) {
  __extends(CCSAdditiveExpression, _super);

  function CCSAdditiveExpression(left, right, op) {
    this.op = op;
    CCSAdditiveExpression.__super__.constructor.call(this, left, right);
  }

  CCSAdditiveExpression.prototype.getPrecedence = function() {
    return 15;
  };

  CCSAdditiveExpression.prototype.evaluate = function() {
    var l, r;
    l = parseInt(this.getLeft().evaluate());
    r = parseInt(this.getRight().evaluate());
    return "" + ((function() {
      if (this.op === "+") {
        return l + r;
      } else if (this.op === "-") {
        return l - r;
      } else {
        throw new Error("Invalid operator!");
      }
    }).call(this));
  };

  CCSAdditiveExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSAdditiveExpression.prototype.typeOfEvaluation = function() {
    return "number";
  };

  CCSAdditiveExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSAdditiveExpression.prototype.copy = function() {
    return new CCSAdditiveExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSAdditiveExpression;

})(CCSExpression);

CCSMultiplicativeExpression = (function(_super) {
  __extends(CCSMultiplicativeExpression, _super);

  function CCSMultiplicativeExpression(left, right, op) {
    this.op = op;
    CCSMultiplicativeExpression.__super__.constructor.call(this, left, right);
  }

  CCSMultiplicativeExpression.prototype.getPrecedence = function() {
    return 12;
  };

  CCSMultiplicativeExpression.prototype.evaluate = function() {
    var l, r;
    l = parseInt(this.getLeft().evaluate());
    r = parseInt(this.getRight().evaluate());
    if (this.op === "*") {
      return l * r;
    } else if (this.op === "/") {
      return Math.floor(l / r);
    } else {
      throw new Error("Invalid operator!");
    }
  };

  CCSMultiplicativeExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSMultiplicativeExpression.prototype.typeOfEvaluation = function() {
    return "number";
  };

  CCSMultiplicativeExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSMultiplicativeExpression.prototype.copy = function() {
    return new CCSMultiplicativeExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSMultiplicativeExpression;

})(CCSExpression);

CCSConcatenatingExpression = (function(_super) {
  __extends(CCSConcatenatingExpression, _super);

  function CCSConcatenatingExpression(left, right) {
    CCSConcatenatingExpression.__super__.constructor.call(this, left, right);
  }

  CCSConcatenatingExpression.prototype.getPrecedence = function() {
    return 9;
  };

  CCSConcatenatingExpression.prototype.evaluate = function() {
    return "" + this.getLeft().evaluate() + this.getRight().evaluate();
  };

  CCSConcatenatingExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSConcatenatingExpression.prototype.typeOfEvaluation = function() {
    return "string";
  };

  CCSConcatenatingExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + "^" + this.stringForSubExp(this.getRight());
  };

  CCSConcatenatingExpression.prototype.copy = function() {
    return new CCSConcatenatingExpression(this.getLeft().copy(), this.getRight().copy());
  };

  return CCSConcatenatingExpression;

})(CCSExpression);

CCSRelationalExpression = (function(_super) {
  __extends(CCSRelationalExpression, _super);

  function CCSRelationalExpression(left, right, op) {
    this.op = op;
    CCSRelationalExpression.__super__.constructor.call(this, left, right);
  }

  CCSRelationalExpression.prototype.getPrecedence = function() {
    return 6;
  };

  CCSRelationalExpression.prototype.evaluate = function() {
    var l, r, res;
    l = parseInt(this.getLeft().evaluate());
    r = parseInt(this.getRight().evaluate());
    res = (function() {
      if (this.op === "<") {
        return l < r;
      } else if (this.op === "<=") {
        return l <= r;
      } else if (this.op === ">") {
        return l > r;
      } else if (this.op === ">=") {
        return l >= r;
      } else {
        throw new Error("Invalid operator!");
      }
    }).call(this);
    return CCSConstantExpression.valueToString(res);
  };

  CCSRelationalExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSRelationalExpression.prototype.typeOfEvaluation = function() {
    return "boolean";
  };

  CCSRelationalExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSRelationalExpression.prototype.copy = function() {
    return new CCSRelationalExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSRelationalExpression;

})(CCSExpression);

CCSEqualityExpression = (function(_super) {
  __extends(CCSEqualityExpression, _super);

  function CCSEqualityExpression(left, right, op) {
    this.op = op;
    CCSEqualityExpression.__super__.constructor.call(this, left, right);
  }

  CCSEqualityExpression.prototype.getPrecedence = function() {
    return 3;
  };

  CCSEqualityExpression.prototype.evaluate = function() {
    var l, r, res;
    l = this.getLeft().evaluate();
    r = this.getRight().evaluate();
    res = (function() {
      if (this.op === "==") {
        return l === r;
      } else if (this.op === "!=") {
        return l !== r;
      } else {
        throw new Error("Invalid operator!");
      }
    }).call(this);
    return CCSConstantExpression.valueToString(res);
  };

  CCSEqualityExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSEqualityExpression.prototype.typeOfEvaluation = function() {
    return "boolean";
  };

  CCSEqualityExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSEqualityExpression.prototype.copy = function() {
    return new CCSEqualityExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSEqualityExpression;

})(CCSExpression);

ActionSets = {
  isActionInK: function(action) {
    return ActionSets.isActionInCom(action) && action.isSimpleAction();
  },
  isActionInCom: function(action) {
    return ActionSets.isActionInAct(action) && action.channel.name !== CCSInternalChannel;
  },
  isActionInAct: function(action) {
    return ActionSets.isActionInActPlus(action) && action.channel.name !== CCSExitChannel;
  },
  isActionInActPlus: function(action) {
    return !action.supportsValuePassing();
  },
  isActionInComVP: function(action) {
    return ActionSets.isActionInActVP(action) && action.channel.name !== CCSInternalChannel;
  },
  isActionInActVP: function(action) {
    return action.channel.name !== CCSExitChannel;
  },
  isActionInActVPPlus: function(action) {
    return true;
  }
};

Array.prototype.filterKSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInK(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterComSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInCom(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInAct(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActPlusSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInActPlus(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterComVPSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInComVP(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActVPSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInActVP(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActVPPlusSteps = function() {
  return this;
};

String.prototype.replaceAll = function(needle, replacement) {
	var t = this
	var tt = this
	do {
		t = tt;
		tt = t.replace(needle, replacement);
	} while (t != tt);
	return t;
}

Array.prototype.concatChildren = function() {
	if (this.length == 0)
		return [];
	var target = this.concat([]);	// Copy
	var result = target.shift().concat([]);	// Result should always be a copy
	while (target.length > 0) {
		result = result.concat(target.shift());
	}
	return result;
}

Array.prototype.joinChildren = function(separator) {
	var result = [];
	var i = 0;
	while(true) {
		var joinTarget = [];
		for (var c = 0; c < this.length; c++) {
			if (this[c][i]) joinTarget.push(this[c][i]);
		}
		if (joinTarget.length == 0)
			break;
		result[i++] = joinTarget.join(separator);
	}
	return result;
};

Array.prototype.assertNonNull = function() {
  var e, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = this.length; _i < _len; _i++) {
    e = this[_i];
    _results.push((function() {
      if (typeof e === "undefined" || e === null) {
        throw new Error("Null element found!");
      }
    })());
  }
  return _results;
};

CCSProcess.prototype.findApp = function(name) {
  var c;
  return ((function() {
    var _i, _len, _ref3, _results;
    _ref3 = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      c = _ref3[_i];
      _results.push(c.findApp(name));
    }
    return _results;
  }).call(this)).joinChildren();
};

CCSProcessApplication.prototype.findApp = function(name) {
  debugger;
  if (name === this.processName) {
    return [this];
  } else {
    return [];
  }
};

CCSPrefix.prototype.findApp = function() {
  return [];
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


CCSStep = (function() {
  function CCSStep() {
    var action, actionDetails, copyOnPerform, index, process, rule, s, substeps, _i, _len, _ref3;
    index = arguments[0], process = arguments[1], action = arguments[2], rule = arguments[3], copyOnPerform = arguments[4], actionDetails = arguments[5], substeps = 7 <= arguments.length ? __slice.call(arguments, 6) : [];
    this.index = index;
    this.process = process;
    this.action = action;
    this.rule = rule;
    this.copyOnPerform = copyOnPerform;
    this.actionDetails = actionDetails;
    this.substeps = substeps;
    _ref3 = this.substeps;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      s = _ref3[_i];
      if (s === void 0 || s === null) {
        throw "substep must not be nil!";
      }
    }
    if (!this.actionDetails) {
      this.actionDetails = this.substeps.length === 1 ? this.substeps[0].actionDetails : "";
    }
  }

  CCSStep.prototype.getLeafProcesses = function() {
    var step;
    if (this.substeps.length === 0) {
      return [this.process];
    } else {
      return ((function() {
        var _i, _len, _ref3, _results;
        _ref3 = this.substeps;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          step = _ref3[_i];
          _results.push(step.getLeafProcesses());
        }
        return _results;
      }).call(this)).concatChildren();
    }
  };

  CCSStep.prototype.perform = function() {
    return this.rule.performStep(this);
  };

  CCSStep.prototype.toString = function() {
    return this.action.toString() + (this.actionDetails.length > 0 ? " " + this.actionDetails : "");
  };

  CCSStep.prototype._getMutableProcess = function() {
    if (this.copyOnPerform) {
      return this.process.copy();
    } else {
      return this.process;
    }
  };

  return CCSStep;

})();

CCSBaseStep = (function(_super) {
  __extends(CCSBaseStep, _super);

  function CCSBaseStep(prefix, rule, copyOnPerform) {
    CCSBaseStep.__super__.constructor.call(this, 0, prefix, prefix.action, rule, copyOnPerform);
  }

  return CCSBaseStep;

})(CCSStep);

CCSInputStep = (function(_super) {
  __extends(CCSInputStep, _super);

  function CCSInputStep() {
    _ref3 = CCSInputStep.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  CCSInputStep.prototype.performWithInputValue = function(inputValue) {
    return this.rule.performStep(this, inputValue);
  };

  CCSInputStep.prototype.perform = function() {
    throw new Error("perform is not supported on input steps! Use performWithInputValue with an input value as argument instead!");
  };

  return CCSInputStep;

})(CCSBaseStep);

CCSBaseStep.prototype.performWithInputValue = function() {
  throw new Error("performWithInputValue is only allowed for input steps!");
};

CCSStep.prototype.performWithInputValue = function(inputValue) {
  if (this.substeps.length !== 1) {
    throw new Error("Forwarding of performWithInputValue only supported for linear step tree!");
  }
  return this.substeps[0].performWithInputValue(inputValue);
};

CCSPrefixRule = {
  getPossibleSteps: function(prefix, copyOnPerform) {
    if ((prefix != null ? prefix.action.isSimpleAction() : void 0) || !prefix.action.supportsValuePassing()) {
      return [new CCSBaseStep(prefix, this, copyOnPerform)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.process.getProcess();
  }
};

CCSOutputRule = {
  getPossibleSteps: function(prefix, copyOnPerform) {
    if ((prefix != null ? prefix.action.isOutputAction() : void 0) && prefix.action.supportsValuePassing()) {
      return [new CCSBaseStep(prefix, this, copyOnPerform)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.process.getProcess();
  }
};

CCSInputRule = {
  getPossibleSteps: function(prefix, copyOnPerform) {
    if ((prefix != null ? prefix.action.isInputAction() : void 0) && prefix.action.supportsValuePassing()) {
      return [new CCSInputStep(prefix, this, copyOnPerform)];
    } else {
      return [];
    }
  },
  performStep: function(step, inputValue) {
    var result;
    if (!inputValue) {
      throw new Error("Input value was not set!");
    }
    result = step._getMutableProcess().getProcess();
    result.replaceVariableWithValue(step.process.action.variable, inputValue);
    return result;
  }
};

CCSMatchRule = {
  getPossibleSteps: function(prefix, copyOnPerform) {
    if (prefix != null ? prefix.action.isMatchAction() : void 0) {
      return [new CCSBaseStep(prefix, this, copyOnPerform)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.process.getProcess();
  }
};

CCSChoiceLRule = {
  getPossibleSteps: function(choice, copyOnPerform) {
    var i, step, _i, _len, _ref4, _results;
    i = 0;
    _ref4 = choice.getLeft().getPossibleSteps(copyOnPerform).filterActVPPlusSteps();
    _results = [];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      step = _ref4[_i];
      _results.push(new CCSStep(i++, choice, step.action, this, copyOnPerform, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

CCSChoiceRRule = {
  getPossibleSteps: function(choice, copyOnPerform) {
    var i, step, _i, _len, _ref4, _results;
    i = 0;
    _ref4 = choice.getRight().getPossibleSteps(copyOnPerform).filterActVPPlusSteps();
    _results = [];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      step = _ref4[_i];
      _results.push(new CCSStep(i++, choice, step.action, this, copyOnPerform, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

CCSParLRule = {
  getPossibleSteps: function(parallel, copyOnPerform) {
    var i, step;
    if (!parallel._CCSParLRule) {
      i = 0;
      parallel._CCSParLRule = (function() {
        var _i, _len, _ref4, _results;
        _ref4 = parallel.getLeft().getPossibleSteps(copyOnPerform).filterActVPSteps();
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          step = _ref4[_i];
          _results.push(new CCSStep(i++, parallel, step.action, this, copyOnPerform, null, step));
        }
        return _results;
      }).call(this);
    }
    return parallel._CCSParLRule;
  },
  performStep: function(step) {
    var res;
    res = step._getMutableProcess();
    res._CCSSyncRule = void 0;
    res._CCSParRRule = void 0;
    res._CCSParLRule = void 0;
    res.setLeft(step.substeps[0].perform());
    return res;
  }
};

CCSParRRule = {
  getPossibleSteps: function(parallel, copyOnPerform) {
    var i, step;
    if (!parallel._CCSParRRule) {
      i = 0;
      parallel._CCSParRRule = (function() {
        var _i, _len, _ref4, _results;
        _ref4 = parallel.getRight().getPossibleSteps(copyOnPerform).filterActVPSteps();
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          step = _ref4[_i];
          _results.push(new CCSStep(i++, parallel, step.action, this, copyOnPerform, null, step));
        }
        return _results;
      }).call(this);
    }
    return parallel._CCSParRRule;
  },
  performStep: function(step) {
    var res;
    res = step._getMutableProcess();
    res._CCSSyncRule = void 0;
    res._CCSParRRule = void 0;
    res._CCSParLRule = void 0;
    res.setRight(step.substeps[0].perform());
    return res;
  }
};

CCSSyncRule = {
  filterStepsSyncableWithStep: function(step, steps) {
    var result, s, _i, _len;
    result = [];
    for (_i = 0, _len = steps.length; _i < _len; _i++) {
      s = steps[_i];
      if (s.action.isSyncableWithAction(step.action)) {
        result.push(s);
      }
    }
    return result;
  },
  getPossibleSteps: function(parallel, copyOnPerform) {
    var c, l, left, r, result, right, _i, _j, _len, _len1, _right;
    if (!parallel._CCSSyncRule) {
      left = parallel.getLeft().getPossibleSteps(copyOnPerform);
      right = parallel.getRight().getPossibleSteps(copyOnPerform);
      result = [];
      c = 0;
      for (_i = 0, _len = left.length; _i < _len; _i++) {
        l = left[_i];
        _right = CCSSyncRule.filterStepsSyncableWithStep(l, right);
        for (_j = 0, _len1 = _right.length; _j < _len1; _j++) {
          r = _right[_j];
          result.push(new CCSStep(c++, parallel, new CCSInternalActionCreate(CCSInternalChannel), this, copyOnPerform, "" + (l.action.isOutputAction() ? l.action.transferDescription() : r.action.transferDescription()), l, r));
        }
      }
      parallel._CCSSyncRule = result;
    }
    return parallel._CCSSyncRule;
  },
  performStep: function(step) {
    var inp, left, out, prefix, res, right;
    res = step._getMutableProcess();
    res._CCSSyncRule = void 0;
    res._CCSParRRule = void 0;
    res._CCSParLRule = void 0;
    inp = null;
    out = null;
    left = null;
    right = null;
    prefix = step.substeps[0].getLeafProcesses()[0];
    if (prefix.action.supportsValuePassing()) {
      if (prefix.action.isInputAction()) {
        inp = prefix;
        out = step.substeps[1].getLeafProcesses()[0];
        left = step.substeps[0].performWithInputValue(out.action.expression.evaluate());
        right = step.substeps[1].perform();
      } else {
        out = prefix;
        inp = step.substeps[1].getLeafProcesses()[0];
        left = step.substeps[0].perform();
        right = step.substeps[1].performWithInputValue(out.action.expression.evaluate());
      }
    } else {
      left = step.substeps[0].perform();
      right = step.substeps[1].perform();
    }
    res.setLeft(left);
    res.setRight(right);
    return res;
  }
};

CCSResRule = {
  shouldRestrictChannel: function(chan, restr) {
    if (chan === CCSInternalChannel || chan === CCSExitChannel) {
      return false;
    }
    if (restr.length === 0) {
      return false;
    }
    if (restr[0] === "*") {
      return restr.indexOf(chan) === -1;
    } else {
      return restr.indexOf(chan) !== -1;
    }
  },
  getPossibleSteps: function(restriction, copyOnPerform) {
    var c, result, step, steps, _i, _len;
    steps = restriction.getProcess().getPossibleSteps(copyOnPerform).filterActVPPlusSteps();
    result = [];
    c = 0;
    for (_i = 0, _len = steps.length; _i < _len; _i++) {
      step = steps[_i];
      if (!this.shouldRestrictChannel(step.action.channel.name, restriction.restrictedChannels)) {
        result.push(new CCSStep(c++, restriction, step.action, this, copyOnPerform, null, step));
      }
    }
    return result;
  },
  performStep: function(step) {
    var res;
    res = step._getMutableProcess();
    res.setProcess(step.substeps[0].perform());
    return res;
  }
};

CCSCondRule = {
  getPossibleSteps: function(condition, copyOnPerform) {
    if (CCSCondRule.DEBUGGER) {
      debugger;
    }
    if (condition.expression.evaluate() === "1") {
      return condition.getProcess().getPossibleSteps(copyOnPerform).filterActVPPlusSteps();
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

CCSExitRule = {
  getPossibleSteps: function(exit, copyOnPerform) {
    return [new CCSStep(0, exit, new CCSInternalActionCreate(CCSExitChannel), this, copyOnPerform)];
  },
  performStep: function(step) {
    return new CCSStop();
  }
};

CCSSyncExitRule = {
  getPossibleSteps: function(parallel, copyOnPerform) {
    var c, filter, l, left, r, result, right, _i, _j, _len, _len1;
    filter = function(step) {
      return step.action.channel.name === CCSExitChannel;
    };
    left = parallel.getLeft().getPossibleSteps(copyOnPerform).filter(filter);
    right = parallel.getRight().getPossibleSteps(copyOnPerform).filter(filter);
    c = 0;
    result = [];
    for (_i = 0, _len = left.length; _i < _len; _i++) {
      l = left[_i];
      for (_j = 0, _len1 = right.length; _j < _len1; _j++) {
        r = right[_j];
        result.push(new CCSStep(c++, parallel, CCSInternalActionCreate(CCSExitChannel), this, copyOnPerform, "" + (l.action.isOutput() ? l.action.transferDescription() : r.action.transferDescription()), l, r));
      }
    }
    return result;
  },
  performStep: function(step) {
    return CCSSyncRule.performStep(step);
  }
};

CCSSeq1Rule = {
  getPossibleSteps: function(sequence, copyOnPerform) {
    var c, step, _i, _len, _ref4, _results;
    c = 0;
    _ref4 = sequence.getLeft().getPossibleSteps(copyOnPerform).filterActVPSteps();
    _results = [];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      step = _ref4[_i];
      _results.push(new CCSStep(c++, sequence, step.action, this, copyOnPerform, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    var res;
    res = step._getMutableProcess();
    res.setLeft(step.substeps[0].perform());
    return res;
  }
};

CCSSeq2Rule = {
  getPossibleSteps: function(sequence, copyOnPerform) {
    var c, filter, result, rho, rhos, _i, _len;
    filter = function(step) {
      return step.action.channel.name === CCSExitChannel;
    };
    rhos = sequence.getLeft().getPossibleSteps(copyOnPerform).filter(filter);
    result = [];
    c = 0;
    for (_i = 0, _len = rhos.length; _i < _len; _i++) {
      rho = rhos[_i];
      result.push(new CCSStep(c++, sequence, new CCSInternalActionCreate(CCSInternalChannel), this, copyOnPerform, "" + CCSExitChannel, rho));
    }
    return result;
  },
  performStep: function(step) {
    return step.process.getRight();
  }
};

CCSRecRule = {
  getPossibleSteps: function(application, copyOnPerform) {
    var c, step, steps, _i, _len, _results;
    steps = application.getProcess().getPossibleSteps(copyOnPerform);
    c = 0;
    _results = [];
    for (_i = 0, _len = steps.length; _i < _len; _i++) {
      step = steps[_i];
      _results.push(new CCSStep(c++, application, step.action, this, copyOnPerform, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


CCSExecutorCopyOnPerformStepPolicy = false;

CCSExecutorStepCountPerExecutionUnit = 20;

CCSExecutorDefaultStepPicker = function(steps) {
  return steps[0];
};

CCSExecutor = (function() {
  function CCSExecutor(ccs, delegate) {
    this.ccs = ccs;
    this.delegate = delegate;
  }

  CCSExecutor.prototype.execute = function(system) {
    this.prepareExecution(system);
    while (this.continueExecution()) {
      ({});
    }
    return this.finishExecution();
  };

  CCSExecutor.prototype.prepareExecution = function(system) {
    this.system = system != null ? system : this.ccs.system.copy();
    if (!this.system) {
      throw new Error("No CCS system available!");
    }
    this._printExecutionIntro();
    this.executionStart = new Date();
    return this.stepCount = 0;
  };

  CCSExecutor.prototype._printExecutionIntro = function() {
    return this._output("Starting CCS execution.");
  };

  CCSExecutor.prototype.continueExecution = function() {
    var count, step, steps;
    steps = this.system.getPossibleSteps(CCSExecutorCopyOnPerformStepPolicy);
    if (this.stepCount > 5000) {
      throw new Error("Time exceeded. Info: \n\t" + steps.join("\n\t"));
    }
    count = CCSExecutorStepCountPerExecutionUnit;
    while (steps.length > 0 && count > 0) {
      step = this._chooseStep(steps);
      this._performStep(step);
      this._printStep(step);
      steps = this.system.getPossibleSteps(CCSExecutorCopyOnPerformStepPolicy);
      this.stepCount++;
      count--;
    }
    return steps.length > 0;
  };

  CCSExecutor.prototype._printStep = function(step) {
    var exp, value;
    if (step.action.channel.name !== CCSInternalChannel) {
      exp = step.action.expression;
      value = exp ? exp.evaluate() : "";
      if (exp.typeOfEvaluation() === "string") {
        value = "\"" + value + "\"";
      }
      value = ": " + value;
      if (step.action.isOutputAction()) {
        return this._output("Output on channel <b>" + (step.action.channel.toString()) + "</b>" + value);
      } else if (step.action.isInputAction()) {
        return this._output("Input on channel " + (step.action.channel.toString()) + value);
      } else {
        return this._output("Message on channel " + (step.action.channel.toString()));
      }
    }
  };

  CCSExecutor.prototype.finishExecution = function() {
    this._printExecutionSummary();
    return this.system = null;
  };

  CCSExecutor.prototype._printExecutionSummary = function() {
    var elapsedMS, perStep;
    elapsedMS = (new Date()).getTime() - this.executionStart.getTime();
    perStep = Math.round(elapsedMS / this.stepCount * 100) / 100;
    return this._output("Finished CCS execution after performing " + this.stepCount + " steps in " + (elapsedMS / 1000) + " seconds (" + perStep + "ms per step).\n-------------------------------------------------------------------------------------------");
  };

  CCSExecutor.prototype._output = function(msg) {
    if (this.delegate.executorPrint) {
      return this.delegate.executorPrint(this, msg);
    }
  };

  CCSExecutor.prototype._chooseStep = function(steps) {
    if (this.delegate.executorChooseStep) {
      return this.delegate.executorChooseStep(this, step);
    } else {
      return CCSExecutorDefaultStepPicker(steps);
    }
  };

  CCSExecutor.prototype._performStep = function(step) {
    if (this.delegate.executorWillPerformStep) {
      this.delegate.executorWillPerformStep(this, step);
    }
    this.system = step.perform();
    if (this.delegate.executorDidPerformStep) {
      this.delegate.executorDidPerformStep(this, step, this.system);
    }
    return this.system;
  };

  return CCSExecutor;

})();

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


exports = module && module.exports ? module.exports : {};

exports["parser"] = CCSParser;

exports["internalChannelName"] = CCSInternalChannel;

exports["exitChannelName"] = CCSExitChannel;

exports["typeUnknown"] = CCSTypeUnknown;

exports["typeChannel"] = CCSTypeChannel;

exports["typeValue"] = CCSTypeValue;

exports["getMostGeneralType"] = CCSGetMostGeneralType;

exports["CCS"] = CCS;

exports["ProcessDefinition"] = CCSProcessDefinition;

exports["Process"] = CCSProcess;

exports["Stop"] = CCSStop;

exports["Exit"] = CCSExit;

exports["ProcessApplication"] = CCSProcessApplication;

exports["Prefix"] = CCSPrefix;

exports["Condition"] = CCSCondition;

exports["Choice"] = CCSChoice;

exports["Parallel"] = CCSParallel;

exports["Sequence"] = CCSSequence;

exports["Restriction"] = CCSRestriction;

exports["Channel"] = CCSChannel;

exports["Action"] = CCSAction;

exports["SimpleAction"] = CCSSimpleAction;

exports["Input"] = CCSInput;

exports["Output"] = CCSOutput;

exports["CCSExpression"] = CCSExpression;

exports["ConstantExpression"] = CCSConstantExpression;

exports["VariableExpression"] = CCSVariableExpression;

exports["AdditiveExpression"] = CCSAdditiveExpression;

exports["MultiplicativeExpression"] = CCSMultiplicativeExpression;

exports["ConcatenatingExpression"] = CCSConcatenatingExpression;

exports["RelationalExpression"] = CCSRelationalExpression;

exports["EqualityExpression"] = CCSEqualityExpression;

exports["actionSets"] = ActionSets;

exports["Step"] = CCSStep;

exports["BaseStep"] = CCSBaseStep;

exports["InputStep"] = CCSInputStep;

exports["PrefixRule"] = CCSPrefixRule;

exports["OutputRule"] = CCSOutputRule;

exports["InputRule"] = CCSInputRule;

exports["MatchRule"] = CCSMatchRule;

exports["ChoiceLRule"] = CCSChoiceLRule;

exports["ChoiceRRule"] = CCSChoiceRRule;

exports["ParLRule"] = CCSParLRule;

exports["ParRRule"] = CCSParRRule;

exports["SyncRule"] = CCSSyncRule;

exports["ResRule"] = CCSResRule;

exports["CondRule"] = CCSCondRule;

exports["ExitRule"] = CCSExitRule;

exports["SyncExitRule"] = CCSSyncExitRule;

exports["Seq1Rule"] = CCSSeq1Rule;

exports["Seq2Rule"] = CCSSeq2Rule;

exports["RecRule"] = CCSRecRule;

exports["Executor"] = CCSExecutor;

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
	The central coordination class for the compile process of PseuCo to CCS.
	You start the compilation process by creating a new PCCCompiler object with the node of your PseuCo tree and call compile() on it. You'll get a CCS tree on success
*/

debugger;
var CCS, PC, PCCApplicationPlaceholderStackElement, PCCApplicationStackElement, PCCBinaryCCSStackElement, PCCBinaryContainer, PCCBinaryStackElement, PCCBinaryTarget, PCCChoiceStackElement, PCCClass, PCCClassStackElement, PCCCompiler, PCCCompilerStack, PCCComposedContainer, PCCCondition, PCCConditionStackElement, PCCConstantContainer, PCCConstructor, PCCContainer, PCCExecutor, PCCExitStackElement, PCCField, PCCGlobal, PCCGlobalStackElement, PCCGlobalVariable, PCCGroupable, PCCInputStackElement, PCCInternalReadOnlyField, PCCLocalVariable, PCCOutputStackElement, PCCParallelStackElement, PCCPrefixStackElement, PCCProcedure, PCCProcedureFrame, PCCProcedureStackElement, PCCProcessDefinitionStackElement, PCCProcessFrame, PCCProcessFrameStackElement, PCCProgramController, PCCRestrictionStackElement, PCCSequenceStackElement, PCCStackElement, PCCStackResult, PCCStackResultContainer, PCCStopStackElement, PCCSystemProcessStackElement, PCCType, PCCUnaryContainer, PCCUnaryStackElement, PCCVariable, PCCVariableContainer, PCCVariableInfo, exports, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _t,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PC = require("PseuCo");

CCS = require("CCS");

PCCCompiler = (function() {
  function PCCCompiler(program) {
    this.program = program;
    this.controller = null;
    this.stack = null;
    this.groupElements = [];
    this.controller = new PCCProgramController(this.program);
    this.systemProcesses = [];
    this.compilingNodes = [];
  }

  PCCCompiler.prototype.compileProgram = function() {
    var cls, global, n, p, usedTypes, _i, _j, _len, _len1, _ref, _ref1;
    this.program.collectClasses(this.controller);
    this.program.collectEnvironment(this.controller);
    this.program.collectAgents(this.controller);
    global = new PCCGlobalStackElement(this.controller.getGlobal());
    this.stack = new PCCCompilerStack(global);
    usedTypes = this.controller.getUsedTypes();
    this.compileReturn();
    this.compileMutex();
    this.compileWaitRoom();
    this.compileArrayManager();
    for (n in usedTypes.arrays) {
      this.compileArrayWithCapacity(n);
    }
    this.compileChannelManager();
    for (n in usedTypes.channels) {
      this.compileChannelWithCapacity(n);
    }
    this.compileAgentTools();
    _ref = this.controller.getAgents();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.emitAgentConstructor(this);
      this.beginSystemProcess();
      this.emitProcessApplication(p.getAgentProcessName(), []);
      this.endSystemProcess();
    }
    _ref1 = this.controller.getAllClasses();
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      cls = _ref1[_j];
      cls.emitConstructor(this);
    }
    this.program.compile(this);
    return new CCS(this.controller.root.collectPDefs(), this._getSystem());
  };

  PCCCompiler.prototype.compile = function() {
    var args, node, res;
    node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.compilingNodes.push(node);
    res = node.compile.apply(node, [this].concat(__slice.call(args)));
    this.compilingNodes.pop();
    return res;
  };

  PCCCompiler.prototype.pushStackElement = function(element) {
    element.pseucoNode = this.compilingNodes[this.compilingNodes.length - 1];
    return this.stack.pushElement(element);
  };

  PCCCompiler.prototype._getSystem = function() {
    var i, system, _i, _ref;
    this.beginSystemProcess();
    this.emitProcessApplication("MainAgent", []);
    this.endSystemProcess();
    system = this.systemProcesses[0];
    for (i = _i = 1, _ref = this.systemProcesses.length; _i < _ref; i = _i += 1) {
      system = new CCSParallel(system, this.systemProcesses[i]);
    }
    return new CCSRestriction(system, ["*", "println"]);
  };

  /*
  		Delegates must implement the following methods:
  		 compilerGetVariable(compiler, identifier)
  		 compilerGetProcedure(compiler, identifier)
  		 compilerHandleNewIdentifierWithDefaultValueCallback(compiler, identifier, callback, context)
  		When these methods are called, the receiver may modify the compiler state by emitting CCS processes, pushing processes, ...
  */


  PCCCompiler.prototype.getVariableWithName = function(name, className, isInternal) {
    if (isInternal) {
      name = PCCVariableInfo.getNameForInternalVariableWithName(name);
    }
    if (className) {
      return this.controller.getClassWithName(className).compilerGetVariable(this, name);
    }
    return this.stack.compilerGetVariable(this, name);
  };

  PCCCompiler.prototype.getProcedureWithName = function(name, className) {
    if (className) {
      return this.controller.getClassWithName(className).compilerGetProcedure(this, name);
    }
    return this.stack.compilerGetProcedure(this, name);
  };

  PCCCompiler.prototype.getClassWithName = function(name) {
    return this.controller.getClassWithName(name);
  };

  PCCCompiler.prototype.getCurrentClass = function() {
    var e, _i, _len, _ref;
    _ref = this.groupElements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (e instanceof PCCClassStackElement) {
        return e.classInfo;
      }
    }
  };

  PCCCompiler.prototype.getCurrentProcedure = function() {
    var e, _i, _len, _ref;
    _ref = this.groupElements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (e instanceof PCCProcedureStackElement) {
        return e.procedure;
      }
    }
  };

  PCCCompiler.prototype.getGlobal = function() {
    return this.controller.getGlobal();
  };

  PCCCompiler.prototype.getFreshContainer = function(ccsType, wish) {
    var res;
    res = this.getProcessFrame().createContainer(ccsType, wish);
    res.pseucoNode = this.compilingNodes[this.compilingNodes.length - 1];
    res.pseucoNode.addCalculusComponent(res.pseucoNode);
    return res;
  };

  PCCCompiler.prototype.handleNewVariableWithDefaultValueCallback = function(variable, callback, context) {
    return this.stack.compilerHandleNewVariableWithDefaultValueCallback(this, variable, callback, context);
  };

  PCCCompiler.prototype._getControlElement = function() {
    return this.stack.getCurrentControlElement();
  };

  PCCCompiler.prototype._handleStackResult = function(resultContainer, controlElement) {
    var result, _i, _len, _ref, _results;
    _ref = resultContainer.results;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      _results.push(result.type === PCCStackResult.TYPE_CCSPROCESS_DEFINITION ? controlElement.compilerPushPDef(result.data) : void 0);
    }
    return _results;
  };

  PCCCompiler.prototype.beginSystemProcess = function() {
    var element;
    element = new PCCSystemProcessStackElement();
    this.groupElements.push(element);
    return this.pushStackElement(element);
  };

  PCCCompiler.prototype.endSystemProcess = function() {
    var element, res;
    element = this.groupElements.pop();
    if (!(element instanceof PCCSystemProcessStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    res = element.removeFromStack();
    return this.systemProcesses.push(res.data);
  };

  PCCCompiler.prototype.emitSystemProcessApplication = function(processName, argumentContainers) {
    this.beginSystemProcess();
    this.emitProcessApplication(processName, argumentContainers);
    return this.endSystemProcess();
  };

  PCCCompiler.prototype.beginProcessGroup = function(groupable, variables) {
    var element, frame;
    frame = new PCCProcessFrame(groupable, variables);
    element = new PCCProcessFrameStackElement(frame);
    this.groupElements.push(element);
    this.pushStackElement(element);
    return frame.emitProcessDefinition(this);
  };

  PCCCompiler.prototype.endProcessGroup = function() {
    var controlElement, frame;
    frame = this.groupElements.pop();
    if (!(frame instanceof PCCProcessFrameStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(frame.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.getProcessFrame = function() {
    return this.stack.getCurrentProcessFrame();
  };

  PCCCompiler.prototype.addProcessGroupFrame = function(nextFrame) {
    this.pushStackElement(new PCCProcessFrameStackElement(nextFrame));
    nextFrame.emitProcessDefinition(this);
    return null;
  };

  PCCCompiler.prototype.emitNewScope = function(derivationFrame) {
    var frame, scope;
    frame = this.getProcessFrame();
    if (!derivationFrame) {
      derivationFrame = frame;
    }
    scope = derivationFrame.createScope();
    scope.emitTransitionFromFrame(this, frame);
    this.addProcessGroupFrame(scope);
    return scope;
  };

  PCCCompiler.prototype.emitNextProcessFrame = function(derivationFrames) {
    var frame, next;
    frame = this.getProcessFrame();
    if (!derivationFrames) {
      derivationFrames = [frame];
    }
    next = PCCProcessFrame.createFollowupFrameForFrames(derivationFrames);
    next.emitTransitionFromFrame(this, frame);
    this.addProcessGroupFrame(next);
    return next;
  };

  PCCCompiler.prototype.emitMergeOfProcessFramesOfPlaceholders = function(placeholders) {
    var followup, frames, p, _i, _len;
    if (placeholders.length === 0) {
      return null;
    }
    frames = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = placeholders.length; _i < _len; _i++) {
        p = placeholders[_i];
        _results.push(p.frame);
      }
      return _results;
    })();
    followup = PCCProcessFrame.createFollowupFrameForFrames(frames);
    for (_i = 0, _len = placeholders.length; _i < _len; _i++) {
      p = placeholders[_i];
      followup.emitCallProcessFromFrame(this, p.frame, p);
    }
    this.addProcessGroupFrame(followup);
    return followup;
  };

  PCCCompiler.prototype.protectContainer = function(container) {
    return this.getProcessFrame().protectContainer(container);
  };

  PCCCompiler.prototype.unprotectContainer = function() {
    return this.getProcessFrame().unprotectContainer();
  };

  PCCCompiler.prototype.getProtectedContainer = function() {
    return this.getProcessFrame().getProtectedContainer();
  };

  PCCCompiler.prototype._silentlyAddProcessDefinition = function(processName, argumentContainers) {
    var element;
    element = new PCCProcessDefinitionStackElement(processName, argumentContainers);
    this.pushStackElement(element);
    return element;
  };

  PCCCompiler.prototype.beginProcessDefinition = function(processName, argumentContainers) {
    var element;
    element = this._silentlyAddProcessDefinition(processName, argumentContainers);
    return this.groupElements.push(element);
  };

  PCCCompiler.prototype.isCurrentProcessCompleted = function() {
    return this.stack.isCurrentProcessCompleted();
  };

  PCCCompiler.prototype.endProcessDefinition = function() {
    var controlElement, def;
    def = this.groupElements.pop();
    if (!(def instanceof PCCProcessDefinitionStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(def.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.beginClass = function(className) {
    var curClass, element;
    this.controller.beginClass(className);
    curClass = this.controller.getClassWithName(className);
    if (!curClass) {
      throw new Error("Tried to begin unknown class!");
    }
    element = new PCCClassStackElement(curClass);
    this.pushStackElement(element);
    return this.groupElements.push(element);
  };

  PCCCompiler.prototype.endClass = function() {
    var cls;
    this.controller.endClass();
    cls = this.groupElements.pop();
    if (!(cls instanceof PCCClassStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    return cls.removeFromStack();
  };

  PCCCompiler.prototype.beginProgram = function() {
    /*
    		throw new Error("Stack already existed before beginning of program!") if @stack != null
    		global = new PCCGlobalStackElement(@controller.getGlobal())
    		@stack = new PCCCompilerStack(global)
    		@groupElements.push(global)
    */

  };

  PCCCompiler.prototype.endProgram = function() {};

  /*
  		global = @groupElements.pop()
  		throw new Error("Unexpected stack element!") if not (global instanceof PCCGlobalStackElement)
  		global.removeFromStack()
  		@stack = null
  */


  PCCCompiler.prototype.beginMainAgent = function() {
    this.controller.beginMainAgent();
    return this.beginProcessGroup(new PCCGroupable("MainAgent"));
  };

  PCCCompiler.prototype.endMainAgent = function() {
    this.controller.endMainAgent();
    return this.endProcessGroup();
  };

  PCCCompiler.prototype.beginProcedure = function(procedureName) {
    var element, frame, procedure;
    this.controller.beginProcedure(procedureName);
    procedure = this.stack.compilerGetProcedure(this, procedureName);
    if (!procedure) {
      throw new Error("Tried to begin unknown procedure!");
    }
    frame = new PCCProcedureFrame(procedure);
    element = new PCCProcedureStackElement(procedure);
    this.pushStackElement(element);
    this.groupElements.push(element);
    return this.addProcessGroupFrame(frame);
  };

  PCCCompiler.prototype.endProcedure = function() {
    var controlElement, proc;
    this.controller.endProcedure();
    proc = this.groupElements.pop();
    if (!(proc instanceof PCCProcedureStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(proc.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.beginStatement = function(statement) {};

  PCCCompiler.prototype.endStatement = function() {};

  PCCCompiler.prototype.beginExpression = function(expression) {};

  PCCCompiler.prototype.endExpression = function() {};

  PCCCompiler.prototype._usingFrames = function() {
    return this.groupElements.length > 1 || (this.groupElements.length > 0 && this.groupElements[0] instanceof PCCProcessFrameStackElement);
  };

  PCCCompiler.prototype.emitStop = function() {
    return this.pushStackElement(new PCCStopStackElement());
  };

  PCCCompiler.prototype.emitExit = function() {
    return this.pushStackElement(new PCCExitStackElement());
  };

  PCCCompiler.prototype.emitProcessApplication = function(processName, argumentContainers) {
    if (argumentContainers == null) {
      argumentContainers = [];
    }
    return this.pushStackElement(new PCCApplicationStackElement(processName, argumentContainers));
  };

  PCCCompiler.prototype.emitOutput = function(channel, specificChannel, valueContainer) {
    return this.pushStackElement(new PCCOutputStackElement(channel, specificChannel, valueContainer));
  };

  PCCCompiler.prototype.emitInput = function(channel, specificChannel, container) {
    return this.pushStackElement(new PCCInputStackElement(channel, specificChannel, container));
  };

  PCCCompiler.prototype.emitCondition = function(condition) {
    return this.pushStackElement(new PCCConditionStackElement(condition));
  };

  PCCCompiler.prototype.emitChoice = function() {
    var res;
    res = new PCCChoiceStackElement();
    this.pushStackElement(res);
    if (this._usingFrames()) {
      this.emitNewScope();
    }
    return res;
  };

  PCCCompiler.prototype.emitParallel = function() {
    var res;
    res = new PCCParallelStackElement();
    this.pushStackElement(res);
    if (this._usingFrames()) {
      this.emitNewScope();
    }
    return res;
  };

  PCCCompiler.prototype.emitSequence = function() {
    var res;
    res = new PCCSequenceStackElement();
    this.pushStackElement(res);
    return res;
  };

  PCCCompiler.prototype.emitRestriction = function(restrictedChannelNames) {
    return this.pushStackElement(new PCCRestrictionStackElement(restrictedChannelNames));
  };

  PCCCompiler.prototype.emitProcessApplicationPlaceholder = function() {
    var ph;
    ph = new PCCApplicationPlaceholderStackElement(this.getProcessFrame());
    this.pushStackElement(ph);
    return ph;
  };

  PCCCompiler.prototype.compileMutex = function() {
    var control, i;
    i = new PCCVariableContainer("i", PCCType.INT);
    this.beginProcessDefinition("Mutex", [i]);
    this.emitInput("lock", i, null);
    this.emitInput("unlock", i, null);
    this.emitProcessApplication("Mutex", [i]);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Mutex_cons", [i]);
    this.emitOutput("mutex_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("Mutex_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitProcessApplication("Mutex", [i]);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Mutex_cons", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileWaitRoom = function() {
    var c, control, control1, control2, control3, i, inner;
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("WaitRoom", [i, c]);
    control1 = this.emitChoice();
    this.emitInput("signal", i, null);
    inner = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "=="));
    this.emitProcessApplication("WaitRoom", [i, c]);
    inner.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("wait", i, null);
    this.emitProcessApplication("WaitRoom", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    inner.setBranchFinished();
    control1.setBranchFinished();
    control2 = this.emitChoice();
    this.emitInput("add", i, null);
    this.emitProcessApplication("WaitRoom", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "+")]);
    control2.setBranchFinished();
    control3 = this.emitSequence();
    this.emitInput("signal_all", i, null);
    this.emitProcessApplication("WaitDistributor", [i, c]);
    control3.setBranchFinished();
    this.emitProcessApplication("WaitRoom", [i, new PCCConstantContainer(0)]);
    control3.setBranchFinished();
    control2.setBranchFinished();
    control1.setBranchFinished();
    this.endProcessDefinition();
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("WaitDistributor", [i, c]);
    control = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<="));
    this.emitExit();
    control.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("wait", i, null);
    this.emitProcessApplication("WaitDistributor", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    control.setBranchFinished();
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("WaitRoom_cons", [i]);
    this.emitOutput("wait_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("WaitRoom_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitProcessApplication("WaitRoom", [i, new PCCConstantContainer(0)]);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("WaitRoom_cons", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileArrayWithCapacity = function(size) {
    var args, control, def, emitAccessors, i, index, j, _i, _j, _k, _ref;
    i = new PCCVariableContainer("i", PCCType.INT);
    args = [i];
    for (j = _i = 0; 0 <= size ? _i < size : _i > size; j = 0 <= size ? ++_i : --_i) {
      args.push(new PCCVariableContainer("v" + j, PCCType.INT));
    }
    this.beginProcessDefinition("Array" + size, args);
    index = new PCCVariableContainer("index", PCCType.INT);
    this.emitInput("array_access", i, index);
    emitAccessors = function(compiler, i, size, j, args) {
      var inner;
      compiler.emitCondition(new PCCBinaryContainer(index, new PCCConstantContainer(j), "=="));
      inner = compiler.emitChoice();
      compiler.emitOutput("array_get", i, args[j + 1]);
      compiler.emitProcessApplication("Array" + size, args);
      inner.setBranchFinished();
      compiler.emitInput("array_set", i, args[j + 1]);
      compiler.emitProcessApplication("Array" + size, args);
      return inner.setBranchFinished();
    };
    for (j = _j = 0, _ref = size - 1; 0 <= _ref ? _j < _ref : _j > _ref; j = 0 <= _ref ? ++_j : --_j) {
      control = this.emitChoice();
      emitAccessors(this, i, size, j, args);
      control.setBranchFinished();
    }
    emitAccessors(this, i, size, size - 1, args);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Array" + size + "_cons", []);
    this.emitInput("array_new", null, i);
    def = new PCCVariableContainer("d", PCCType.VOID);
    this.emitOutput("array" + size + "_create", null, i);
    this.emitInput("array_setDefault", i, def);
    control = this.emitParallel();
    this.emitProcessApplication("Array" + size + "_cons", []);
    control.setBranchFinished();
    args = [i];
    for (j = _k = 0; 0 <= size ? _k < size : _k > size; j = 0 <= size ? ++_k : --_k) {
      args.push(def);
    }
    this.emitProcessApplication("Array" + size, args);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Array" + size + "_cons", []);
  };

  PCCCompiler.prototype.compileArrayManager = function() {
    var i;
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("ArrayManager", [i]);
    this.emitOutput("array_new", null, i);
    this.emitProcessApplication("ArrayManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("ArrayManager", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileChannelWithCapacity = function(capacity) {
    var args, c, control, def, i, j, v, _i, _j, _k;
    if (capacity <= 0) {
      return this.compileUnbufferedChannelCons();
    }
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    args = [i, c];
    for (j = _i = 0; 0 <= capacity ? _i < capacity : _i > capacity; j = 0 <= capacity ? ++_i : --_i) {
      args.push(new PCCVariableContainer("v" + j, PCCType.INT));
    }
    this.beginProcessDefinition("Channel" + capacity, args);
    args[1] = new PCCBinaryContainer(c, new PCCConstantContainer(1), "+");
    for (j = _j = 0; 0 <= capacity ? _j < capacity : _j > capacity; j = 0 <= capacity ? ++_j : --_j) {
      control = this.emitChoice();
      this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(j), "=="));
      v = new PCCVariableContainer("v" + j, PCCType.INT);
      this.emitInput("put", i, v);
      this.emitProcessApplication("Channel" + capacity, args);
      control.setBranchFinished();
    }
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitOutput("receive", i, new PCCVariableContainer("v0", PCCType.INT));
    args.splice(2, 1);
    args.push(new PCCConstantContainer(0));
    args[1] = new PCCBinaryContainer(c, new PCCConstantContainer(1), "-");
    this.emitProcessApplication("Channel" + capacity, args);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Channel" + capacity + "_cons", []);
    this.emitInput("channel_new", null, i);
    this.emitOutput("channel" + capacity + "_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("Channel" + capacity + "_cons", []);
    control.setBranchFinished();
    args = [i, new PCCConstantContainer(0)];
    def = new PCCConstantContainer(0);
    for (j = _k = 0; 0 <= capacity ? _k < capacity : _k > capacity; j = 0 <= capacity ? ++_k : --_k) {
      args.push(def);
    }
    this.emitProcessApplication("Channel" + capacity, args);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Channel" + capacity + "_cons", []);
  };

  PCCCompiler.prototype.compileUnbufferedChannelCons = function() {
    var i;
    i = new PCCVariableContainer("i", PCCType.INT);
    this.beginProcessDefinition("Channel_cons", [i]);
    this.emitOutput("channel_create", null, i);
    this.emitProcessApplication("Channel_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "-")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Channel_cons", [new PCCConstantContainer(-1)]);
  };

  PCCCompiler.prototype.compileChannelManager = function() {
    var i;
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("ChannelManager", [i]);
    this.emitOutput("channel_new", null, i);
    this.emitProcessApplication("ChannelManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("ChannelManager", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileAgentTools = function() {
    var a, c, control, i;
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("AgentManager", [i]);
    this.emitOutput("agent_new", null, i);
    this.emitProcessApplication("AgentManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    this.emitSystemProcessApplication("AgentManager", [new PCCConstantContainer(1)]);
    a = new PCCVariableContainer("a", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("AgentJoiner", [a, c]);
    control = this.emitChoice();
    this.emitInput("join_register", a, null);
    this.emitProcessApplication("AgentJoiner", [a, new PCCBinaryContainer(c, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitInput("agent_terminate", a, null);
    this.emitProcessApplication("JoinDistributor", [a, c]);
    control.setBranchFinished();
    this.endProcessDefinition();
    a = new PCCVariableContainer("a", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("JoinDistributor", [a, c]);
    control = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<="));
    this.emitInput("join_register", a, null);
    this.emitInput("join", a, null);
    this.emitProcessApplication("JoinDistributor", [a, new PCCConstantContainer(0)]);
    control.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("join", a, null);
    this.emitProcessApplication("JoinDistributor", [a, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    control.setBranchFinished();
    return this.endProcessDefinition();
  };

  PCCCompiler.prototype.compileReturn = function() {
    var v;
    this.beginProcessDefinition("Return", []);
    v = new PCCVariableContainer("v", PCCType.INT);
    this.emitInput("return", null, v);
    this.emitOutput("rreturn", null, v);
    this.emitProcessApplication("Return", []);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Return", []);
  };

  return PCCCompiler;

})();

PC.EnvironmentNode.prototype.compilerPushPDef = function(pdef) {
  if (!this.PCCCompilerPDefs) {
    this.PCCCompilerPDefs = [];
  }
  return this.PCCCompilerPDefs.push(pdef);
};

PC.Variable.prototype.compilerPushPDef = PC.EnvironmentNode.prototype.compilerPushPDef;

PC.EnvironmentNode.prototype.collectPDefs = function() {
  var c;
  if (!this.PCCCompilerPDefs) {
    this.PCCCompilerPDefs = [];
  }
  return this.PCCCompilerPDefs.concat(((function() {
    var _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.collectPDefs());
    }
    return _results;
  }).call(this)).concatChildren());
};

PC.Variable.prototype.collectPDefs = function() {
  if (this.PCCCompilerPDefs) {
    return this.PCCCompilerPDefs;
  } else {
    return [];
  }
};

PC.Node.prototype.addCalculusComponent = function(component) {
  if (!this.calculusComponents) {
    this.calculusComponents = [];
  }
  return this.calculusComponents.push(component);
};

PC.Node.prototype.getCalculusComponents = function() {
  if (!this.calculusComponents) {
    this.calculusComponents = [];
  }
  return this.calculusComponents;
};

/*
PCStmtExpression::collectAgents = (env) -> 
	@children[0].collectAgents(env)
PCVariableDeclarator::collectEnvironment = (env, type) ->
	@children.length > 0 and @children[0].collectEnvironment(env)
PCVariableInitializer::collectEnvironment = (env) ->
	!@isArray() and @children[0].collectEnvironment(env)
PCExpression::collectEnvironment = (env) -> c.collectEnvironment(env) for c in @children
PCStartExpression::collectEnvironment = (env) ->
	env instanceof PCCProgramController and env.processProcedureAsAgent(@children[0].getProcedure(env))
*/


PCCConstructor = (function() {
  function PCCConstructor(compiler, delegate, context) {
    this.compiler = compiler;
    this.delegate = delegate;
    this.context = context;
  }

  PCCConstructor.prototype.emit = function() {
    var control, entry, envArgCount, envName, i, recursion, v, variables, vars, _base, _i;
    envName = this.delegate.constructorGetName(this, this.context);
    variables = this.delegate.constructorGetArguments(this, this.compiler, this.context);
    this.compiler.beginProcessGroup(new PCCGroupable(envName + "_cons"), variables);
    entry = this.compiler.getProcessFrame();
    variables = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(this.compiler.getVariableWithName(v.getName(), null, v.isInternal));
      }
      return _results;
    }).call(this);
    envArgCount = this.delegate.constructorProtectEnvironmentArguments(this, this.compiler, variables, this.context);
    vars = [];
    for (i = _i = 0; 0 <= envArgCount ? _i < envArgCount : _i > envArgCount; i = 0 <= envArgCount ? ++_i : --_i) {
      vars.unshift(this.compiler.unprotectContainer());
    }
    recursion = typeof (_base = this.delegate).constructorShouldCallRecursively === "function" ? _base.constructorShouldCallRecursively(this, this.context) : void 0;
    control = null;
    if (recursion) {
      control = this.compiler.emitParallel();
    }
    this.compiler.emitProcessApplication(envName, vars);
    if (recursion) {
      control.setBranchFinished();
      this.delegate.constructorUpdateVariablesForRecursiveCall(this, this.compiler, entry, variables, this.context);
      entry.emitCallProcessFromFrame(this.compiler, this.compiler.getProcessFrame());
      control.setBranchFinished();
    }
    return this.compiler.endProcessGroup();
  };

  return PCCConstructor;

})();

PCCConstructor.emitConstructor = function(compiler, delegate, context) {
  return (new PCCConstructor(compiler, delegate, context)).emit();
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	Manages multiple versions of process frames. A process frame is the set of all arguments, local variables and temporary containers of a compile unit, also called a process groupable (e.g. a procedure) at a specific time.
	Process frames may exist in multiple versions: One version for each CCS process. Because of restrictions of CCS it is not always possible to compile into a single process. This class helps to manage the fragmentation of code into multiple processes.
	Versions are partially ordered.
*/


/*
	Groupable implements:
	 getProcessName()
*/


PCCProcessFrame = (function() {
  /*
  		* @param groupable: An object that implements the Groupable interface. All process frames with the same groupable object are in the same process group.
  		* @param variables: An array of PCCVariableInfo objects. The incoming variables that will get passed on transition to the represented process definition.
  		* @param tempTypes: An array of PCTType objects, which represents the values that will get passed as temporary values on transition to the represented process definition.
  		* @param autoInit: By default true. If the created process frame will be followup process frame, the creator of the frame might want to perform its own initialization, which it can communicate through this parameter.
  		
  		
  		Variables:
  			processID: Gives a process frame a unique identifier within the group, which is used to determine a unique name for the created process definition. For scopes the value of this variable is not relevant.
  			containerIndex: The number of issued auto-named PCCVariableContainer objects (using @createContainer).
  			usedContainers: An array of PCCVariableContainer objects that are already in use in the scope of the represented process definition.
  			varTable: A map from PseuCo identifiers (string) to PCCContainer objects which represents the current value of the corresponding identifier.
  			protections: A stack (array) of PCCContainer objects which represent a temporary value.
  			initialVariableCount: The number of incomming variables.
  			variables: An array of PCCVariableInfo objects, which represent the PseuCo variables currently covered by the process frame.
  */

  function PCCProcessFrame(groupable, variables, tempTypes, autoInit) {
    this.groupable = groupable;
    this.variables = variables != null ? variables : [];
    this.tempTypes = tempTypes != null ? tempTypes : [];
    if (autoInit == null) {
      autoInit = true;
    }
    if (autoInit) {
      this._freshInit();
    }
    null;
  }

  PCCProcessFrame.prototype._freshInit = function() {
    var i, v, _i, _len, _ref;
    if (this.groupable.frameCount === void 0) {
      this.groupable.frameCount = 0;
    }
    this.processID = this.groupable.frameCount++;
    this.containerIndex = 0;
    this.usedContainers = [];
    this.varTable = {};
    _ref = this.variables;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      this.varTable[v.getIdentifier()] = this.createContainer(v.getCCSType(), v.getSuggestedContainerName());
    }
    this.protections = (function() {
      var _j, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref1 = this.tempTypes.length; _j < _ref1; i = _j += 1) {
        _results.push(this.createContainer(this.tempTypes[i], "t" + i));
      }
      return _results;
    }).call(this);
    return this.initialVariableCount = this.variables.length;
  };

  PCCProcessFrame.prototype._argumentsForProcessDefinition = function() {
    var args, v;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = this.variables;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(this.varTable[v.getIdentifier()]);
      }
      return _results;
    }).call(this);
    return args.concat(this.protections);
  };

  /*
  		Must be called before new containers get assigned to the variables or temporary values are pushed or popped!
  */


  PCCProcessFrame.prototype.emitProcessDefinition = function(compiler) {
    var args;
    if (this.isScope) {
      return;
    }
    args = this._argumentsForProcessDefinition();
    return compiler._silentlyAddProcessDefinition(this._getProcessName(), args);
  };

  PCCProcessFrame.prototype._getProcessName = function() {
    return "" + (this.groupable.getProcessName()) + (this.processID > 0 ? "_" + this.processID : "");
  };

  PCCProcessFrame.prototype._getProcessArgCount = function() {
    return this.initialVariableCount + this.tempTypes.length;
  };

  PCCProcessFrame.prototype._didAlreadyUseContainerWithIdentifier = function(id) {
    var c, _i, _len, _ref;
    _ref = this.usedContainers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (c.identifier === id) {
        return true;
      }
    }
    return false;
  };

  PCCProcessFrame.prototype.createContainer = function(ccsType, wish) {
    var container, id;
    if (typeof wish === "string" && wish.length > 0 && wish.indexOf("f_") !== 0 && !this._didAlreadyUseContainerWithIdentifier(wish)) {
      id = wish;
    } else {
      id = "f_" + (this.containerIndex++);
    }
    container = new PCCVariableContainer(id, ccsType);
    this.usedContainers.push(container);
    return container;
  };

  PCCProcessFrame.prototype.getContainerForVariable = function(identifier) {
    if (this.varTable[identifier] === void 0) {
      throw new Error("Unknown variable!");
    }
    return this.varTable[identifier];
  };

  PCCProcessFrame.prototype.assignContainerToVariable = function(identifier, container) {
    if (this.varTable[identifier] === void 0) {
      throw new Error("Unknown variable!");
    }
    return this.varTable[identifier] = container;
  };

  PCCProcessFrame.prototype.addLocalVariable = function(variable, container) {
    if (!this.varTable[variable.getIdentifier()]) {
      this.variables.push(variable);
    }
    return this.varTable[variable.getIdentifier()] = container;
  };

  PCCProcessFrame.prototype.protectContainer = function(container) {
    return this.protections.push(container);
  };

  PCCProcessFrame.prototype.unprotectContainer = function() {
    return this.protections.pop();
  };

  /*
  		Returns the last pushed temporary value.
  */


  PCCProcessFrame.prototype.getProtectedContainer = function() {
    if (this.protections.length === 0) {
      throw new Error("No protected containers available");
    }
    return this.protections[this.protections.length - 1];
  };

  PCCProcessFrame.prototype.isContainerLocalVariable = function(container) {
    var c, v, _ref;
    _ref = this.varTable;
    for (v in _ref) {
      c = _ref[v];
      if (container.isEqual(c)) {
        return true;
      }
    }
    return false;
  };

  PCCProcessFrame.prototype.createFollowupFrame = function() {
    return PCCProcessFrame.createFollowupFrameForFrames([this]);
  };

  PCCProcessFrame.prototype._createFollowupFrameAcceptingTempTypes = function(tempTypes) {
    return new PCCProcessFrame(this.groupable, this.variables.slice(0), tempTypes);
  };

  PCCProcessFrame.prototype.getTypesForTemporaryValues = function() {
    var c, _i, _len, _ref, _results;
    _ref = this.protections;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.ccsType);
    }
    return _results;
  };

  PCCProcessFrame.prototype.createScope = function() {
    var res;
    res = new PCCProcessFrame(this.groupable, this.variables.slice(0), this.getTypesForTemporaryValues(), false);
    this._configureVariablesInScope(res);
    return res;
  };

  PCCProcessFrame.prototype._configureVariablesInScope = function(res) {
    res.processID = this.processID;
    res.initialVariableCount = this.variables.length;
    res.parentFrame = this;
    res.isScope = true;
    return null;
  };

  /*
  		Guarantees that it is allowed to transition from frame to the receiver of the method call.
  */


  PCCProcessFrame.prototype._checkTransitionConsistency = function(frame) {
    var fail, i, _i, _ref;
    fail = frame.protections.length !== this.tempTypes.length;
    if (frame.groupable !== this.groupable) {
      fail = true;
    }
    fail = this.isScope && this.varTable;
    if (frame.variables.length < this.initialVariableCount) {
      fail = true;
    }
    for (i = _i = 0, _ref = this.initialVariableCount; _i < _ref; i = _i += 1) {
      if (this.variables[i].getIdentifier() !== frame.variables[i].getIdentifier()) {
        fail = true;
        break;
      }
    }
    if (fail) {
      throw new Error("Call consistency is violated!");
    }
    return null;
  };

  PCCProcessFrame.prototype._variablesForTransition = function() {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = this.initialVariableCount; _i < _ref; i = _i += 1) {
      _results.push(this.variables[i]);
    }
    return _results;
  };

  PCCProcessFrame.prototype._argumentsToCallProcessFromFrame = function(frame) {
    var args, v;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = this._variablesForTransition();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(frame.varTable[v.getIdentifier()]);
      }
      return _results;
    }).call(this);
    return args.concat(frame.protections.slice(0, this.tempTypes.length));
  };

  PCCProcessFrame.prototype.emitCallProcessFromFrame = function(compiler, frame, appPlaceholder) {
    var args;
    this._checkTransitionConsistency(frame);
    args = this._argumentsToCallProcessFromFrame(frame);
    return this.emitCallProcessWithArgumentContainers(compiler, args, appPlaceholder);
  };

  PCCProcessFrame.prototype.emitCallProcessWithArgumentContainers = function(compiler, containers, appPlaceholder) {
    if (this.isScope) {
      throw new Error("Illegal operation! This method cannot be used with scopes!");
    }
    if (containers.length !== this._getProcessArgCount()) {
      throw new Error("Number of argument containers does not match number of required arguments");
    }
    if (appPlaceholder) {
      return appPlaceholder.set(this._getProcessName(), containers);
    } else {
      return compiler.emitProcessApplication(this._getProcessName(), containers);
    }
  };

  PCCProcessFrame.prototype._emitScopeTransition = function(compiler, frame) {
    var v, _i, _len, _ref;
    this.containerIndex = frame.containerIndex;
    this.usedContainers = frame.usedContainers.slice(0);
    this.varTable = {};
    _ref = this._variablesForTransition();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      this.varTable[v.getIdentifier()] = frame.varTable[v.getIdentifier()];
    }
    return this.protections = frame.protections.slice(0);
  };

  PCCProcessFrame.prototype.emitTransitionFromFrame = function(compiler, frame) {
    if (this.isScope) {
      this._checkTransitionConsistency(frame);
      return this._emitScopeTransition(compiler, frame);
    } else {
      return this.emitCallProcessFromFrame(compiler, frame);
    }
  };

  return PCCProcessFrame;

})();

PCCProcedureFrame = (function(_super) {
  __extends(PCCProcedureFrame, _super);

  function PCCProcedureFrame(procedure, variables, tempTypes, autoInit) {
    if (!variables) {
      variables = procedure["arguments"];
      if (procedure.isClassProcedure()) {
        variables.unshift(new PCCVariableInfo(null, "i", null, true));
      }
    }
    PCCProcedureFrame.__super__.constructor.call(this, procedure, variables, tempTypes, autoInit);
  }

  PCCProcedureFrame.prototype.getProcedure = function() {
    return this.groupable;
  };

  PCCProcedureFrame.prototype._createFollowupFrameAcceptingTempTypes = function(tempTypes) {
    return new PCCProcedureFrame(this.groupable, this.variables.slice(0), tempTypes);
  };

  PCCProcedureFrame.prototype.createScope = function() {
    var res;
    res = new PCCProcedureFrame(this.groupable, this.variables.slice(0), this.getTypesForTemporaryValues(), false);
    this._configureVariablesInScope(res);
    return res;
  };

  return PCCProcedureFrame;

})(PCCProcessFrame);

/*
	This method creates a new process frame.
	@param frames: The array with the process frames that the new frame should be derived by.
*/


PCCProcessFrame.createFollowupFrameForFrames = function(frames) {
  var closestAncestor, result;
  PCCProcessFrame.checkFramesForConsistency(frames);
  closestAncestor = PCCProcessFrame.findClosesAncestorForFrames(frames);
  result = closestAncestor._createFollowupFrameAcceptingTempTypes(frames[0].getTypesForTemporaryValues());
  result.parentFrame = closestAncestor;
  return result;
};

/*
	Helping methods for creating a new frame.
*/


PCCProcessFrame.checkTempTypesEquality = function(prot1, prot2) {
  var i, _i, _ref;
  if (prot1.length !== prot2.length) {
    return false;
  }
  for (i = _i = 0, _ref = prot1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (!prot1[i].ccsType.isEqual(prot2[i].ccsType)) {
      return false;
    }
  }
  return true;
};

PCCProcessFrame.checkFramesForConsistency = function(frames) {
  var groupable, i, protections, _i, _ref;
  groupable = frames[0].groupable;
  protections = frames[0].protections;
  for (i = _i = 1, _ref = frames.length; _i < _ref; i = _i += 1) {
    if (frames[i].groupable !== groupable || !PCCProcessFrame.checkTempTypesEquality(protections, frames[i].protections)) {
      throw new Error("Inconsistent process frames");
    }
  }
  return null;
};

PCCProcessFrame.prototype.parentFrame = null;

PCCProcessFrame.prototype.mark = function(m) {
  if (!this.marked) {
    this.marked = [];
  }
  return this.marked.push(m);
};

PCCProcessFrame.findClosesAncestorForFrames = function(frames) {
  var closestAncestor, currentFrames, f, i, markedFrames, _i, _j, _len, _ref;
  closestAncestor = null;
  markedFrames = [];
  currentFrames = frames.concat([]);
  while (closestAncestor === null) {
    for (i = _i = 0, _ref = frames.length; _i < _ref; i = _i += 1) {
      if (currentFrames[i] !== null) {
        currentFrames[i].mark(frames[i]);
        markedFrames.push(currentFrames[i]);
        if (currentFrames[i].marked.length === frames.length) {
          closestAncestor = currentFrames[i];
          break;
        }
        currentFrames[i] = currentFrames[i].parentFrame;
      }
    }
  }
  for (_j = 0, _len = markedFrames.length; _j < _len; _j++) {
    f = markedFrames[_j];
    f.marked = null;
  }
  return closestAncestor;
};

PCCProcessFrame.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
  var c;
  c = variable.compileDefaultValue(compiler);
  compiler.getProcessFrame().addLocalVariable(variable, c);
  return variable;
};

PCCProcessFrame.prototype.compilerGetVariable = function(compiler, identifier) {
  var v, _i, _len, _ref;
  _ref = this.variables;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    if (v.getIdentifier() === identifier) {
      return new PCCLocalVariable(v.node, v.getName(), v.type, v.isInternal);
    }
  }
  return null;
};

PCCProcessFrame.prototype.compilerGetProcedure = function(compiler, identifier, instanceContainer) {
  return null;
};

PCCProcedureFrame.prototype.compilerGetProcedure = function(compiler, identifier, instanceContainer) {
  var p;
  p = this.getProcedure();
  if (p.getName() === identifier) {
    return p;
  } else {
    return p.getProcedureWithName(identifier);
  }
};

PCCGroupable = (function() {
  function PCCGroupable(processName) {
    this.processName = processName;
  }

  PCCGroupable.prototype.getProcessName = function() {
    return this.processName;
  };

  return PCCGroupable;

})();

/*
class PCCContainerInfo
	constructor: (@payload, @isLocalVariable) ->


class PCCContainerInfoArray
	constructor: (temporaryItems=[]) -> @infos = (new PCCContainerInfo(c, false) for c in temporaryItems)
	copy: ->
		res = new PCCContainerProtectionArray()
		res.infos = @infos[..]
		res
	getCount: ->
		res = 0
		++res for ci in @infos
		res
	
	# Protecting Containers
	protectContainer: (container, isLocalVariable) ->
		@protections.push(new PCCContainerInfo(container, isLocalVariable))
	unprotectContainer: -> @infos.pop().container
	getContainer: ->
		throw new Error("getProtection: Nothing protected at the moment!") if @infos.length == 0
		@infos[@infos.length-1].payload
	getTemporaryContainers: ->
		res = []
		(res.push(ci.payload) if not ci.isLocalVariable) for ci in @infos
		res
	
	getCCSTypes: ->
		res = new PCCContainerInfoArray()
		res.infos = (new PCCContainerInfo(ci.payload.ccsType, ci.isLocalVariable) for ci in @infos)
		res
		
	getTemporaryTypes: ->
		res = []
		return res if infos.length == 0
		if @infos[0].payload instanceof PCCContainer
			(res.push(ci.payload.ccsType) if not cp.isLocalVariable) for ci in @infos
		else if infos[0].payload instanceof PCCType
			(res.push(ci.payload) if not cp.isLocalVariable) for ci in @infos
		else
			throw new Error("getTemporaryTypes not applicable on payload!")
		res
*/


/*

{version: "1.0", tree: (new PCProgram((new PCDecl(true, (new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("x", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(42))))))))), (new PCMainAgent((new PCStmtBlock((new PCDecl(true, (new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("y", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(7))))))))), (new PCStatement((new PCForStmt((new PCStatement((new PCStmtBlock((new PCStatement((new PCPrintStmt((new PCAdditiveExpression((new PCLiteralExpression("Die Zahl ist ")), "+", (new PCAdditiveExpression((new PCAdditiveExpression((new PCIdentifierExpression("x")), "+", (new PCIdentifierExpression("y")))), "+", (new PCIdentifierExpression("i")))))))))))))), (new PCForInit((new PCDecl(false, (new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("i", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(0))))))))))), (new PCRelationalExpression((new PCIdentifierExpression("i")), "<", (new PCLiteralExpression(parseInt(10))))), (new PCStmtExpression((new PCPostfixExpression((new PCAssignDestination("i")), "++"))))))))))))))}
*/


/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	PCCProgramController manages all variables, classes, procedures and the relationships between each other that occur in a PseuCo program.
*/


PCCGlobal = (function(_super) {
  __extends(PCCGlobal, _super);

  function PCCGlobal(program) {
    PCCGlobal.__super__.constructor.call(this, program, "");
  }

  PCCGlobal.prototype.getVariableClass = function() {
    return PCCGlobalVariable;
  };

  PCCGlobal.prototype.compilerGetVariable = function(compiler, identifier) {
    return this.getVariableWithName(identifier);
  };

  PCCGlobal.prototype.compilerGetProcedure = function(compiler, identifier) {
    return this.getProcedureWithName(identifier);
  };

  PCCGlobal.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
    variable = this.getVariableWithName(variable.getName());
    if (variable === void 0) {
      throw new Error("Unexpected new identifier found!");
    }
    variable.emitConstructor(compiler);
    return variable;
  };

  return PCCGlobal;

})(PC.EnvironmentNode);

PCCClass = (function(_super) {
  __extends(PCCClass, _super);

  function PCCClass() {
    PCCClass.__super__.constructor.apply(this, arguments);
    this.addChild(new PCCInternalReadOnlyField(null, "guard", new PC.Type(PC.Type.MUTEX), true));
  }

  PCCClass.prototype.getAllConditions = function() {
    var n, result, v, _ref;
    result = [];
    _ref = this.variables;
    for (n in _ref) {
      v = _ref[n];
      if (v.type && v.type.kind === PC.Type.CONDITION) {
        result.push(v);
      }
    }
    return result;
  };

  PCCClass.prototype.getVariableClass = function() {
    return PCCField;
  };

  PCCClass.prototype.compilerGetVariable = function(compiler, identifier) {
    return this.getVariableWithName(identifier);
  };

  PCCClass.prototype.compilerGetProcedure = function(compiler, identifier) {
    return this.getProcedureWithName(identifier);
  };

  PCCClass.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
    return this.getVariableWithName(variable.getName());
  };

  PCCClass.prototype.emitEnvironment = function(compiler) {
    var control, i, instance, n, names, v, variables, _i, _ref;
    variables = (function() {
      var _ref, _results;
      _ref = this.variables;
      _results = [];
      for (n in _ref) {
        v = _ref[n];
        _results.push(v);
      }
      return _results;
    }).call(this);
    instance = new PCCVariableInfo(null, "i", this.type, true);
    variables.unshift(instance);
    compiler.beginProcessGroup(new PCCGroupable(this.getEnvProcessName()), variables);
    variables = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(compiler.getVariableWithName(v.getIdentifier()));
      }
      return _results;
    })();
    names = (function() {
      var _results;
      _results = [];
      for (n in this.variables) {
        _results.push(n);
      }
      return _results;
    }).call(this);
    for (i = _i = 0, _ref = names.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      control = compiler.emitChoice();
      this.variables[names[i]].emitAccessors(compiler, variables, variables[0].getContainer(compiler));
      control.setBranchFinished();
    }
    this.variables[names[names.length - 1]].emitAccessors(compiler, variables, variables[0].getContainer(compiler));
    return compiler.endProcessGroup();
  };

  PCCClass.prototype.emitConstructor = function(compiler) {
    var hasVariables, n;
    hasVariables = false;
    for (n in this.variables) {
      hasVariables = true;
      break;
    }
    if (!hasVariables) {
      return;
    }
    this.emitEnvironment(compiler);
    PCCConstructor.emitConstructor(compiler, this);
    return compiler.emitSystemProcessApplication(this.getProcessName(), [new PCCConstantContainer(1)]);
  };

  PCCClass.prototype.constructorGetName = function() {
    return this.getEnvProcessName();
  };

  PCCClass.prototype.constructorGetArguments = function() {
    return [new PCCVariableInfo(null, "next_i", this.type, true)];
  };

  PCCClass.prototype.constructorProtectEnvironmentArguments = function(cons, compiler, variables) {
    var c, instance, n, res, v, _ref;
    instance = variables[0];
    compiler.emitOutput("class_" + (this.getName()) + "_create", null, instance.getContainer(compiler));
    compiler.protectContainer(instance.getContainer(compiler));
    res = 1;
    _ref = this.variables;
    for (n in _ref) {
      v = _ref[n];
      c = v.compileDefaultValue(compiler);
      compiler.protectContainer(c);
      res++;
    }
    return res;
  };

  PCCClass.prototype.constructorShouldCallRecursively = function() {
    return true;
  };

  PCCClass.prototype.constructorUpdateVariablesForRecursiveCall = function(cons, compiler, entry, variables) {
    var instance, new_i;
    instance = variables[0];
    new_i = new PCCBinaryContainer(instance.getContainer(compiler), new PCCConstantContainer(1), "+");
    return instance.setContainer(compiler, new_i);
  };

  PCCClass.prototype.getProcessName = function() {
    return "Env_class_" + (this.getName()) + "_cons";
  };

  PCCClass.prototype.getEnvProcessName = function() {
    return "Env_class_" + (this.getName());
  };

  return PCCClass;

})(PC.Class);

PCCProcedure = (function(_super) {
  __extends(PCCProcedure, _super);

  function PCCProcedure() {
    _ref = PCCProcedure.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PCCProcedure.prototype.getProcessName = function() {
    return "Proc" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getAgentStarterChannel = function() {
    return "start" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getAgentProcessName = function() {
    return "Agent" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getVariableClass = function() {
    return PCCLocalVariable;
  };

  PCCProcedure.prototype.getAllArgumentContainers = function(compiler, explicitArgumentContainers, instanceContainer) {
    var argumentContainers;
    argumentContainers = explicitArgumentContainers.slice(0);
    if (this.isClassProcedure()) {
      if (!instanceContainer) {
        instanceContainer = compiler.getVariableWithName("i", null, true).getContainer(compiler);
      }
      argumentContainers.unshift(instanceContainer);
    } else {
      if (instanceContainer) {
        throw new Error("Illegal instance value");
      }
    }
    return argumentContainers;
  };

  PCCProcedure.prototype.getImplicitAndExplicitArgumentCount = function() {
    var res;
    res = this["arguments"].length;
    if (this.isClassProcedure()) {
      res++;
    }
    return res;
  };

  PCCProcedure.prototype.emitAgentConstructor = function(compiler) {
    var a, args, control1, control2, control3, definitionName, i, j, _i, _ref1;
    definitionName = this.getAgentProcessName();
    compiler.beginProcessDefinition(definitionName, []);
    i = new PCCVariableContainer("i", PCCType.INT);
    compiler.emitInput("agent_new", null, i);
    compiler.emitOutput(this.getAgentStarterChannel(), null, i);
    args = [];
    for (j = _i = 0, _ref1 = this.getImplicitAndExplicitArgumentCount(); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; j = 0 <= _ref1 ? ++_i : --_i) {
      a = new PCCVariableContainer("a" + j, PCCType.VOID);
      compiler.emitInput("start_set_arg", i, a);
      args.push(a);
    }
    control1 = compiler.emitParallel();
    compiler.emitProcessApplication(definitionName, []);
    control1.setBranchFinished();
    control2 = compiler.emitParallel();
    control3 = compiler.emitSequence();
    compiler.emitProcessApplication(this.getProcessName(), args);
    control3.setBranchFinished();
    compiler.emitOutput("agent_terminate", i, null);
    compiler.emitStop();
    control3.setBranchFinished();
    control2.setBranchFinished();
    compiler.emitProcessApplication("AgentJoiner", [i, new PCCConstantContainer(0)]);
    control2.setBranchFinished();
    control1.setBranchFinished();
    return compiler.endProcessDefinition();
  };

  PCCProcedure.prototype.emitExit = function(compiler) {
    var guard;
    if (this.isMonitorProcedure()) {
      guard = compiler.getVariableWithName("guard", null, true);
      compiler.emitOutput("unlock", guard.getContainer(compiler));
    }
    return compiler.emitExit();
  };

  return PCCProcedure;

})(PC.Procedure);

/*
	PCCType represents CCS types, and - if an integer is used as a reference - the referenced CCS type.
*/


PCCType = (function() {
  function PCCType(_type, _className) {
    this._type = _type;
    this._className = _className;
    if (!this._type && this._className) {
      this._type = 1;
    }
  }

  PCCType.prototype.isVoid = function() {
    return this._type === -1;
  };

  PCCType.prototype.isBool = function() {
    return this._type === 0;
  };

  PCCType.prototype.isInt = function() {
    return this._type === 1;
  };

  PCCType.prototype.isString = function() {
    return this._type === 2;
  };

  PCCType.prototype.isArray = function() {
    return this._type instanceof PCCType;
  };

  PCCType.prototype.isClass = function() {
    if (this._className) {
      return true;
    } else {
      return false;
    }
  };

  PCCType.prototype.getClassName = function() {
    if (!this._className) {
      throw new Error("Can't get class name for non-class type!");
    }
    return this._className;
  };

  PCCType.prototype.isEqual = function(type) {
    if (this.isArray()) {
      return type.isArray() && this._type.isEqual(type._type);
    } else {
      return this._type === type._type;
    }
  };

  PCCType.prototype.getSubtype = function() {
    if (!this.isArray()) {
      throw new Error("Cannot get subtype for non-array type!");
    }
    return this._type._type;
  };

  PCCType.prototype.getDefaultContainer = function() {
    if (this.isArray() || this.isClass()) {
      return new PCCConstantContainer(0);
    }
    return new PCCConstantContainer((function() {
      switch (this._type) {
        case 0:
          return false;
        case 1:
          return 0;
        case 2:
          return "";
        default:
          throw new Error("Void does not have a default value");
      }
    }).call(this));
  };

  return PCCType;

})();

PCCType.VOID = new PCCType(-1);

PCCType.BOOL = new PCCType(0);

PCCType.INT = new PCCType(1);

PCCType.STRING = new PCCType(2);

PC.Type.prototype.getCCSType = function() {
  switch (this.kind) {
    case PC.Type.INT:
      return PCCType.INT;
    case PC.Type.BOOL:
      return PCCType.BOOL;
    case PC.Type.STRING:
      return PCCType.STRING;
    case PC.Type.CHANNEL:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.ARRAY:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.MONITOR:
      return PCCType.INT;
    case PC.Type.STRUCTURE:
      return PCCType.INT;
    case PC.Type.MUTEX:
      return PCCType.INT;
    case PC.Type.CONDITION:
      return PCCType.INT;
    case PC.Type.PROCEDURE:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.TYPE:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.MAINAGENT:
      throw new Error("Unexpected type kind!");
      break;
    case PC.Type.AGENT:
      return PCCType.INT;
    case PC.Type.WILDCARD:
      throw new Error("Unexpected type kind!");
      break;
    default:
      return PCCType.VOID;
  }
};

PC.ArrayType.prototype.getCCSType = function() {
  return new PCCType(this.elementsType.getCCSType());
};

PC.ChannelType.prototype.getCCSType = function() {
  return new PCCType(this.channelledType.getCCSType());
};

PC.ProcedureType.prototype.getCCSType = function() {
  return this.returnType.getCCSType();
};

PC.ProcedureType.prototype.getCCSArgumentTypes = function() {
  var t, _i, _len, _ref1, _results;
  _ref1 = this.argumentTypes;
  _results = [];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    t = _ref1[_i];
    _results.push(t.getCCSType());
  }
  return _results;
};

/*
PCTArrayType::fulfillAssignment = (compiler, container) ->
	result = compiler.getFreshContainer(container.ccsType)
	compiler.emitInput("array_copy", container, result)
	result
*/


PC.ArrayType.prototype.createContainer = function(compiler, containers) {
  var c, i, result, _i, _j, _len, _ref1, _ref2;
  if (containers == null) {
    containers = [];
  }
  result = compiler.getFreshContainer(this.getCCSType());
  compiler.emitInput("array" + this.capacity + "_create", null, result);
  compiler.emitOutput("array_setDefault", result, this.elementsType.getCCSType().getDefaultContainer());
  if (this.elementsType.requiresCustomDefaultContainer()) {
    for (i = _i = _ref1 = containers.length, _ref2 = this.capacity; _i < _ref2; i = _i += 1) {
      containers.push(this.elementsType.createContainer(compiler));
    }
  }
  for (i = _j = 0, _len = containers.length; _j < _len; i = ++_j) {
    c = containers[i];
    compiler.emitOutput("array_access", result, new PCCConstantContainer(i));
    compiler.emitOutput("array_set", result, c);
  }
  return result;
};

PC.Type.prototype.requiresCustomDefaultContainer = function() {
  return this.kind !== PC.Type.INT && this.kind !== PC.Type.BOOL && this.kind !== PC.Type.STRING;
};

PC.Type.prototype.createContainer = function(compiler, container) {
  var result;
  if (container) {
    return container;
  }
  if (this.kind === PC.Type.AGENT) {
    throw new Error("No default value for agents available");
  }
  if (this.kind === PC.Type.VOID) {
    throw new Error("No default value for void available");
  }
  if (this.kind === PC.Type.MUTEX) {
    result = compiler.getFreshContainer(PCCType.INT);
    compiler.emitInput("mutex_create", null, result);
    return result;
  } else if (this.kind === PC.Type.STRING) {
    return new PCCConstantContainer("");
  } else {
    return new PCCConstantContainer(0);
  }
};

PC.ChannelType.prototype.createContainer = function(compiler, container) {
  var buffered, channel, res;
  if (container) {
    return container;
  }
  res = compiler.getFreshContainer(this.getCCSType());
  buffered = this.capacity !== PCChannelType.CAPACITY_UNKNOWN && this.capacity !== 0;
  channel = "channel" + (buffered ? this.capacity : "") + "_create";
  compiler.emitInput(channel, null, res);
  return res;
};

PC.ClassType.prototype.createContainer = function(compiler, container) {
  var result;
  if (container) {
    return container;
  }
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput("class_" + this.identifier + "_create", null, result);
  return result;
};

PCCVariableInfo = (function(_super) {
  __extends(PCCVariableInfo, _super);

  function PCCVariableInfo(node, name, type, isInternal) {
    this.isInternal = isInternal != null ? isInternal : false;
    PCCVariableInfo.__super__.constructor.call(this, node, name, type);
  }

  PCCVariableInfo.prototype.getIdentifier = function() {
    return "" + (this.isInternal ? "#" : "") + (this.getName());
  };

  PCCVariableInfo.prototype.getSuggestedContainerName = function() {
    return this.getName() + (this.isInternal ? "H" : "L");
  };

  return PCCVariableInfo;

})(PC.Variable);

PCCVariableInfo.getNameForInternalVariableWithName = function(name) {
  return "#" + name;
};

PC.Variable.prototype.getSuggestedContainerName = function() {
  return this.getName() + "L";
};

PC.Variable.prototype.getCCSType = function() {
  return this.type.getCCSType();
};

PC.Variable.prototype.compileDefaultValue = function(compiler) {
  if (this.node) {
    return this.node.compileDefaultValue(compiler);
  } else {
    return this.type.createContainer(compiler);
  }
};

PCCVariableInfo.prototype.getCCSType = function() {
  if (this.type || !this.isInternal) {
    return PCCVariableInfo.__super__.getCCSType.apply(this, arguments);
  } else {
    return PCCType.INT;
  }
};

PCCVariable = (function(_super) {
  __extends(PCCVariable, _super);

  function PCCVariable() {
    _ref1 = PCCVariable.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  PCCVariable.prototype.getContainer = function(compiler) {
    throw new Error("Not implemented!");
  };

  PCCVariable.prototype.setContainer = function(compiler, container) {
    throw new Error("Not implemented");
  };

  return PCCVariable;

})(PCCVariableInfo);

PCCGlobalVariable = (function(_super) {
  __extends(PCCGlobalVariable, _super);

  function PCCGlobalVariable() {
    _ref2 = PCCGlobalVariable.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  PCCGlobalVariable.prototype.accessorChannel = function(set) {
    return "env_global_" + (set ? "set" : "get") + "_" + (this.getName());
  };

  PCCGlobalVariable.prototype.getContainer = function(compiler) {
    var result;
    result = compiler.getFreshContainer(this.type.getCCSType());
    compiler.emitInput(this.accessorChannel(false), null, result);
    return result;
  };

  PCCGlobalVariable.prototype.setContainer = function(compiler, container) {
    compiler.emitOutput(this.accessorChannel(true), null, container);
    return null;
  };

  PCCGlobalVariable.prototype.emitAccessors = function(compiler, variables, instance) {
    var c, containers, control, local, v;
    if (instance == null) {
      instance = null;
    }
    local = compiler.getVariableWithName(this.getIdentifier());
    containers = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(v.getContainer(compiler));
      }
      return _results;
    })();
    control = compiler.emitChoice();
    c = local.getContainer(compiler);
    compiler.emitOutput(this.accessorChannel(false), instance, c);
    compiler.emitProcessApplication(this.getEnvProcessName(), containers);
    control.setBranchFinished();
    compiler.emitInput(this.accessorChannel(true), instance, c);
    compiler.emitProcessApplication(this.getEnvProcessName(), containers);
    return control.setBranchFinished();
  };

  PCCGlobalVariable.prototype.emitConstructor = function(compiler) {
    var container;
    compiler.beginProcessGroup(new PCCGroupable(this.getEnvProcessName()), [this]);
    this.emitAccessors(compiler, [compiler.getVariableWithName(this.getName())]);
    compiler.endProcessGroup();
    compiler.beginProcessGroup(this);
    container = this.compileDefaultValue(compiler);
    compiler.emitProcessApplication(this.getEnvProcessName(), [container]);
    compiler.endProcessGroup();
    return compiler.emitSystemProcessApplication(this.getProcessName(), []);
  };

  PCCGlobalVariable.prototype.getProcessName = function() {
    return "Env_global_" + (this.getName()) + "_cons";
  };

  PCCGlobalVariable.prototype.getEnvProcessName = function() {
    return "Env_global_" + (this.getName());
  };

  return PCCGlobalVariable;

})(PCCVariable);

PCCField = (function(_super) {
  __extends(PCCField, _super);

  function PCCField() {
    _ref3 = PCCField.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  PCCField.prototype.accessorChannel = function(set) {
    return "env_class_" + (this.parent.getName()) + "_" + (set ? "set" : "get") + "_" + (this.getName());
  };

  PCCField.prototype.getContainer = function(compiler) {
    var result;
    if (this.getIdentifier() === "#guard") {
      result = compiler.getFreshContainer(PCCType.INT);
      compiler.emitInput("env_class_get_guard", compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    } else {
      result = compiler.getFreshContainer(this.type.getCCSType());
      compiler.emitInput(this.accessorChannel(false), compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    }
    return result;
  };

  PCCField.prototype.setContainer = function(compiler, container) {
    compiler.emitOutput(this.accessorChannel(true), compiler.getVariableWithName("i", null, true).getContainer(compiler), container);
    return null;
  };

  PCCField.prototype.getEnvProcessName = function() {
    return "Env_class_" + (this.parent.getName());
  };

  return PCCField;

})(PCCGlobalVariable);

PCCInternalReadOnlyField = (function(_super) {
  __extends(PCCInternalReadOnlyField, _super);

  function PCCInternalReadOnlyField() {
    _ref4 = PCCInternalReadOnlyField.__super__.constructor.apply(this, arguments);
    return _ref4;
  }

  PCCInternalReadOnlyField.prototype.emitAccessors = function(compiler, variables, instance) {
    var c, containers, local, v;
    local = compiler.getVariableWithName(this.getIdentifier());
    containers = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(v.getContainer(compiler));
      }
      return _results;
    })();
    c = local.getContainer(compiler);
    compiler.emitOutput("env_class_guard", instance, c);
    return compiler.emitProcessApplication(this.getEnvProcessName(), containers);
  };

  PCCInternalReadOnlyField.prototype.getContainer = function(compiler) {
    var result;
    result = compiler.getFreshContainer(PCCType.INT);
    compiler.emitInput("env_class_guard", compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    return result;
  };

  PCCInternalReadOnlyField.prototype.setContainer = function() {
    throw new Error("Setting container for read only variable!");
  };

  return PCCInternalReadOnlyField;

})(PCCField);

PCCCondition = (function(_super) {
  __extends(PCCCondition, _super);

  function PCCCondition(name, expressionNode) {
    this.expressionNode = expressionNode;
    PCCCondition.__super__.constructor.call(this, name, new PC.Type(PC.Type.CONDITION));
  }

  return PCCCondition;

})(PCCField);

PCCLocalVariable = (function(_super) {
  __extends(PCCLocalVariable, _super);

  function PCCLocalVariable() {
    _ref5 = PCCLocalVariable.__super__.constructor.apply(this, arguments);
    return _ref5;
  }

  PCCLocalVariable.prototype.getContainer = function(compiler) {
    return compiler.getProcessFrame().getContainerForVariable(this.getIdentifier());
  };

  PCCLocalVariable.prototype.setContainer = function(compiler, container) {
    return compiler.getProcessFrame().assignContainerToVariable(this.getIdentifier(), container);
  };

  return PCCLocalVariable;

})(PCCVariable);

PCCProgramController = (function(_super) {
  __extends(PCCProgramController, _super);

  function PCCProgramController() {
    PCCProgramController.__super__.constructor.apply(this, arguments);
    this.root = new PCCGlobal();
    this.agents = {};
    this._envStack = this.root;
  }

  PCCProgramController.prototype.processNewClass = function(node, classType) {
    var tnode;
    tnode = new PCCClass(node, classType);
    return this._processNewClass(tnode);
  };

  PCCProgramController.prototype.beginNewProcedure = function(node, procedureName, returnType, args) {
    var tnode;
    tnode = new PCCProcedure(node, procedureName, returnType, args);
    return this._beginNewProcedure(tnode);
  };

  PCCProgramController.prototype.processNewVariable = function(variable) {
    var tnode, varClass;
    varClass = this._envStack.getVariableClass();
    tnode = new varClass(variable.node, variable.getName(), variable.type);
    return this._processNewVariable(tnode);
  };

  PCCProgramController.prototype.processProcedureAsAgent = function(procedure) {
    return this.agents[procedure.getName()] = procedure;
  };

  PCCProgramController.prototype.getAgents = function() {
    var p, proc, res;
    res = [];
    for (p in this.agents) {
      proc = this.agents[p];
      if (proc instanceof PC.Procedure) {
        res.push(proc);
      }
    }
    return res;
  };

  PCCProgramController.prototype.getUsedTypes = function() {
    var res;
    res = {
      arrays: {},
      channels: {}
    };
    this.root.getUsedTypes(res);
    return res;
  };

  return PCCProgramController;

})(PC.EnvironmentController);

PC.EnvironmentNode.prototype.getUsedTypes = function(res) {
  var c, _i, _len, _ref6;
  _ref6 = this.children;
  for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
    c = _ref6[_i];
    c.getUsedTypes(res);
  }
  return null;
};

PC.Variable.prototype.getUsedTypes = function(res) {
  return this.type.getUsedTypes(res);
};

PC.Type.prototype.getUsedTypes = function() {
  return null;
};

PC.ArrayType.prototype.getUsedTypes = function(res) {
  res.arrays[this.capacity] = true;
  this.elementsType.getUsedTypes(res);
  return null;
};

PC.ChannelType.prototype.getUsedTypes = function(res) {
  res.channels[this.getApplicableCapacity()] = true;
  return null;
};

PC.Node.prototype.collectAgents = function(env) {
  var c, _i, _len, _ref6, _results;
  _ref6 = this.children;
  _results = [];
  for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
    c = _ref6[_i];
    _results.push(c.collectAgents(env));
  }
  return _results;
};

_t = PC.Monitor;

_t.prototype.collectAgents = function(env) {
  env.beginClass(this.name);
  _t.__super__.collectAgents.apply(this, arguments);
  return env.endClass();
};

_t = PC.Struct;

_t.prototype.collectAgents = function(env) {
  env.beginClass(this.name);
  _t.__super__.collectAgents.apply(this, arguments);
  return env.endClass();
};

_t = PC.ProcedureDecl;

_t.prototype.collectAgents = function(env) {
  env.beginProcedure(this.name);
  _t.__super__.collectAgents.apply(this, arguments);
  return env.endProcedure();
};

PC.StartExpression.prototype.collectAgents = function(env) {
  return env.processProcedureAsAgent(this.children[0].getProcedure(env));
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	Manages different kinds of containers. Containers basically wrap CCS Expressions.
*/


PCCContainer = (function() {
  function PCCContainer(ccsType) {
    this.ccsType = ccsType;
  }

  PCCContainer.prototype.isReadonly = function() {
    throw new Error("Abstract");
  };

  PCCContainer.prototype.ccsTree = function() {
    throw new Error("Abstract");
  };

  PCCContainer.prototype.isEqual = function(container) {
    throw new Error("Abstract");
  };

  return PCCContainer;

})();

PCCConstantContainer = (function(_super) {
  __extends(PCCConstantContainer, _super);

  function PCCConstantContainer(value) {
    this.value = value;
    if (typeof this.value === "boolean") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (typeof this.value === "number") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (typeof this.value === "string") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.STRING);
    } else {
      throw new Error("Unknown type");
    }
  }

  PCCConstantContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCConstantContainer.prototype.ccsTree = function() {
    return new CCS.ConstantExpression(this.value);
  };

  PCCConstantContainer.prototype.isEqual = function(container) {
    return container instanceof PCCConstantContainer && container.value === this.value;
  };

  return PCCConstantContainer;

})(PCCContainer);

PCCVariableContainer = (function(_super) {
  __extends(PCCVariableContainer, _super);

  function PCCVariableContainer(identifier, ccsType) {
    this.identifier = identifier;
    PCCVariableContainer.__super__.constructor.call(this, ccsType);
  }

  PCCVariableContainer.prototype.isReadonly = function() {
    return false;
  };

  PCCVariableContainer.prototype.ccsTree = function() {
    return new CCS.VariableExpression(this.identifier);
  };

  PCCVariableContainer.prototype.isEqual = function(container) {
    return container instanceof PCCVariableContainer && container.identifier === this.identifier;
  };

  return PCCVariableContainer;

})(PCCContainer);

PCCComposedContainer = (function(_super) {
  __extends(PCCComposedContainer, _super);

  function PCCComposedContainer(ccsType) {
    PCCComposedContainer.__super__.constructor.call(this, ccsType);
  }

  return PCCComposedContainer;

})(PCCContainer);

PCCBinaryContainer = (function(_super) {
  __extends(PCCBinaryContainer, _super);

  function PCCBinaryContainer(leftContainer, rightContainer, operator) {
    this.leftContainer = leftContainer;
    this.rightContainer = rightContainer;
    this.operator = operator;
    if (this.operator === "+" || this.operator === "^") {
      if (this.leftContainer.ccsType.isString() || this.rightContainer.ccsType.isString() || this.operator === "^") {
        this.exp = new CCS.ConcatenatingExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree());
        PCCBinaryContainer.__super__.constructor.call(this, PCCType.STRING);
      } else {
        this.exp = new CCS.AdditiveExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
        PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
      }
    } else if (this.operator === "-") {
      this.exp = new CCS.AdditiveExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator === "*" || this.operator === "/" || this.operator === "%") {
      this.exp = new CCS.MultiplicativeExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator === "<" || this.operator === "<=" || this.operator === ">" || this.operator === ">=") {
      this.exp = new CCS.RelationalExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "==" || this.operator === "!=") {
      this.exp = new CCS.EqualityExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "&&") {
      throw new Error("Not available in CCS");
    } else if (this.operator === "||") {
      throw new Error("Not available in CCS");
    } else {
      throw new Error("Unknown operator");
    }
  }

  PCCBinaryContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCBinaryContainer.prototype.ccsTree = function() {
    return this.exp;
  };

  PCCBinaryContainer.prototype.isEqual = function(container) {
    return container instanceof PCCBinaryContainer && container.operator === this.operator && container.leftContainer.isEqual(this.leftContainer) && container.rightContainer.isEqual(this.rightContainer);
  };

  return PCCBinaryContainer;

})(PCCComposedContainer);

PCCUnaryContainer = (function(_super) {
  __extends(PCCUnaryContainer, _super);

  function PCCUnaryContainer(operator, container) {
    this.operator = operator;
    this.container = container;
    if (this.operator === "!") {
      this.exp = new CCS.EqualityExpression(this.container.ccsTree(), new CCSConstantExpression(false), "==");
      PCCUnaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "-") {
      this.exp = new CCS.AdditiveExpression(new CCSConstantExpression(0), this.container.ccsTree(), "-");
      PCCUnaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator !== "+") {
      throw new Error("Unknown operator");
    }
  }

  PCCUnaryContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCUnaryContainer.prototype.ccsTree = function() {
    return this.exp;
  };

  PCCUnaryContainer.prototype.isEqual = function(container) {
    return container instanceof PCCConstantContainer && container.operator === this.operator && container.container.isEqual(this.container);
  };

  return PCCUnaryContainer;

})(PCCComposedContainer);

/*
PCCContainer.RETURN = -> new PCCVariableContainer("i_r")
PCCContainer.INSTANCE = -> new PCCVariableContainer("i_i")
PCCContainer.GUARD = -> new PCCVariableContainer("i_g")
*/


/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


PCCStackElement = (function() {
  function PCCStackElement() {
    this.parent = null;
  }

  PCCStackElement.prototype.getResult = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.getNext = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.setNext = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.removeNext = function(next) {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.getTopElement = function() {
    var next;
    next = this.getNext();
    if (next === null) {
      return this;
    } else {
      return next.getTopElement();
    }
  };

  PCCStackElement.prototype.getCurrentProcessFrame = function() {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.getCurrentProcessFrame() : void 0;
  };

  PCCStackElement.prototype.getCurrentControlElement = function() {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.getCurrentControlElement() : void 0;
  };

  PCCStackElement.prototype.getResults = function() {
    throw new Error("Not implemented");
  };

  PCCStackElement.prototype.removeFromStack = function() {
    var _ref6;
    this.getStack().setTopElement(this.parent);
    if ((_ref6 = this.parent) != null) {
      _ref6.removeNext(this);
    }
    return this.getResults();
  };

  PCCStackElement.prototype.isCompletedProcess = function() {
    return false;
  };

  PCCStackElement.prototype.createCalculusNode = function() {
    var args, cons, res;
    cons = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    res = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(cons, args, function(){});
    res.pseucoNode = this.pseucoNode;
    if (this.pseucoNode) {
      this.pseucoNode.addCalculusComponent(res);
    }
    return res;
  };

  PCCStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.compilerGetVariable(compiler, identifier) : void 0;
  };

  PCCStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.compilerGetProcedure(compiler, identifier) : void 0;
  };

  PCCStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var _ref6;
    return (_ref6 = this.parent) != null ? _ref6.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context) : void 0;
  };

  return PCCStackElement;

})();

PCCUnaryStackElement = (function(_super) {
  __extends(PCCUnaryStackElement, _super);

  function PCCUnaryStackElement() {
    this.next = null;
    PCCUnaryStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCUnaryStackElement.prototype.getResults = function() {
    if (this.next === null) {
      return new PCCStackResultContainer();
    } else {
      return this.next.getResults();
    }
  };

  PCCUnaryStackElement.prototype.getNext = function() {
    return this.next;
  };

  PCCUnaryStackElement.prototype.setNext = function(next) {
    if (this.next !== null) {
      throw new Error("Can't set next twice!");
    }
    next.parent = this;
    return this.next = next;
  };

  PCCUnaryStackElement.prototype.removeNext = function(next) {
    if (this.next !== next) {
      throw new Error("Unknown next");
    }
    next.parent = null;
    return this.next = null;
  };

  return PCCUnaryStackElement;

})(PCCStackElement);

PCCBinaryStackElement = (function(_super) {
  __extends(PCCBinaryStackElement, _super);

  function PCCBinaryStackElement() {
    this.leftStack = null;
    this.rightStack = null;
    this.topStack = null;
    this.target = 0;
    PCCBinaryStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCBinaryStackElement.prototype.getResults = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCBinaryStackElement.prototype.getNext = function() {
    if (this.target === PCCBinaryTarget.LEFT) {
      return this.leftStack;
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      return this.rightStack;
    } else {
      return this.topStack;
    }
  };

  PCCBinaryStackElement.prototype.setNext = function(next) {
    if (next) {
      next.parent = this;
    }
    if (this.target === PCCBinaryTarget.LEFT) {
      if (this.leftStack) {
        throw new Error("Can't set next twice!");
      }
      return this.leftStack = next;
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      if (this.rightStack) {
        throw new Error("Can't set next twice!");
      }
      return this.rightStack = next;
    } else {
      if (this.topStack) {
        throw new Error("Can't set next twice!");
      }
      return this.topStack = next;
    }
  };

  PCCBinaryStackElement.prototype.removeNext = function(next) {
    if (this.next !== this.getNext()) {
      throw new Error("Unknown next");
    }
    return this.setNext(null);
  };

  PCCBinaryStackElement.prototype.setTarget = function(target) {
    if (target < 0 || target > 2) {
      raise(new Error("Illegal target!"));
    }
    if (target === PCCBinaryTarget.TOP && this.topStack) {
      raise(new Error("Left and right target are not allowed once top was modified!"));
    }
    this.target = target;
    this.getStack().setTopElement(this.getTopElement());
    return this.parent.updateBinaryTargets(this);
  };

  PCCBinaryStackElement.prototype.setBranchFinished = function() {
    if (this.target === PCCBinaryTarget.TOP) {
      throw new Error("All branches are already finished!");
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      this.setTarget(PCCBinaryTarget.TOP);
    } else if (this.target === PCCBinaryTarget.LEFT) {
      this.setTarget(PCCBinaryTarget.RIGHT);
    } else {
      throw new Error("Unknown target is currently specified!");
    }
    return null;
  };

  PCCBinaryStackElement.prototype.updateBinaryTargets = function(destination) {
    if (destination === this.leftStack) {
      return this.target = PCCBinaryTarget.LEFT;
    } else if (destination === this.rightStack) {
      return this.target = PCCBinaryTarget.RIGHT;
    } else if (destination === this.topStack) {
      return this.target = PCCBinaryTarget.TOP;
    } else {
      throw new Error("Unknown destination!");
    }
  };

  return PCCBinaryStackElement;

})(PCCStackElement);

PCCBinaryTarget = {};

PCCBinaryTarget.LEFT = 0;

PCCBinaryTarget.RIGHT = 1;

PCCBinaryTarget.TOP = 2;

PCCStackElement.prototype.updateBinaryTargets = function(destination) {
  var _ref6;
  return (_ref6 = this.parent) != null ? _ref6.updateBinaryTargets(this) : void 0;
};

PCCStopStackElement = (function(_super) {
  __extends(PCCStopStackElement, _super);

  function PCCStopStackElement() {
    _ref6 = PCCStopStackElement.__super__.constructor.apply(this, arguments);
    return _ref6;
  }

  PCCStopStackElement.prototype.getResults = function() {
    var more;
    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Stop));
    return more;
  };

  PCCStopStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCStopStackElement;

})(PCCUnaryStackElement);

PCCExitStackElement = (function(_super) {
  __extends(PCCExitStackElement, _super);

  function PCCExitStackElement() {
    _ref7 = PCCExitStackElement.__super__.constructor.apply(this, arguments);
    return _ref7;
  }

  PCCExitStackElement.prototype.getResults = function() {
    var more;
    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Exit));
    return more;
  };

  PCCExitStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCExitStackElement;

})(PCCUnaryStackElement);

PCCPrefixStackElement = (function(_super) {
  __extends(PCCPrefixStackElement, _super);

  function PCCPrefixStackElement(channel, specificChannel) {
    this.channel = channel;
    this.specificChannel = specificChannel;
    PCCPrefixStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCPrefixStackElement.prototype._getChannel = function() {
    return new CCS.Channel(this.channel, this.specificChannel ? this.specificChannel.ccsTree() : null);
  };

  PCCPrefixStackElement.prototype._getAction = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCPrefixStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Prefix, this._getAction(), pRes.data));
    return container;
  };

  PCCPrefixStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCPrefixStackElement;

})(PCCUnaryStackElement);

PCCInputStackElement = (function(_super) {
  __extends(PCCInputStackElement, _super);

  function PCCInputStackElement(channel, specificChannel, container) {
    this.container = container;
    PCCInputStackElement.__super__.constructor.call(this, channel, specificChannel);
  }

  PCCInputStackElement.prototype._getAction = function() {
    return this.createCalculusNode(CCS.Input, this._getChannel(), this.container ? this.container.identifier : null);
  };

  return PCCInputStackElement;

})(PCCPrefixStackElement);

PCCOutputStackElement = (function(_super) {
  __extends(PCCOutputStackElement, _super);

  function PCCOutputStackElement(channel, sepcificChannel, container) {
    this.container = container;
    PCCOutputStackElement.__super__.constructor.call(this, channel, sepcificChannel);
  }

  PCCOutputStackElement.prototype._getAction = function() {
    return this.createCalculusNode(CCS.Output, this._getChannel(), this.container ? this.container.ccsTree() : null);
  };

  return PCCOutputStackElement;

})(PCCPrefixStackElement);

PCCConditionStackElement = (function(_super) {
  __extends(PCCConditionStackElement, _super);

  function PCCConditionStackElement(conditionContainer) {
    this.conditionContainer = conditionContainer;
    PCCConditionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCConditionStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Condition, this.conditionContainer.ccsTree(), pRes.data));
    return container;
  };

  PCCConditionStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCConditionStackElement;

})(PCCUnaryStackElement);

PCCRestrictionStackElement = (function(_super) {
  __extends(PCCRestrictionStackElement, _super);

  function PCCRestrictionStackElement(restrictedChannels) {
    this.restrictedChannels = restrictedChannels;
    PCCRestrictionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCRestrictionStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.Restriction, pRes.data, this.restrictedChannels));
    return container;
  };

  PCCRestrictionStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCRestrictionStackElement;

})(PCCUnaryStackElement);

PCCApplicationStackElement = (function(_super) {
  __extends(PCCApplicationStackElement, _super);

  function PCCApplicationStackElement(processName, argContainers) {
    this.processName = processName;
    if (argContainers === void 0) {
      argContainers = [];
    }
    if (argContainers) {
      this.argContainers = argContainers.slice(0);
    }
    PCCApplicationStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCApplicationStackElement.prototype.getResults = function() {
    var c, more, values;
    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    values = (function() {
      var _i, _len, _ref8, _results;
      _ref8 = this.argContainers;
      _results = [];
      for (_i = 0, _len = _ref8.length; _i < _len; _i++) {
        c = _ref8[_i];
        _results.push(c.ccsTree());
      }
      return _results;
    }).call(this);
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, this.createCalculusNode(CCS.ProcessApplication, this.processName, values));
    return more;
  };

  PCCApplicationStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCApplicationStackElement;

})(PCCUnaryStackElement);

PCCApplicationPlaceholderStackElement = (function(_super) {
  __extends(PCCApplicationPlaceholderStackElement, _super);

  function PCCApplicationPlaceholderStackElement(frame) {
    this.frame = frame;
    PCCApplicationPlaceholderStackElement.__super__.constructor.call(this, null, null);
  }

  PCCApplicationPlaceholderStackElement.prototype.set = function(processName, argContainers) {
    if (argContainers == null) {
      argContainers = [];
    }
    if (this.processName || this.argContainers) {
      throw new Error("Placeholder values can't be set twice!");
    }
    this.processName = processName;
    this.argContainers = argContainers.slice(0);
    return null;
  };

  PCCApplicationPlaceholderStackElement.prototype.getResults = function() {
    if (!this.processName || !this.argContainers) {
      throw new Error("Placeholder without values!");
    }
    return PCCApplicationPlaceholderStackElement.__super__.getResults.apply(this, arguments);
  };

  return PCCApplicationPlaceholderStackElement;

})(PCCApplicationStackElement);

PCCBinaryCCSStackElement = (function(_super) {
  __extends(PCCBinaryCCSStackElement, _super);

  function PCCBinaryCCSStackElement() {
    _ref8 = PCCBinaryCCSStackElement.__super__.constructor.apply(this, arguments);
    return _ref8;
  }

  PCCBinaryCCSStackElement.prototype._createCCSProcess = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCBinaryCCSStackElement.prototype.getResults = function() {
    var left, leftContainer, more, right, rightContainer;
    more = this.topStack ? this.topStack.getResults() : new PCCStackResultContainer();
    leftContainer = this.leftStack.getResults();
    left = leftContainer.getResult();
    if (left.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    rightContainer = this.rightStack.getResults();
    right = rightContainer.getResult();
    if (right.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    rightContainer.removeResult();
    leftContainer.appendContainer(rightContainer);
    leftContainer.appendContainer(more);
    leftContainer.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this._createCCSProcess(left.data, right.data));
    return leftContainer;
  };

  PCCBinaryCCSStackElement.prototype.isCompletedProcess = function() {
    if (this.leftStack && this.rightStack) {
      return this.leftStack.isCompletedProcess() && this.rightStack.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCBinaryCCSStackElement;

})(PCCBinaryStackElement);

PCCChoiceStackElement = (function(_super) {
  __extends(PCCChoiceStackElement, _super);

  function PCCChoiceStackElement() {
    _ref9 = PCCChoiceStackElement.__super__.constructor.apply(this, arguments);
    return _ref9;
  }

  PCCChoiceStackElement.prototype._createCCSProcess = function(left, right) {
    return this.createCalculusNode(CCS.Choice, left, right);
  };

  return PCCChoiceStackElement;

})(PCCBinaryCCSStackElement);

PCCParallelStackElement = (function(_super) {
  __extends(PCCParallelStackElement, _super);

  function PCCParallelStackElement() {
    _ref10 = PCCParallelStackElement.__super__.constructor.apply(this, arguments);
    return _ref10;
  }

  PCCParallelStackElement.prototype._createCCSProcess = function(left, right) {
    return this.createCalculusNode(CCS.Parallel, left, right);
  };

  return PCCParallelStackElement;

})(PCCBinaryCCSStackElement);

PCCSequenceStackElement = (function(_super) {
  __extends(PCCSequenceStackElement, _super);

  function PCCSequenceStackElement() {
    _ref11 = PCCSequenceStackElement.__super__.constructor.apply(this, arguments);
    return _ref11;
  }

  PCCSequenceStackElement.prototype._createCCSProcess = function(left, right) {
    return this.createCalculusNode(CCS.Sequence, left, right);
  };

  return PCCSequenceStackElement;

})(PCCBinaryCCSStackElement);

PCCSystemProcessStackElement = (function(_super) {
  __extends(PCCSystemProcessStackElement, _super);

  function PCCSystemProcessStackElement() {
    _ref12 = PCCSystemProcessStackElement.__super__.constructor.apply(this, arguments);
    return _ref12;
  }

  PCCSystemProcessStackElement.prototype.getResults = function() {
    var container, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    return pRes;
  };

  return PCCSystemProcessStackElement;

})(PCCUnaryStackElement);

PCCProcessDefinitionStackElement = (function(_super) {
  __extends(PCCProcessDefinitionStackElement, _super);

  function PCCProcessDefinitionStackElement(processName, argContainers) {
    this.processName = processName;
    if (argContainers == null) {
      argContainers = [];
    }
    this.argContainers = argContainers.slice(0);
    PCCProcessDefinitionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcessDefinitionStackElement.prototype.getResults = function() {
    var argNames, c, container, def, pRes;
    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    argNames = (function() {
      var _i, _len, _ref13, _results;
      _ref13 = this.argContainers;
      _results = [];
      for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
        c = _ref13[_i];
        _results.push(c.identifier);
      }
      return _results;
    }).call(this);
    def = this.createCalculusNode(CCS.ProcessDefinition, this.processName, pRes.data, argNames);
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS_DEFINITION, def);
    return container;
  };

  return PCCProcessDefinitionStackElement;

})(PCCUnaryStackElement);

PCCProcessFrameStackElement = (function(_super) {
  __extends(PCCProcessFrameStackElement, _super);

  function PCCProcessFrameStackElement(frame) {
    this.frame = frame;
    PCCProcessFrameStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcessFrameStackElement.prototype.getCurrentProcessFrame = function() {
    return this.frame;
  };

  PCCProcessFrameStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;
    result = this.frame.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;
    result = this.frame.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;
    result = this.frame.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCProcessFrameStackElement;

})(PCCUnaryStackElement);

PCCClassStackElement = (function(_super) {
  __extends(PCCClassStackElement, _super);

  function PCCClassStackElement(classInfo) {
    this.classInfo = classInfo;
    PCCClassStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCClassStackElement.prototype.getCurrentControlElement = function() {
    return this.classInfo;
  };

  PCCClassStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;
    result = this.classInfo.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCClassStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;
    result = this.classInfo.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCClassStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;
    result = this.classInfo.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCClassStackElement;

})(PCCUnaryStackElement);

PCCGlobalStackElement = (function(_super) {
  __extends(PCCGlobalStackElement, _super);

  function PCCGlobalStackElement(global) {
    this.global = global;
    PCCGlobalStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCGlobalStackElement.prototype.getCurrentControlElement = function() {
    return this.global;
  };

  PCCGlobalStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;
    result = this.global.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCGlobalStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;
    result = this.global.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCGlobalStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;
    result = this.global.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCGlobalStackElement;

})(PCCUnaryStackElement);

PCCProcedureStackElement = (function(_super) {
  __extends(PCCProcedureStackElement, _super);

  function PCCProcedureStackElement(procedure) {
    this.procedure = procedure;
    PCCProcedureStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcedureStackElement.prototype.getCurrentControlElement = function() {
    return this.procedure;
  };

  return PCCProcedureStackElement;

})(PCCUnaryStackElement);

PCCCompilerStack = (function() {
  function PCCCompilerStack(initialElement) {
    this.topElement = initialElement;
    this.topElement.__PCCCompilerStack = this;
    this.topElement.getStack = function() {
      return this.__PCCCompilerStack;
    };
  }

  PCCCompilerStack.prototype.setTopElement = function(e) {
    return this.topElement = e;
  };

  PCCCompilerStack.prototype.getCurrentProcessFrame = function() {
    return this.topElement.getCurrentProcessFrame();
  };

  PCCCompilerStack.prototype.getCurrentControlElement = function() {
    return this.topElement.getCurrentControlElement();
  };

  PCCCompilerStack.prototype.pushElement = function(e) {
    this.topElement.setNext(e);
    return this.topElement = e;
  };

  PCCCompilerStack.prototype.isCurrentProcessCompleted = function() {
    return this.topElement.isCompletedProcess();
  };

  PCCCompilerStack.prototype.compilerGetVariable = function(compiler, identifier) {
    var _ref13;
    return (_ref13 = this.topElement) != null ? _ref13.compilerGetVariable(compiler, identifier) : void 0;
  };

  PCCCompilerStack.prototype.compilerGetProcedure = function(compiler, identifier) {
    var _ref13;
    return (_ref13 = this.topElement) != null ? _ref13.compilerGetProcedure(compiler, identifier) : void 0;
  };

  PCCCompilerStack.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var _ref13;
    return (_ref13 = this.topElement) != null ? _ref13.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context) : void 0;
  };

  return PCCCompilerStack;

})();

PCCStackElement.prototype.getStack = function() {
  return this.parent.getStack();
};

PCCStackResult = (function() {
  function PCCStackResult(type, data) {
    this.type = type;
    this.data = data;
  }

  return PCCStackResult;

})();

PCCStackResultContainer = (function() {
  function PCCStackResultContainer() {
    this.results = [];
  }

  PCCStackResultContainer.prototype.addResult = function(type, data) {
    return this.results.unshift(new PCCStackResult(type, data));
  };

  PCCStackResultContainer.prototype.replaceResult = function(type, data) {
    return this.results[0] = new PCCStackResult(type, data);
  };

  PCCStackResultContainer.prototype.getResult = function() {
    return this.results[0];
  };

  PCCStackResultContainer.prototype.removeResult = function() {
    return this.results.shift();
  };

  PCCStackResultContainer.prototype.appendContainer = function(container) {
    return this.results = this.results.concat(container.results);
  };

  return PCCStackResultContainer;

})();

PCCStackResult.TYPE_UNSPECIFIC = 0;

PCCStackResult.TYPE_CCSPROCESS = 1;

PCCStackResult.TYPE_CCSPROCESS_DEFINITION = 2;

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


PC.Node.prototype.compile = function(compiler) {
  throw new Error("Abstract method!");
};

PC.Node.prototype._childrenCompile = function(compiler) {
  var c, _i, _len, _ref13, _results;
  _ref13 = this.children;
  _results = [];
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    _results.push(compiler.compile(c));
  }
  return _results;
};

PC.Program.prototype.compile = function(compiler) {
  compiler.beginProgram();
  this._childrenCompile(compiler);
  return compiler.endProgram();
};

PC.MainAgent.prototype.compile = function(compiler) {
  compiler.beginMainAgent();
  this._childrenCompile(compiler);
  compiler.emitStop();
  return compiler.endMainAgent();
};

PC.ProcedureDecl.prototype.compile = function(compiler) {
  var guard, proc;
  compiler.beginProcedure(this.name);
  proc = compiler.getProcedureWithName(this.name);
  if (proc.isMonitorProcedure()) {
    guard = compiler.getVariableWithName("guard", null, true);
    compiler.emitOutput("lock", guard.getContainer(compiler));
  }
  compiler.compile(this.getBody());
  proc.emitExit(compiler);
  compiler.endProcedure();
  return [];
};

PC.FormalParameter.prototype.compile = function(compiler) {
  throw new Error("Not implemented!");
};

PC.Monitor.prototype.compile = function(compiler) {
  compiler.beginClass(this.name);
  this._childrenCompile(compiler);
  return compiler.endClass();
};

PC.Struct.prototype.compile = function(compiler) {
  compiler.beginClass(this.name);
  this._childrenCompile(compiler);
  return compiler.endClass();
};

PC.ConditionDecl.prototype.compile = function(compiler) {
  var context, variable;
  context = {
    target: this,
    compiler: compiler
  };
  variable = new PCCVariableInfo(this, this.name, new PC.Type(PC.Type.CONDITION));
  compiler.handleNewVariableWithDefaultValueCallback(variable);
  return [];
};

PC.ConditionDecl.prototype.compileDefaultValue = function(compiler) {
  var result;
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput("wait_create", null, result);
  return result;
};

PC.Decl.prototype.compile = function(compiler) {
  var type, vd, _i, _len, _ref13;
  type = this.children[0];
  _ref13 = this.getDeclarators();
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    vd = _ref13[_i];
    compiler.compile(vd);
  }
  return [];
};

PC.VariableDeclarator.prototype.compile = function(compiler) {
  var context, variable;
  context = {
    target: this,
    compiler: compiler
  };
  variable = new PCCVariableInfo(this, this.name, this.getTypeNode().getType(compiler).type);
  return compiler.handleNewVariableWithDefaultValueCallback(variable);
};

PC.VariableDeclarator.prototype.compileDefaultValue = function(compiler) {
  var type;
  type = this.getTypeNode().getType(compiler).type;
  if (this.getInitializer()) {
    return compiler.compile(this.getInitializer(), type);
  } else {
    return type.createContainer(compiler);
  }
};

PC.VariableInitializer.prototype.compile = function(compiler, type) {
  var c, cc;
  if (this.isArray()) {
    cc = (function() {
      var _i, _len, _ref13, _results;
      _ref13 = this.children;
      _results = [];
      for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
        c = _ref13[_i];
        _results.push(compiler.compile(c, type.elementsType));
      }
      return _results;
    }).call(this);
    return type.createContainer(compiler, cc);
  } else {
    return type.createContainer(compiler, compiler.compile(this.children[0]));
  }
};

PC.Expression.prototype.compile = function(compiler) {
  throw new Error("Not implemented!");
};

PC.Expression.prototype.getValueForArrayAtIndex = function(compiler, instanceContainer, indexContainer) {
  var result;
  compiler.emitOutput("array_access", instanceContainer, indexContainer);
  result = compiler.getFreshContainer(instanceContainer.ccsType.getSubtype());
  compiler.emitInput("array_get", instanceContainer, result);
  return result;
};

PC.StartExpression.prototype.compile = function(compiler) {
  return this.children[0].compileSend(compiler);
};

PC.AssignExpression.prototype.compile = function(compiler) {
  var c;
  c = compiler.compile(this.getExpression());
  if (this.operator === "+=") {
    c = new PCCBinaryContainer(compiler.compile(this.getDestination()), c, "+");
  } else if (this.operator === "*=") {
    c = new PCCBinaryContainer(compiler.compile(this.getDestination()), c, "*");
  } else if (this.operator === "/=") {
    c = new PCCBinaryContainer(compiler.compile(this.getDestination()), c, "/");
  } else if (this.operator !== "=") {
    throw new Error("Unknown assign operator");
  }
  this.getDestination().assignContainer(compiler, c);
  return c;
};

PC.AssignDestination.prototype.compile = function(compiler) {
  var arrayIndexCount, i, res, v, _i;
  arrayIndexCount = this.children.length;
  v = compiler.getVariableWithName(this.identifier, null);
  res = v.getContainer(compiler);
  for (i = _i = 0; _i < arrayIndexCount; i = _i += 1) {
    res = this.getValueForArrayAtIndex(compiler, ai, compiler.compile(this.children[i]));
  }
  return res;
};

PC.AssignDestination.prototype.setValueForArrayAtIndex = function(compiler, instanceContainer, indexContainer, valueContainer) {
  compiler.emitOutput("array_access", instanceContainer, indexContainer);
  compiler.emitOutput("array_set", instanceContainer, valueContainer);
  return valueContainer;
};

PC.AssignDestination.prototype.assignContainer = function(compiler, c) {
  var ai, arrayIndexCount, i, v, _i, _ref13;
  arrayIndexCount = this.children.length;
  v = compiler.getVariableWithName(this.identifier, null);
  if (arrayIndexCount === 0) {
    return v.setContainer(compiler, c);
  } else {
    ai = v.getContainer(compiler);
    for (i = _i = 0, _ref13 = arrayIndexCount - 2; _i <= _ref13; i = _i += 1) {
      ai = this.getValueForArrayAtIndex(compiler, ai, compiler.compile(this.children[i]));
    }
    return this.setValueForArrayAtIndex(compiler, ai, compiler.compile(this.children[arrayIndexCount - 1]), c);
  }
};

PC.SendExpression.prototype.compile = function(compiler) {
  var c, control, p1, p2, v;
  c = compiler.compile(this.children[0]);
  v = compiler.compile(this.children[1]);
  if (this.children[0].getType(compiler).capacity <= 0) {
    control = compiler.emitChoice();
    compiler.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">="));
    compiler.emitOutput("put", c, v);
    p1 = compiler.emitProcessApplicationPlaceholder();
    control.setBranchFinished();
    compiler.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<"));
    compiler.emitOutput("receive", c, v);
    p2 = compiler.emitProcessApplicationPlaceholder();
    control.setBranchFinished();
    compiler.emitMergeOfProcessFramesOfPlaceholders([p1, p2]);
  } else {
    compiler.emitOutput("put", c, v);
  }
  return v;
};

PC.ConditionalExpression.prototype.compile = function(compiler) {
  var b, c, control, lp, rp;
  b = compiler.compile(this.children[0]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  c = compiler.compile(this.children[1]);
  compiler.protectContainer(c);
  lp = compiler.emitProcessApplicationPlaceholder();
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  c = compiler.compile(this.children[2]);
  compiler.protectContainer(c);
  rp = compiler.emitProcessApplicationPlaceholder();
  compiler.emitMergeOfProcessFramesOfPlaceholders([lp, rp]);
  return compiler.unprotectContainer();
};

PC.OrExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, "||");
};

PC.AndExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, "&&");
};

PC.EqualityExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.RelationalExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.AdditiveExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.MultiplicativeExpression.prototype.compile = function(compiler) {
  var left, right;
  left = compiler.compile(this.children[0]);
  compiler.protectContainer(left);
  right = compiler.compile(this.children[1]);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PC.UnaryExpression.prototype.compile = function(compiler) {
  return new PCCUnaryContainer(this.operator, compiler.compile(this.children[0]));
};

PC.PostfixExpression.prototype.compile = function(compiler) {
  var c, op;
  op = (function() {
    if (this.operator === "++") {
      return "+";
    } else if (this.operator === "--") {
      return "-";
    } else {
      throw new Error("Unknown postfix operator");
    }
  }).call(this);
  c = new PCCBinaryContainer(compiler.compile(this.children[0]), new PCCConstantContainer(1), op);
  this.children[0].assignContainer(compiler, c);
  return c;
};

PC.ReceiveExpression.prototype.compile = function(compiler) {
  var c, res;
  c = compiler.compile(this.children[0]);
  res = compiler.getFreshContainer(c.ccsType.getSubtype());
  compiler.emitInput("receive", c, res);
  return res;
};

PC.ProcedureCall.prototype.compile = function(compiler, instanceContainer, className) {
  var args, c, control, proc, res, _i, _j, _len, _len1, _ref13, _ref14;
  proc = compiler.getProcedureWithName(this.procedureName, className);
  if (instanceContainer) {
    compiler.protectContainer(instanceContainer);
  }
  _ref13 = this.children;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    compiler.protectContainer(compiler.compile(c));
  }
  control = compiler.emitSequence();
  args = [];
  _ref14 = this.children;
  for (_j = 0, _len1 = _ref14.length; _j < _len1; _j++) {
    c = _ref14[_j];
    args.unshift(compiler.unprotectContainer());
  }
  if (instanceContainer) {
    instanceContainer = compiler.unprotectContainer();
  }
  args = proc.getAllArgumentContainers(compiler, args, instanceContainer);
  compiler.emitProcessApplication(proc.getProcessName(), args);
  control.setBranchFinished();
  if (proc.returnType.kind !== PC.Type.VOID) {
    res = compiler.getFreshContainer(proc.returnType.getCCSType());
    compiler.emitInput("rreturn", null, res);
    return res;
  } else {
    return null;
  }
};

PC.ProcedureCall.prototype.compileSend = function(compiler, instanceContainer, className) {
  var args, c, proc, result, _i, _j, _k, _len, _len1, _len2, _ref13, _ref14;
  proc = compiler.getProcedureWithName(this.procedureName, className);
  if (instanceContainer) {
    compiler.protectContainer(instanceContainer);
  }
  _ref13 = this.children;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    compiler.protectContainer(compiler.compile(c));
  }
  args = [];
  _ref14 = this.children;
  for (_j = 0, _len1 = _ref14.length; _j < _len1; _j++) {
    c = _ref14[_j];
    args.unshift(compiler.unprotectContainer());
  }
  if (instanceContainer) {
    instanceContainer = compiler.unprotectContainer();
  }
  args = proc.getAllArgumentContainers(compiler, args, instanceContainer);
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput(proc.getAgentStarterChannel(), null, result);
  for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
    c = args[_k];
    compiler.emitOutput("start_set_arg", result, c);
  }
  return result;
};

PC.ClassCall.prototype.compile = function(compiler) {
  var className;
  className = this.children[0].getType(compiler).identifier;
  return compiler.compile(this.children[1], compiler.compile(this.children[0]), className);
};

PC.ClassCall.prototype.compileSend = function(compiler) {
  var className;
  className = this.children[0].getType(compiler).identifier;
  return this.children[1].compileSend(compiler, compiler.compile(this.children[0]), className);
};

PC.ArrayExpression.prototype.compile = function(compiler) {
  var a, res, t;
  a = compiler.compile(this.children[0]);
  compiler.protectContainer(a);
  t = compiler.compile(this.children[1]);
  a = compiler.unprotectContainer();
  compiler.emitOutput("array_access", a, t);
  res = compiler.getFreshContainer(this.children[0].getType(compiler).type);
  compiler.emitInput("array_get", a, res);
  return res;
};

PC.LiteralExpression.prototype.compile = function(compiler) {
  return new PCCConstantContainer(this.value);
};

PC.IdentifierExpression.prototype.compile = function(compiler) {
  var v;
  v = compiler.getVariableWithName(this.identifier, null);
  return v.getContainer(compiler);
};

PC.Statement.prototype.compile = function(compiler, loopEntry) {
  return compiler.compile(this.children[0], loopEntry);
};

PC.BreakStmt.prototype.compile = function(compiler, loopEntry) {
  return [compiler.emitProcessApplicationPlaceholder()];
};

PC.ContinueStmt.prototype.compile = function(compiler, loopEntry) {
  loopEntry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  return [];
};

PC.StmtBlock.prototype.compile = function(compiler, loopEntry) {
  var breaks, c, statusQuo;
  statusQuo = compiler.getProcessFrame();
  compiler.emitNewScope();
  breaks = ((function() {
    var _i, _len, _ref13, _results;
    _ref13 = this.children;
    _results = [];
    for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
      c = _ref13[_i];
      _results.push(compiler.compile(c, loopEntry));
    }
    return _results;
  }).call(this)).concatChildren();
  compiler.emitNewScope(statusQuo);
  return breaks;
};

PC.StmtExpression.prototype.compile = function(compiler, loopEntry) {
  compiler.compile(this.children[0]);
  return [];
};

PC.SelectStmt.prototype.compile = function(compiler, loopEntry) {
  var breaks, control, i, placeholders, _i, _ref13;
  if (this.children.length === 0) {
    return;
  }
  placeholders = [];
  breaks = [];
  for (i = _i = 0, _ref13 = this.children.length - 1; _i < _ref13; i = _i += 1) {
    control = compiler.emitChoice();
    breaks.concat(compiler.compile(this.children[i], loopEntry));
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
    control.setBranchFinished();
  }
  breaks.concat(compiler.compile(this.children[this.children.length - 1], loopEntry));
  placeholders.push(compiler.emitProcessApplicationPlaceholder());
  compiler.emitMergeOfProcessFramesOfPlaceholders(placeholders);
  return breaks;
};

PC.Case.prototype.compile = function(compiler, loopEntry) {
  var cond;
  cond = this.getCondition();
  if (cond) {
    compiler.compile(cond);
  }
  return compiler.compile(this.getExecution(), loopEntry);
};

PC.IfStmt.prototype.compile = function(compiler, loopEntry) {
  var b, breaks, control, placeholders;
  placeholders = [];
  b = compiler.compile(this.children[0]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  breaks = compiler.compile(this.children[1], loopEntry);
  if (!compiler.isCurrentProcessCompleted()) {
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
  }
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  if (this.children.length === 3) {
    breaks = breaks.concat(compiler.compile(this.children[2], loopEntry));
  }
  if (!compiler.isCurrentProcessCompleted()) {
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
  }
  control.setBranchFinished();
  compiler.emitMergeOfProcessFramesOfPlaceholders(placeholders);
  return breaks;
};

PC.WhileStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, _i, _len;
  entry = compiler.emitNextProcessFrame();
  b = compiler.compile(this.children[0]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  breaks = compiler.compile(this.children[1], entry);
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  out = compiler.emitNextProcessFrame();
  for (_i = 0, _len = breaks.length; _i < _len; _i++) {
    b = breaks[_i];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PC.DoStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, statusQuo, _i, _len;
  statusQuo = compiler.getProcessFrame();
  entry = compiler.emitNextProcessFrame();
  breaks = compiler.compile(this.children[0], entry);
  b = compiler.compile(this.children[1]);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  breaks.push(compiler.emitProcessApplicationPlaceholder());
  control.setBranchFinished();
  out = compiler.emitNextProcessFrame([statusQuo]);
  for (_i = 0, _len = breaks.length; _i < _len; _i++) {
    b = breaks[_i];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PC.ForStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, statusQuo, u, _i, _j, _len, _len1, _ref13;
  statusQuo = compiler.getProcessFrame();
  if (this.init) {
    compiler.emitNewScope();
    compiler.compile(this.init);
  }
  entry = compiler.emitNextProcessFrame();
  breaks = [];
  control = null;
  if (this.expression) {
    b = compiler.compile(this.expression);
    control = compiler.emitChoice();
    compiler.emitCondition(new PCCUnaryContainer("!", b));
    breaks.push(compiler.emitProcessApplicationPlaceholder());
    control.setBranchFinished();
    compiler.emitCondition(b);
  }
  breaks = breaks.concat(compiler.compile(this.body, entry));
  _ref13 = this.update;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    u = _ref13[_i];
    compiler.compile(u);
  }
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  if (control) {
    control.setBranchFinished();
  }
  out = compiler.emitNextProcessFrame([statusQuo]);
  for (_j = 0, _len1 = breaks.length; _j < _len1; _j++) {
    b = breaks[_j];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PC.ForInit.prototype.compile = function(compiler) {
  var c, _i, _len, _ref13;
  _ref13 = this.children;
  for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
    c = _ref13[_i];
    compiler.compile(c);
  }
  return [];
};

PC.ReturnStmt.prototype.compile = function(compiler, loopEntry) {
  var res;
  if (this.children.length === 1) {
    res = compiler.compile(this.children[0]);
    compiler.emitOutput("return", null, res);
  }
  compiler.getCurrentProcedure().emitExit(compiler);
  return [];
};

PC.PrimitiveStmt.prototype.compile = function(compiler, loopEntry) {
  var b, c, cond, control, entry, g, v, vars, _i, _len;
  switch (this.kind) {
    case PC.PrimitiveStmt.JOIN:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("join_register", c, null);
      compiler.emitOutput("join", c, null);
      break;
    case PC.PrimitiveStmt.LOCK:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("lock", c, null);
      break;
    case PC.PrimitiveStmt.UNLOCK:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("unlock", c, null);
      break;
    case PC.PrimitiveStmt.WAIT:
      if (!(this.children[0] instanceof PCIdentifierExpression)) {
        throw new Error("Unexpected expression!");
      }
      cond = compiler.getVariableWithName(this.children[0].identifier);
      entry = compiler.emitNextProcessFrame();
      b = compiler.compile(cond.node.getExpression());
      control = compiler.emitChoice();
      compiler.emitCondition(new PCCUnaryContainer("!", b));
      c = cond.getContainer(compiler);
      compiler.emitOutput("add", c, null);
      g = compiler.getVariableWithName("guard", null, true).getContainer(compiler);
      compiler.emitOutput("unlock", g, null);
      compiler.emitOutput("wait", c, null);
      compiler.emitOutput("lock", g, null);
      entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
      control.setBranchFinished();
      compiler.emitCondition(b);
      break;
    case PC.PrimitiveStmt.SIGNAL:
      c = compiler.compile(this.children[0], loopEntry);
      compiler.emitOutput("signal", c, null);
      break;
    case PC.PrimitiveStmt.SIGNAL_ALL:
      c = this.children.length > 0 ? compiler.compile(this.children[0], loopEntry) : null;
      vars = [];
      if (c) {
        if (!(this.children[0] instanceof PC.IdentifierExpression)) {
          throw new Error("Unexpected expression!");
        }
        vars = [compiler.getVariableWithName(this.children[0].identifier)];
      } else {
        vars = compiler.getCurrentClass().getAllConditions();
      }
      for (_i = 0, _len = vars.length; _i < _len; _i++) {
        v = vars[_i];
        c = v.getContainer(compiler);
        compiler.emitOutput("signal_all", c, null);
      }
  }
  return [];
};

PC.PrintStmt.prototype.compile = function(compiler, loopEntry) {
  var i, out, _i, _ref13;
  if (this.children.length === 0) {
    return;
  }
  out = compiler.compile(this.children[0]);
  for (i = _i = 1, _ref13 = this.children.length; _i < _ref13; i = _i += 1) {
    out = new PCCBinaryContainer(out, compiler.compile(this.children[i]), "+");
  }
  compiler.emitOutput("println", null, out);
  return [];
};

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


PCCExecutor = (function(_super) {
  __extends(PCCExecutor, _super);

  function PCCExecutor() {
    _ref13 = PCCExecutor.__super__.constructor.apply(this, arguments);
    return _ref13;
  }

  PCCExecutor.prototype._printStep = function(step) {
    if (step.action.channel.name === "println" && step.action.isOutputAction() && step.action.expression) {
      return this._output("" + (step.action.expression.evaluate()));
    }
  };

  PCCExecutor.prototype._printExecutionIntro = function() {
    return this._output("<i>Starting CCS execution.</i>");
  };

  PCCExecutor.prototype._printExecutionSummary = function() {
    var elapsedMS, perStep;
    elapsedMS = (new Date()).getTime() - this.executionStart.getTime();
    perStep = Math.round(elapsedMS / this.stepCount * 100) / 100;
    return this._output("<i>Finished CCS execution after performing " + this.stepCount + " steps in " + (elapsedMS / 1000) + " seconds (" + perStep + "ms per step).<\/i> \n-------------------------------------------------------------------------------------------");
  };

  return PCCExecutor;

})(CCS.Executor);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


exports = module && module.exports ? module.exports : {};

exports["Compiler"] = PCCCompiler;

exports["Constructor"] = PCCConstructor;

exports["StackElement"] = PCCStackElement;

exports["UnaryStackElement"] = PCCUnaryStackElement;

exports["BinaryStackElement"] = PCCBinaryStackElement;

exports["StopStackElement"] = PCCStopStackElement;

exports["ExitStackElement"] = PCCExitStackElement;

exports["PrefixStackElement"] = PCCPrefixStackElement;

exports["InputStackElement"] = PCCInputStackElement;

exports["OutputStackElement"] = PCCOutputStackElement;

exports["ConditionStackElement"] = PCCConditionStackElement;

exports["RestrictionStackElement"] = PCCRestrictionStackElement;

exports["ApplicationStackElement"] = PCCApplicationStackElement;

exports["ApplicationPlaceholderStackElement"] = PCCApplicationPlaceholderStackElement;

exports["BinaryCCSStackElement"] = PCCBinaryCCSStackElement;

exports["ChoiceStackElement"] = PCCChoiceStackElement;

exports["ParallelStackElement"] = PCCParallelStackElement;

exports["SequenceStackElement"] = PCCSequenceStackElement;

exports["SystemProcessStackElement"] = PCCSystemProcessStackElement;

exports["ProcessDefinitionStackElement"] = PCCProcessDefinitionStackElement;

exports["ProcessFrameStackElement"] = PCCProcessFrameStackElement;

exports["ClassStackElement"] = PCCClassStackElement;

exports["GlobalStackElement"] = PCCGlobalStackElement;

exports["ProcedureStackElement"] = PCCProcedureStackElement;

exports["CompilerStack"] = PCCCompilerStack;

exports["StackResult"] = PCCStackResult;

exports["StackResultContainer"] = PCCStackResultContainer;

exports["Container"] = PCCContainer;

exports["ConstantContainer"] = PCCConstantContainer;

exports["VariableContainer"] = PCCVariableContainer;

exports["ComposedContainer"] = PCCComposedContainer;

exports["BinaryContainer"] = PCCBinaryContainer;

exports["UnaryContainer"] = PCCUnaryContainer;

exports["Executor"] = PCCExecutor;

exports["PCCProcessFrame"] = PCCProcessFrame;

exports["PCCProcedureFrame"] = PCCProcedureFrame;

exports["PCCGroupable"] = PCCGroupable;

exports["PCCGlobal"] = PCCGlobal;

exports["PCCClass"] = PCCClass;

exports["PCCProcedure"] = PCCProcedure;

exports["PCCType"] = PCCType;

exports["PCCVariableInfo"] = PCCVariableInfo;

exports["PCCVariable"] = PCCVariable;

exports["PCCGlobalVariable"] = PCCGlobalVariable;

exports["PCCField"] = PCCField;

exports["PCCInternalReadOnlyField"] = PCCInternalReadOnlyField;

exports["PCCCondition"] = PCCCondition;

exports["PCCLocalVariable"] = PCCLocalVariable;

exports["PCCProgramController"] = PCCProgramController;

},{"CCS":2,"PseuCo":4}],4:[function(require,module,exports){
PseuCoParser = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = function(program) { return program; },
        peg$c2 = { type: "any", description: "any character" },
        peg$c3 = { type: "other", description: "whitespace" },
        peg$c4 = /^[ \t\x0B\f]/,
        peg$c5 = { type: "class", value: "[ \\t\\x0B\\f]", description: "[ \\t\\x0B\\f]" },
        peg$c6 = function() {},
        peg$c7 = /^[\n\r]/,
        peg$c8 = { type: "class", value: "[\\n\\r]", description: "[\\n\\r]" },
        peg$c9 = { type: "other", description: "end of line" },
        peg$c10 = "\n",
        peg$c11 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c12 = "\r\n",
        peg$c13 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
        peg$c14 = "\r",
        peg$c15 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c16 = { type: "other", description: "comment" },
        peg$c17 = "/*",
        peg$c18 = { type: "literal", value: "/*", description: "\"/*\"" },
        peg$c19 = [],
        peg$c20 = void 0,
        peg$c21 = "*/",
        peg$c22 = { type: "literal", value: "*/", description: "\"*/\"" },
        peg$c23 = "/**",
        peg$c24 = { type: "literal", value: "/**", description: "\"/**\"" },
        peg$c25 = "//",
        peg$c26 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c27 = { type: "other", description: "integer" },
        peg$c28 = "0",
        peg$c29 = { type: "literal", value: "0", description: "\"0\"" },
        peg$c30 = function() { return 0; },
        peg$c31 = /^[1-9]/,
        peg$c32 = { type: "class", value: "[1-9]", description: "[1-9]" },
        peg$c33 = /^[0-9]/,
        peg$c34 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c35 = function(head, tail) { return parseInt(head + tail.join(""), 10); },
        peg$c36 = { type: "other", description: "string" },
        peg$c37 = "\"",
        peg$c38 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c39 = null,
        peg$c40 = function(stringLiteral) { return stringLiteral[1] != null ? stringLiteral[1] : ""; },
        peg$c41 = function(chars) { return chars.join(""); },
        peg$c42 = "\\",
        peg$c43 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c44 = function(char_) { return char_; },
        peg$c45 = function(seq) { return "\\" + seq; },
        peg$c46 = function(con) { return con; },
        peg$c47 = function(seq) { return seq; },
        peg$c48 = /^['"\\bfnrtv]/,
        peg$c49 = { type: "class", value: "['\"\\\\bfnrtv]", description: "['\"\\\\bfnrtv]" },
        peg$c50 = /^[0-7]/,
        peg$c51 = { type: "class", value: "[0-7]", description: "[0-7]" },
        peg$c52 = function(first, second) { return first + (second != null ? second : ""); },
        peg$c53 = /^[0-3]/,
        peg$c54 = { type: "class", value: "[0-3]", description: "[0-3]" },
        peg$c55 = function(first, second, third) { return first + second + third; },
        peg$c56 = { type: "other", description: "identifier" },
        peg$c57 = function(head, tail) { return head + tail.join(""); },
        peg$c58 = /^[$A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0100-\u1FFF\u3040-\u318F\u3300-\u337F\u3400-\u3D2D\u4E00-\u9FFF\uF900-\uFAFF]/,
        peg$c59 = { type: "class", value: "[$A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF\\u0100-\\u1FFF\\u3040-\\u318F\\u3300-\\u337F\\u3400-\\u3D2D\\u4E00-\\u9FFF\\uF900-\\uFAFF]", description: "[$A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF\\u0100-\\u1FFF\\u3040-\\u318F\\u3300-\\u337F\\u3400-\\u3D2D\\u4E00-\\u9FFF\\uF900-\\uFAFF]" },
        peg$c60 = function(letter) { return letter; },
        peg$c61 = /^[0-9\u0660-\u0669\u06F0-\u06F9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE7-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u1040-\u1049]/,
        peg$c62 = { type: "class", value: "[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u1040-\\u1049]", description: "[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u1040-\\u1049]" },
        peg$c63 = function(digit) { return digit; },
        peg$c64 = function(source) { return construct(PCProgram, source); },
        peg$c65 = function(head, tail) {
        														var elements = [];
        														elements.push(head);
        														for (var i = 0; i < tail.length; ++i)
        														{
        															elements.push(tail[i][1]);
        														}
        														return elements;
        													},
        peg$c66 = function(elem) { return elem; },
        peg$c67 = "monitor",
        peg$c68 = { type: "literal", value: "monitor", description: "\"monitor\"" },
        peg$c69 = "{",
        peg$c70 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c71 = "}",
        peg$c72 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c73 = function(id, code) {
        																		code.unshift(id);
        																		return construct(PCMonitor, code);
        																	},
        peg$c74 = function(code) {
        																						var declarations = [];
        																						for (var i = 0; i < code.length; ++i)
        																						{
        																							declarations.push(code[i][0]);
        																						}
        																						return declarations;
        																					},
        peg$c75 = "mainAgent",
        peg$c76 = { type: "literal", value: "mainAgent", description: "\"mainAgent\"" },
        peg$c77 = function(stmtBlock) { return new PCMainAgent(stmtBlock); },
        peg$c78 = function(type, id, fp, stmtBlock) {
        																							fp.unshift(type, id, stmtBlock);
        																							return construct(PCProcedureDecl, fp);
        																						},
        peg$c79 = "(",
        peg$c80 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c81 = ",",
        peg$c82 = { type: "literal", value: ",", description: "\",\"" },
        peg$c83 = ")",
        peg$c84 = { type: "literal", value: ")", description: "\")\"" },
        peg$c85 = function(test) {
        																				if (test != null)
        																				{
        																					var fp = [];
        																					fp.push(test[0]);
        																					for (var i = 0; i < test[1].length; ++i)
        																					{
        																						fp.push(test[1][i][3]);
        																					}
        																					return fp;
        																				}
        																				else
        																				{
        																					return [];
        																				}
        																			},
        peg$c86 = function(type, id) { return new PCFormalParameter(type, id); },
        peg$c87 = "struct",
        peg$c88 = { type: "literal", value: "struct", description: "\"struct\"" },
        peg$c89 = function(id, code) {
        																	code.unshift(id);
        																	return construct(PCStruct, code);
        																},
        peg$c90 = function(decls) {
        														var declarations = [];
        														for (var i = 0; i < decls.length; ++i)
        														{
        															declarations.push(decls[i][0]);
        														}
        														return declarations;
        													},
        peg$c91 = "condition",
        peg$c92 = { type: "literal", value: "condition", description: "\"condition\"" },
        peg$c93 = "with",
        peg$c94 = { type: "literal", value: "with", description: "\"with\"" },
        peg$c95 = ";",
        peg$c96 = { type: "literal", value: ";", description: "\";\"" },
        peg$c97 = function(id, exp) { return new PCConditionDecl(id, exp); },
        peg$c98 = function(decl) {
        									decl.isStatement = true;
        									return decl;
        								},
        peg$c99 = function(type, head, tail) {
        																					var declarations = [];
        																					declarations.push(false, type, head);
        																					for (var i = 0; i < tail.length; ++i)
        																					{
        																						declarations.push(tail[i][3]);
        																					}
        																					return construct(PCDecl, declarations);
        																				},
        peg$c100 = "=",
        peg$c101 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c102 = function(id, varInit) { return varInit != null ? new PCVariableDeclarator(id, varInit[3]) : new PCVariableDeclarator(id); },
        peg$c103 = function(test, uncomplete) {
        																												if (test != null)
        																												{
        																													var inits = [];
        																													inits.push(test[0]);
        																													for (var i = 0; i < test[1].length; ++i)
        																													{
        																														inits.push(test[1][i][3]);
        																													}
        																													return new PCVariableInitializer(uncomplete != null, inits);
        																												}
        																												else
        																												{
        																													return new PCVariableInitializer(uncomplete != null);
        																												}
        																											},
        peg$c104 = function(exp) { return new PCVariableInitializer(false, exp); },
        peg$c105 = "[",
        peg$c106 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c107 = "]",
        peg$c108 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c109 = function(type, ranges) {
        																var res = type;
        																for (var i = 0; i < ranges.length; ++i)
        																{
        																	res = new PCArrayType(res, ranges[i][1]);
        																}
        																return res;
        															},
        peg$c110 = function(ch) { return ch; },
        peg$c111 = "bool",
        peg$c112 = { type: "literal", value: "bool", description: "\"bool\"" },
        peg$c113 = function() { return new PCSimpleType(PCSimpleType.BOOL); },
        peg$c114 = "int",
        peg$c115 = { type: "literal", value: "int", description: "\"int\"" },
        peg$c116 = function() { return new PCSimpleType(PCSimpleType.INT); },
        peg$c117 = "string",
        peg$c118 = { type: "literal", value: "string", description: "\"string\"" },
        peg$c119 = function() { return new PCSimpleType(PCSimpleType.STRING); },
        peg$c120 = "mutex",
        peg$c121 = { type: "literal", value: "mutex", description: "\"mutex\"" },
        peg$c122 = function() { return new PCSimpleType(PCSimpleType.MUTEX); },
        peg$c123 = "agent",
        peg$c124 = { type: "literal", value: "agent", description: "\"agent\"" },
        peg$c125 = function() { return new PCSimpleType(PCSimpleType.AGENT); },
        peg$c126 = function(id) { return new PCClassType(id); },
        peg$c127 = "intchan",
        peg$c128 = { type: "literal", value: "intchan", description: "\"intchan\"" },
        peg$c129 = function(int_) { return new PCChannelType(PCSimpleType.INT, int_ != null ? int_ : PCChannelType.CAPACITY_UNKNOWN); },
        peg$c130 = "boolchan",
        peg$c131 = { type: "literal", value: "boolchan", description: "\"boolchan\"" },
        peg$c132 = function(int_) { return new PCChannelType(PCSimpleType.BOOL, int_ != null ? int_ : PCChannelType.CAPACITY_UNKNOWN); },
        peg$c133 = "stringchan",
        peg$c134 = { type: "literal", value: "stringchan", description: "\"stringchan\"" },
        peg$c135 = function(int_) { return new PCChannelType(PCSimpleType.STRING, int_ != null ? int_ : PCChannelType.CAPACITY_UNKNOWN); },
        peg$c136 = "void",
        peg$c137 = { type: "literal", value: "void", description: "\"void\"" },
        peg$c138 = function() { return new PCSimpleType(PCSimpleType.VOID); },
        peg$c139 = function(type) { return type; },
        peg$c140 = function(exp) { return exp; },
        peg$c141 = "start",
        peg$c142 = { type: "literal", value: "start", description: "\"start\"" },
        peg$c143 = function(exp) { return new PCStartExpression(exp); },
        peg$c144 = function(head, tail) {
        														var exps = [];
        														exps.push(head);
        														for (var i = 0; i < tail.length; ++i)
        														{
        															exps.push(tail[i][3]);
        														}
        														return exps;
        													},
        peg$c145 = function(dest, op, exp) { return new PCAssignExpression(dest, op, exp); },
        peg$c146 = function(id, pos) {
        													var ind = [];
        													for (var i = 0; i < pos.length; ++i)
        													{
        														ind.push(pos[i][1]);
        													}
        													return new PCAssignDestination(id, ind);
        												},
        peg$c147 = function() { return "="; },
        peg$c148 = "*=",
        peg$c149 = { type: "literal", value: "*=", description: "\"*=\"" },
        peg$c150 = function() { return "*="; },
        peg$c151 = "/=",
        peg$c152 = { type: "literal", value: "/=", description: "\"/=\"" },
        peg$c153 = function() { return "/="; },
        peg$c154 = "+=",
        peg$c155 = { type: "literal", value: "+=", description: "\"+=\"" },
        peg$c156 = function() { return "+="; },
        peg$c157 = "-=",
        peg$c158 = { type: "literal", value: "-=", description: "\"-=\"" },
        peg$c159 = function() { return "-="; },
        peg$c160 = "<!",
        peg$c161 = { type: "literal", value: "<!", description: "\"<!\"" },
        peg$c162 = function(callExp, exp) { return new PCSendExpression(callExp, exp); },
        peg$c163 = "?",
        peg$c164 = { type: "literal", value: "?", description: "\"?\"" },
        peg$c165 = ":",
        peg$c166 = { type: "literal", value: ":", description: "\":\"" },
        peg$c167 = function(exp, rest) { return rest != null ? new PCConditionalExpression(exp, rest[3], rest[7]) : exp; },
        peg$c168 = "||",
        peg$c169 = { type: "literal", value: "||", description: "\"||\"" },
        peg$c170 = function(exp, rest) {
        																					var res = exp;
        																					for (var i = 0; i < rest.length; ++i)
        																					{
        																						res = new PCOrExpression(res, rest[i][3]);
        																					}
        																					return res;
        																				},
        peg$c171 = "&&",
        peg$c172 = { type: "literal", value: "&&", description: "\"&&\"" },
        peg$c173 = function(exp, rest) {
        																		var res = exp;
        																		for (var i = 0; i < rest.length; ++i)
        																		{
        																			res = new PCAndExpression(res, rest[i][3]);
        																		}
        																		return res;
        																	},
        peg$c174 = "==",
        peg$c175 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c176 = "!=",
        peg$c177 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c178 = function(exp, rest) {
        																					var res = exp;
        																					for (var i = 0; i < rest.length; ++i)
        																					{
        																						res = new PCEqualityExpression(res, rest[i][1], rest[i][3]);
        																					}
        																					return res;
        																				},
        peg$c179 = "<=",
        peg$c180 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c181 = "<",
        peg$c182 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c183 = ">=",
        peg$c184 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c185 = ">",
        peg$c186 = { type: "literal", value: ">", description: "\">\"" },
        peg$c187 = function(exp, rest) {
        																							var res = exp;
        																							for (var i = 0; i < rest.length; ++i)
        																							{
        																								res = new PCRelationalExpression(res, rest[i][1], rest[i][3]);
        																							}
        																							return res;
        																						},
        peg$c188 = "+",
        peg$c189 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c190 = "-",
        peg$c191 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c192 = function(exp, rest) {
        																						var res = exp;
        																						for (var i = 0; i < rest.length; ++i)
        																						{
        																							res = new PCAdditiveExpression(res, rest[i][1], rest[i][3]);
        																						}
        																						return res;
        																					},
        peg$c193 = "*",
        peg$c194 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c195 = "/",
        peg$c196 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c197 = "%",
        peg$c198 = { type: "literal", value: "%", description: "\"%\"" },
        peg$c199 = function(exp, rest) {
        																			var res = exp;
        																			for (var i = 0; i < rest.length; ++i)
        																			{
        																				res = new PCMultiplicative(res, rest[i][1], rest[i][3]);
        																			}
        																			return res;
        																		},
        peg$c200 = "!",
        peg$c201 = { type: "literal", value: "!", description: "\"!\"" },
        peg$c202 = function(op, exp) { return new PCUnaryExpression(op, exp); },
        peg$c203 = "++",
        peg$c204 = { type: "literal", value: "++", description: "\"++\"" },
        peg$c205 = "--",
        peg$c206 = { type: "literal", value: "--", description: "\"--\"" },
        peg$c207 = function(dest, op) { return new PCPostfixExpression(dest, op); },
        peg$c208 = "<?",
        peg$c209 = { type: "literal", value: "<?", description: "\"<?\"" },
        peg$c210 = function(op, exp) { return op.length > 0 ? new PCReceiveExpression(exp) : exp; },
        peg$c211 = function(call) { return call; },
        peg$c212 = function(id, args) { return new PCProcedureCall(id, args); },
        peg$c213 = function(expList) { return expList != null ? expList : []; },
        peg$c214 = ".",
        peg$c215 = { type: "literal", value: ".", description: "\".\"" },
        peg$c216 = function(exp, call) {
        														var res = new PCClassCall(exp, call[0][1]);
        														for (var i = 1; i < call.length; ++i)
        														{
        															res = new PCClassCall(res, call[i][1]);
        														}
        														return res;
        													},
        peg$c217 = function(exp, call) {
        															var res = exp;
        															for (var i = 0; i < call.length; ++i)
        															{
        																res = new PCArrayExpression(res, call[i][1]);
        															}
        															return res;
        														},
        peg$c218 = function(exp) { return new PCLiteralExpression(exp); },
        peg$c219 = function(exp) { return new PCIdentifierExpression(exp); },
        peg$c220 = function(literal) { return literal; },
        peg$c221 = "true",
        peg$c222 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c223 = function() { return true; },
        peg$c224 = "false",
        peg$c225 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c226 = function() { return false; },
        peg$c227 = function(blockStmts) {
        														var stmts = [];
        														for (var i = 0; i < blockStmts.length; ++i)
        														{
        															stmts.push(blockStmts[i][0]);
        														}
        														return construct(PCStmtBlock, stmts);
        													},
        peg$c228 = function(stmt) { return stmt; },
        peg$c229 = function(stmt) { return new PCStatement(stmt); },
        peg$c230 = "break",
        peg$c231 = { type: "literal", value: "break", description: "\"break\"" },
        peg$c232 = function() { return new PCStatement(new PCBreakStmt()); },
        peg$c233 = "continue",
        peg$c234 = { type: "literal", value: "continue", description: "\"continue\"" },
        peg$c235 = function() { return new PCStatement(new PCContinueStmt()); },
        peg$c236 = function() { return new PCStatement(); },
        peg$c237 = function(stmtExp) { return new PCStmtExpression(stmtExp); },
        peg$c238 = function(head, tail) {
        																			var stmts = [];
        																			stmts.push(head);
        																			for (var i = 0; i < tail.length; ++i)
        																			{
        																				stmts.push(tail[i][3]);
        																			}
        																			return stmts;
        																		},
        peg$c239 = "select",
        peg$c240 = { type: "literal", value: "select", description: "\"select\"" },
        peg$c241 = function(stmts) {
        															var caseStmts = [];
        															for (var i = 0; i < stmts.length; ++i)
        															{
        																caseStmts.push(stmts[i]);
        															}
        															return construct(PCSelectStmt, caseStmts);
        														},
        peg$c242 = "case",
        peg$c243 = { type: "literal", value: "case", description: "\"case\"" },
        peg$c244 = function(exp, stmt) { return new PCCase(stmt, exp); },
        peg$c245 = "default",
        peg$c246 = { type: "literal", value: "default", description: "\"default\"" },
        peg$c247 = function(stmt) { return new PCCase(stmt); },
        peg$c248 = "if",
        peg$c249 = { type: "literal", value: "if", description: "\"if\"" },
        peg$c250 = "else",
        peg$c251 = { type: "literal", value: "else", description: "\"else\"" },
        peg$c252 = function(exp, ifStmt, test) { return test != null ? new PCIfStmt(exp, ifStmt, test[2]) : new PCIfStmt(exp, ifStmt); },
        peg$c253 = "while",
        peg$c254 = { type: "literal", value: "while", description: "\"while\"" },
        peg$c255 = function(exp, stmt) { return new PCWhileStmt(exp, stmt); },
        peg$c256 = "do",
        peg$c257 = { type: "literal", value: "do", description: "\"do\"" },
        peg$c258 = function(stmt, exp) { return new PCDoStmt(stmt, exp); },
        peg$c259 = "for",
        peg$c260 = { type: "literal", value: "for", description: "\"for\"" },
        peg$c261 = function(init, exp, update, stmt) {
        																														var res = [];
        																														if (update != null)
        																														{
        																															res = res.concat(update);
        																														}
        																														res.unshift(stmt, init, exp);
        																														return construct(PCForStmt, res);
        																													},
        peg$c262 = function(head, tail) {
        																										var inits = [];
        																										inits.push(head);
        																										for (var i = 0; i < tail.length; ++i)
        																										{
        																											inits.push(tail[i][3]);
        																										}
        																										return construct(PCForInit, inits);
        																									},
        peg$c263 = function(stmtList) { return stmtList; },
        peg$c264 = "return",
        peg$c265 = { type: "literal", value: "return", description: "\"return\"" },
        peg$c266 = function(exp) { return exp != null ? new PCReturnStmt(exp) : new PCReturnStatement(); },
        peg$c267 = "join",
        peg$c268 = { type: "literal", value: "join", description: "\"join\"" },
        peg$c269 = function(exp) { return new PCPrimitiveStmt(PCPrimitiveStmt.JOIN, exp); },
        peg$c270 = "lock",
        peg$c271 = { type: "literal", value: "lock", description: "\"lock\"" },
        peg$c272 = function(exp) { return new PCPrimitiveStmt(PCPrimitiveStmt.LOCK, exp); },
        peg$c273 = "unlock",
        peg$c274 = { type: "literal", value: "unlock", description: "\"unlock\"" },
        peg$c275 = function(exp) { return new PCPrimitiveStmt(PCPrimitiveStmt.UNLOCK, exp); },
        peg$c276 = "waitForCondition",
        peg$c277 = { type: "literal", value: "waitForCondition", description: "\"waitForCondition\"" },
        peg$c278 = function(exp) { return new PCPrimitiveStmt(PCPrimitiveStmt.WAIT, exp); },
        peg$c279 = "signal",
        peg$c280 = { type: "literal", value: "signal", description: "\"signal\"" },
        peg$c281 = function(exp) { return new PCPrimitiveStmt(PCPrimitiveStmt.SIGNAL, exp); },
        peg$c282 = "signalAll",
        peg$c283 = { type: "literal", value: "signalAll", description: "\"signalAll\"" },
        peg$c284 = function(exp) { return exp != null ? new PCPrimitiveStmt(PCPrimitiveStmt.SIGNAL_ALL, exp) : new PCPrimitiveStmt(PCPrimitiveStmt.SIGNAL_ALL); },
        peg$c285 = "println",
        peg$c286 = { type: "literal", value: "println", description: "\"println\"" },
        peg$c287 = function(expList) { return new PCPrintStmt(expList); },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseProgram();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseEOF();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c1(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSourceCharacter() {
      var s0;

      if (input.length > peg$currPos) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }

      return s0;
    }

    function peg$parseWhiteSpace() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      if (peg$c4.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }

      return s0;
    }

    function peg$parseLineTerminator() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c7.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseLineTerminatorSequence() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 10) {
        s1 = peg$c10;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c12) {
          s1 = peg$c12;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c14;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c6();
          }
          s0 = s1;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }

      return s0;
    }

    function peg$parseComment() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseMultiLineComment();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseFormalComment();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSingleLineComment();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c6();
          }
          s0 = s1;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }

      return s0;
    }

    function peg$parseMultiLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c17) {
        s1 = peg$c17;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c21) {
          s5 = peg$c21;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c20;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c21) {
            s5 = peg$c21;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c20;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c21) {
            s3 = peg$c21;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c6();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMultiLineCommentNoLineTerminator() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c17) {
        s1 = peg$c17;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c21) {
          s5 = peg$c21;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        if (s5 === peg$FAILED) {
          s5 = peg$parseLineTerminator();
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c20;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c21) {
            s5 = peg$c21;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$parseLineTerminator();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c20;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c21) {
            s3 = peg$c21;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c6();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFormalComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c23) {
        s1 = peg$c23;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c21) {
          s5 = peg$c21;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c22); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c20;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c21) {
            s5 = peg$c21;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c20;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c21) {
            s3 = peg$c21;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c6();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSingleLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c25) {
        s1 = peg$c25;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseLineTerminator();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c20;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseLineTerminator();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c20;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseWhiteSpace();
      if (s2 === peg$FAILED) {
        s2 = peg$parseMultiLineCommentNoLineTerminator();
        if (s2 === peg$FAILED) {
          s2 = peg$parseSingleLineComment();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseWhiteSpace();
        if (s2 === peg$FAILED) {
          s2 = peg$parseMultiLineCommentNoLineTerminator();
          if (s2 === peg$FAILED) {
            s2 = peg$parseSingleLineComment();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;

      return s0;
    }

    function peg$parse__() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseWhiteSpace();
      if (s2 === peg$FAILED) {
        s2 = peg$parseLineTerminatorSequence();
        if (s2 === peg$FAILED) {
          s2 = peg$parseComment();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseWhiteSpace();
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminatorSequence();
          if (s2 === peg$FAILED) {
            s2 = peg$parseComment();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c20;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseIntegerLiteral() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 48) {
        s1 = peg$c28;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c30();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (peg$c31.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c32); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c33.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c33.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c34); }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c35(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c27); }
      }

      return s0;
    }

    function peg$parseStringLiteral() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c37;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseStringCharacters();
        if (s3 === peg$FAILED) {
          s3 = peg$c39;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c37;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c40(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }

      return s0;
    }

    function peg$parseStringCharacters() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseStringCharacter();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseStringCharacter();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c41(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseStringCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c37;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c42;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseLineTerminator();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c20;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSourceCharacter();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c44(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c42;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEscapeSequence();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c45(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseLineContinuation();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c46(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseLineContinuation() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c42;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLineTerminatorSequence();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEscapeSequence() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseCharacterEscapeSequence();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseOctalEscapeSequence();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseCharacterEscapeSequence() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c48.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c44(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseOctalEscapeSequence() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (peg$c50.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c51); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c39;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c52(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (peg$c53.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c54); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s2 !== peg$FAILED) {
            if (peg$c50.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c51); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c55(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseIdentifier() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseLetter();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseLetter();
        if (s3 === peg$FAILED) {
          s3 = peg$parseDigit();
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseLetter();
          if (s3 === peg$FAILED) {
            s3 = peg$parseDigit();
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c57(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }

      return s0;
    }

    function peg$parseLetter() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c58.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c60(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDigit() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c61.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c63(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseProgram() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseSourceElements();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c64(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseSourceElements() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseSourceElement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceElement();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceElement();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c65(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSourceElement() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseMonitor();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c66(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseStruct();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c66(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseMainAgent();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c66(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseProcedure();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c66(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseDeclarationStatement();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c66(s1);
              }
              s0 = s1;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseMonitor() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c67) {
        s1 = peg$c67;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 123) {
                s5 = peg$c69;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c70); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseMonitorCode();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s9 = peg$c71;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c72); }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c73(s3, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMonitorCode() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parseProcedure();
      if (s3 === peg$FAILED) {
        s3 = peg$parseConditionDeclarationStatement();
        if (s3 === peg$FAILED) {
          s3 = peg$parseDeclarationStatement();
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c0;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parseProcedure();
        if (s3 === peg$FAILED) {
          s3 = peg$parseConditionDeclarationStatement();
          if (s3 === peg$FAILED) {
            s3 = peg$parseDeclarationStatement();
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c74(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseMainAgent() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c75) {
        s1 = peg$c75;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c76); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseStatementBlock();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c77(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseProcedure() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseResultType();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseFormalParameters();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseStatementBlock();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c78(s1, s3, s5, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFormalParameters() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c79;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseFormalParameter();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$parse__();
            if (s7 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s8 = peg$c81;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c82); }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse__();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parseFormalParameter();
                  if (s10 !== peg$FAILED) {
                    s7 = [s7, s8, s9, s10];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c0;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$c0;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s8 = peg$c81;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c82); }
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse__();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseFormalParameter();
                    if (s10 !== peg$FAILED) {
                      s7 = [s7, s8, s9, s10];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c0;
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c39;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c83;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c84); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c85(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseFormalParameter() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseType();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c86(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseStruct() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c87) {
        s1 = peg$c87;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 123) {
                s5 = peg$c69;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c70); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseStructCode();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c71;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c72); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c89(s3, s7);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseStructCode() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parseProcedure();
      if (s3 === peg$FAILED) {
        s3 = peg$parseDeclarationStatement();
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c0;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parseProcedure();
        if (s3 === peg$FAILED) {
          s3 = peg$parseDeclarationStatement();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c90(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseConditionDeclarationStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c91) {
        s1 = peg$c91;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c93) {
                s5 = peg$c93;
                peg$currPos += 4;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c94); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseExpression();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 59) {
                        s9 = peg$c95;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c96); }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c97(s3, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseDeclarationStatement() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseDeclaration();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s3 = peg$c95;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c96); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c98(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseDeclaration() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseType();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseVariableDeclarator();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c81;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c82); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse__();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseVariableDeclarator();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c81;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c82); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse__();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseVariableDeclarator();
                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c99(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseVariableDeclarator() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s4 = peg$c100;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseVariableInitializer();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c39;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c102(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseVariableInitializer() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c69;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseVariableInitializer();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$currPos;
            s7 = peg$parse__();
            if (s7 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s8 = peg$c81;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c82); }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse__();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parseVariableInitializer();
                  if (s10 !== peg$FAILED) {
                    s7 = [s7, s8, s9, s10];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c0;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$c0;
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$currPos;
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s8 = peg$c81;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c82); }
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse__();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseVariableInitializer();
                    if (s10 !== peg$FAILED) {
                      s7 = [s7, s8, s9, s10];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c0;
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c39;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c81;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c82); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c39;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c71;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c72); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c103(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseExpression();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c104(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseType() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parsePrimitiveType();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s4 = peg$c105;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c106); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseIntegerLiteral();
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s6 = peg$c107;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c108); }
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s4 = peg$c105;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c106); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseIntegerLiteral();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s6 = peg$c107;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c108); }
              }
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c109(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsePrimitiveType() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseChan();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c110(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c111) {
          s1 = peg$c111;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c112); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c113();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c114) {
            s1 = peg$c114;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c115); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c116();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c117) {
              s1 = peg$c117;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c118); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c119();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 5) === peg$c120) {
                s1 = peg$c120;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c121); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c122();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 5) === peg$c123) {
                  s1 = peg$c123;
                  peg$currPos += 5;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c124); }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c125();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseIdentifier();
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c126(s1);
                  }
                  s0 = s1;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseChan() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c127) {
        s1 = peg$c127;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c128); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIntegerLiteral();
        if (s2 === peg$FAILED) {
          s2 = peg$c39;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c129(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c130) {
          s1 = peg$c130;
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c131); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIntegerLiteral();
          if (s2 === peg$FAILED) {
            s2 = peg$c39;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c132(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c133) {
            s1 = peg$c133;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c134); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIntegerLiteral();
            if (s2 === peg$FAILED) {
              s2 = peg$c39;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c135(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      return s0;
    }

    function peg$parseResultType() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c136) {
        s1 = peg$c136;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c137); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c138();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseType();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c139(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseExpression() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseStartExpression();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c140(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseAssignmentExpression();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c140(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSendExpression();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c140(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseConditionalExpression();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c140(s1);
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parseStartExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c141) {
        s1 = peg$c141;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c142); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMonCall();
          if (s3 === peg$FAILED) {
            s3 = peg$parseProcCall();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c143(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseExpressionList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c81;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c81;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c82); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c144(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAssignmentExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseAssignDestination();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseAssignmentOperator();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c145(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAssignDestination() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s4 = peg$c105;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c106); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseExpression();
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s6 = peg$c107;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c108); }
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s4 = peg$c105;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c106); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseExpression();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s6 = peg$c107;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c108); }
              }
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c146(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAssignmentOperator() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c147();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c148) {
          s1 = peg$c148;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c149); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c150();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c151) {
            s1 = peg$c151;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c152); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c153();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c154) {
              s1 = peg$c154;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c155); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c156();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c157) {
                s1 = peg$c157;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c158); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c159();
              }
              s0 = s1;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseSendExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseCallExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c160) {
            s3 = peg$c160;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c161); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c162(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseConditionalExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      s1 = peg$parseConditionalOrExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 63) {
            s4 = peg$c163;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c164); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseExpression();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s8 = peg$c165;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c166); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseConditionalExpression();
                      if (s10 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c0;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c0;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c0;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c39;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c167(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseConditionalOrExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseConditionalAndExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c168) {
            s5 = peg$c168;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c169); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseConditionalAndExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c168) {
              s5 = peg$c168;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c169); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseConditionalAndExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c170(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseConditionalAndExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseEqualityExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c171) {
            s5 = peg$c171;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c172); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseEqualityExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c171) {
              s5 = peg$c171;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c172); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseEqualityExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c173(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseEqualityExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseRelationalExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c174) {
            s5 = peg$c174;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c175); }
          }
          if (s5 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c176) {
              s5 = peg$c176;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c177); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseRelationalExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c174) {
              s5 = peg$c174;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c175); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c176) {
                s5 = peg$c176;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c177); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseRelationalExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c178(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseRelationalExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseAdditiveExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c179) {
            s5 = peg$c179;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c180); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 60) {
              s5 = peg$c181;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c182); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c183) {
                s5 = peg$c183;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c184); }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s5 = peg$c185;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c186); }
                }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseAdditiveExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c179) {
              s5 = peg$c179;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c180); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 60) {
                s5 = peg$c181;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c182); }
              }
              if (s5 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c183) {
                  s5 = peg$c183;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c184); }
                }
                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s5 = peg$c185;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c186); }
                  }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseAdditiveExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c187(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseAdditiveExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s5 = peg$c188;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c189); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c190;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c191); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMultiplicativeExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s5 = peg$c188;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c189); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c190;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c191); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMultiplicativeExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c192(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMultiplicativeExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 42) {
            s5 = peg$c193;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c194); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s5 = peg$c195;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c196); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 37) {
                s5 = peg$c197;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c198); }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseUnaryExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
              s5 = peg$c193;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c194); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s5 = peg$c195;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c196); }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 37) {
                  s5 = peg$c197;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c198); }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseUnaryExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c199(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseUnaryExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c188;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c189); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c190;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c191); }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c200;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c201); }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseUnaryExpression();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c202(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseReceiveExpression();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c140(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsePostfixExpression();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c140(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsePostfixExpression() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseAssignDestination();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c203) {
          s2 = peg$c203;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c204); }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c205) {
            s2 = peg$c205;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c206); }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c207(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseReceiveExpression() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c208) {
          s4 = peg$c208;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c209); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c0;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c208) {
            s4 = peg$c208;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c209); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseCallExpression();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c210(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseCallExpression() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseMonCall();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c211(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseProcCall();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c211(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseArrayExpression();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c211(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseProcCall() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseIdentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseArguments();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c212(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseArguments() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c79;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpressionList();
          if (s3 === peg$FAILED) {
            s3 = peg$c39;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c83;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c84); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c213(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseMonCall() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsePrimaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c214;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c215); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseProcCall();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c214;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c215); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseProcCall();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c216(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseArrayExpression() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parsePrimaryExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s4 = peg$c105;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c106); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseExpression();
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s6 = peg$c107;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c108); }
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s4 = peg$c105;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c106); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseExpression();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s6 = peg$c107;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c108); }
              }
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c217(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsePrimaryExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseLiteral();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c218(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c219(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c79;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExpression();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s3 = peg$c83;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c84); }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c140(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      return s0;
    }

    function peg$parseLiteral() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseIntegerLiteral();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c220(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseStringLiteral();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c220(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseBooleanLiteral();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c220(s1);
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseBooleanLiteral() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c221) {
        s1 = peg$c221;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c222); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c223();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c224) {
          s1 = peg$c224;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c225); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c226();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseStatementBlock() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c69;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parseBlockStatement();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseBlockStatement();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s4 = peg$c71;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c72); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c227(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseBlockStatement() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseStatement();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c228(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseProcedure();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c228(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDeclarationStatement();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c229(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseConditionDeclarationStatement();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c228(s1);
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parseStatement() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseStatementBlock();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c229(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseStatementExpression();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s2 = peg$c95;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c96); }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c229(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSelectStatement();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c229(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseIfStatement();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c229(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseWhileStatement();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c229(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseDoStatement();
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c229(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseForStatement();
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c229(s1);
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c230) {
                      s1 = peg$c230;
                      peg$currPos += 5;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c231); }
                    }
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parse_();
                      if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                          s3 = peg$c95;
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c96); }
                        }
                        if (s3 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c232();
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 8) === peg$c233) {
                        s1 = peg$c233;
                        peg$currPos += 8;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c234); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 59) {
                            s3 = peg$c95;
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c96); }
                          }
                          if (s3 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c235();
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parseReturnStatement();
                        if (s1 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c229(s1);
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parsePrimitiveStatement();
                          if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c229(s1);
                          }
                          s0 = s1;
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parsePrintln();
                            if (s1 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c229(s1);
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$parse_();
                              if (s1 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 59) {
                                  s2 = peg$c95;
                                  peg$currPos++;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c96); }
                                }
                                if (s2 !== peg$FAILED) {
                                  peg$reportedPos = s0;
                                  s1 = peg$c236();
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseStatementExpression() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseStartExpression();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c237(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseAssignmentExpression();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c237(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSendExpression();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c237(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePostfixExpression();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c237(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseCallExpression();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c237(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseReceiveExpression();
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c237(s1);
                }
                s0 = s1;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseStatementExpressionList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseStatementExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c81;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseStatementExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c81;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c82); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseStatementExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c238(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseSelectStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c239) {
        s1 = peg$c239;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c240); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s3 = peg$c69;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c70); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseCaseStatement();
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseCaseStatement();
                }
              } else {
                s5 = peg$c0;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s7 = peg$c71;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c72); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c241(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseCaseStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c242) {
        s1 = peg$c242;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c243); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseStatementExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s5 = peg$c165;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c166); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseStatement();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c244(s3, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c245) {
          s1 = peg$c245;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c246); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s3 = peg$c165;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c166); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseStatement();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c247(s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseIfStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c248) {
        s1 = peg$c248;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c249); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c79;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c83;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c84); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseStatement();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$currPos;
                          if (input.substr(peg$currPos, 4) === peg$c250) {
                            s12 = peg$c250;
                            peg$currPos += 4;
                          } else {
                            s12 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c251); }
                          }
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse__();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parseStatement();
                              if (s14 !== peg$FAILED) {
                                s12 = [s12, s13, s14];
                                s11 = s12;
                              } else {
                                peg$currPos = s11;
                                s11 = peg$c0;
                              }
                            } else {
                              peg$currPos = s11;
                              s11 = peg$c0;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$c0;
                          }
                          if (s11 === peg$FAILED) {
                            s11 = peg$c39;
                          }
                          if (s11 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c252(s5, s9, s11);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseWhileStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c253) {
        s1 = peg$c253;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c254); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c79;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c83;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c84); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseStatement();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c255(s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseDoStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c256) {
        s1 = peg$c256;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c257); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseStatement();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c253) {
                s5 = peg$c253;
                peg$currPos += 5;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c254); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s7 = peg$c79;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c80); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseExpression();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c83;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c84); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 59) {
                                s13 = peg$c95;
                                peg$currPos++;
                              } else {
                                s13 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c96); }
                              }
                              if (s13 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c258(s3, s9);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseForStatement() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c259) {
        s1 = peg$c259;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c260); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c79;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseForInit();
              if (s5 === peg$FAILED) {
                s5 = peg$c39;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s7 = peg$c95;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c96); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseExpression();
                      if (s9 === peg$FAILED) {
                        s9 = peg$c39;
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 59) {
                            s11 = peg$c95;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c96); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseForUpdate();
                              if (s13 === peg$FAILED) {
                                s13 = peg$c39;
                              }
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parse_();
                                if (s14 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 41) {
                                    s15 = peg$c83;
                                    peg$currPos++;
                                  } else {
                                    s15 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c84); }
                                  }
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parse__();
                                    if (s16 !== peg$FAILED) {
                                      s17 = peg$parseStatement();
                                      if (s17 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c261(s5, s9, s13, s17);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseForInit() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseDeclaration();
      if (s1 === peg$FAILED) {
        s1 = peg$parseStatementExpression();
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c81;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseDeclaration();
              if (s7 === peg$FAILED) {
                s7 = peg$parseStatementExpression();
              }
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c81;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c82); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseDeclaration();
                if (s7 === peg$FAILED) {
                  s7 = peg$parseStatementExpression();
                }
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c262(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseForUpdate() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseStatementExpressionList();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c263(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseReturnStatement() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c264) {
        s1 = peg$c264;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c265); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpression();
          if (s3 === peg$FAILED) {
            s3 = peg$c39;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s5 = peg$c95;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c96); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c266(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsePrimitiveStatement() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c267) {
        s1 = peg$c267;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c268); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s5 = peg$c95;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c96); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c269(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c270) {
          s1 = peg$c270;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c271); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExpression();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s5 = peg$c95;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c96); }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c272(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c273) {
            s1 = peg$c273;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c274); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s5 = peg$c95;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c96); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c275(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 16) === peg$c276) {
              s1 = peg$c276;
              peg$currPos += 16;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c277); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseExpression();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s5 = peg$c95;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c96); }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c278(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 6) === peg$c279) {
                s1 = peg$c279;
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c280); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseExpression();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 59) {
                        s5 = peg$c95;
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c96); }
                      }
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c281(s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 9) === peg$c282) {
                  s1 = peg$c282;
                  peg$currPos += 9;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c283); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseExpression();
                    if (s3 === peg$FAILED) {
                      s3 = peg$c39;
                    }
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parse_();
                      if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                          s5 = peg$c95;
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c96); }
                        }
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c284(s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsePrintln() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c285) {
        s1 = peg$c285;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c286); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c79;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpressionList();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c83;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c84); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 59) {
                        s9 = peg$c95;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c96); }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c287(s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }


    	function construct(constructor, args)
    	{
    		function F()
    		{
    			return constructor.apply(this, args);
    		}
    		F.prototype = constructor.prototype;
    		return new F();
    	}


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();
// Generated by CoffeeScript 1.6.3
/* ###
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
### */;
/*

	The following classes represent the PseuCo tree. Its implementation is partly incomplete.
	Method _getType is not implemented everywhere and does not perform type checking anywhere at the moment!
	
	toString returns the string representation of the tree with minimal brackets and correctly indented.
*/

var PCAdditiveExpression, PCAndExpression, PCArrayExpression, PCArrayType, PCAssignDestination, PCAssignExpression, PCBaseType, PCBreakStmt, PCCase, PCChannelType, PCClassCall, PCClassType, PCConditionDecl, PCConditionalExpression, PCContinueStmt, PCDecl, PCDeclStmt, PCDoStmt, PCEqualityExpression, PCExpression, PCForInit, PCForStmt, PCFormalParameter, PCIdentifierExpression, PCIfStmt, PCIndent, PCLiteralExpression, PCMainAgent, PCMonitor, PCMultiplicativeExpression, PCNode, PCOrExpression, PCPostfixExpression, PCPrimitiveStmt, PCPrintStmt, PCProcedureCall, PCProcedureDecl, PCProgram, PCReceiveExpression, PCRelationalExpression, PCReturnStmt, PCSelectStmt, PCSendExpression, PCSimpleType, PCStartExpression, PCStatement, PCStmtBlock, PCStmtExpression, PCStruct, PCTArrayType, PCTChannelType, PCTClass, PCTClassType, PCTEnvironmentController, PCTEnvironmentNode, PCTProcedure, PCTProcedureType, PCTType, PCTTypeType, PCTVariable, PCUnaryExpression, PCVariableDeclarator, PCVariableInitializer, PCWhileStmt, exports, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PCIndent = "   ";

PCNode = (function() {
  function PCNode() {
    var c, children, _i, _len, _ref;
    children = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.children = children;
    this.parent = null;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.parent = this;
    }
  }

  PCNode.prototype.getType = function(env) {
    if (!this._type) {
      this._type = this._getType(env);
      if (!this._type) {
        this._type = true;
      }
    }
    if (this._type === true) {
      return null;
    } else {
      return this._type;
    }
  };

  PCNode.prototype._getType = function() {
    throw new Error("Not implemented");
  };

  return PCNode;

})();

PCProgram = (function(_super) {
  __extends(PCProgram, _super);

  function PCProgram() {
    _ref = PCProgram.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PCProgram.prototype.collectClasses = function(env) {
    var c, _i, _len, _ref1, _results;
    _ref1 = this.children;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      _results.push(c.collectClasses(env));
    }
    return _results;
  };

  PCProgram.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref1, _results;
    _ref1 = this.children;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      _results.push(c.collectEnvironment(env));
    }
    return _results;
  };

  PCProgram.prototype.toString = function() {
    var o;
    return ((function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.children;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        o = _ref1[_i];
        _results.push(o.toString(""));
      }
      return _results;
    }).call(this)).join("\n");
  };

  return PCProgram;

})(PCNode);

PCMainAgent = (function(_super) {
  __extends(PCMainAgent, _super);

  function PCMainAgent() {
    _ref1 = PCMainAgent.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  PCMainAgent.prototype.collectClasses = function(env) {
    return null;
  };

  PCMainAgent.prototype.collectEnvironment = function(env) {
    env.beginMainAgent(this);
    this.children[0].collectEnvironment(env);
    return env.endMainAgent();
  };

  PCMainAgent.prototype.toString = function() {
    return "mainAgent " + this.children[0].toString("");
  };

  return PCMainAgent;

})(PCNode);

PCProcedureDecl = (function(_super) {
  __extends(PCProcedureDecl, _super);

  function PCProcedureDecl() {
    var body, name, parameters, resultType;
    resultType = arguments[0], name = arguments[1], body = arguments[2], parameters = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    this.name = name;
    parameters.unshift(resultType, body);
    PCProcedureDecl.__super__.constructor.apply(this, parameters);
  }

  PCProcedureDecl.prototype.getResultType = function() {
    return this.children[0];
  };

  PCProcedureDecl.prototype.getBody = function() {
    return this.children[1];
  };

  PCProcedureDecl.prototype.getArgumentCount = function() {
    return this.children.length - 2;
  };

  PCProcedureDecl.prototype.getArgumentAtIndex = function(index) {
    return this.children[index + 2];
  };

  PCProcedureDecl.prototype.collectClasses = function(env) {
    return null;
  };

  PCProcedureDecl.prototype.collectEnvironment = function(env) {
    var args, p;
    args = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.children.slice(2, this.children.length);
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i += 1) {
        p = _ref2[_i];
        _results.push(p.getVariable(env));
      }
      return _results;
    }).call(this);
    env.beginNewProcedure(this, this.name, this.getResultType().getType(env).type, args);
    this.getBody().collectEnvironment(env);
    return env.endProcedure();
  };

  PCProcedureDecl.prototype.toString = function(indent) {
    var i;
    return "" + indent + (this.getResultType().toString()) + " " + this.name + "(" + (((function() {
      var _i, _ref2, _results;
      _results = [];
      for (i = _i = 0, _ref2 = this.getArgumentCount(); _i < _ref2; i = _i += 1) {
        _results.push(this.getArgumentAtIndex(i).toString());
      }
      return _results;
    }).call(this)).join(", ")) + ") " + (this.getBody().toString(indent));
  };

  return PCProcedureDecl;

})(PCNode);

PCFormalParameter = (function(_super) {
  __extends(PCFormalParameter, _super);

  function PCFormalParameter(type, identifier) {
    this.identifier = identifier;
    PCFormalParameter.__super__.constructor.call(this, type);
  }

  PCFormalParameter.prototype.getVariable = function(env) {
    return new PCTVariable(this, this.identifier, this.children[0].getType(env).type);
  };

  PCFormalParameter.prototype.toString = function() {
    return this.children[0].toString() + " " + this.identifier;
  };

  return PCFormalParameter;

})(PCNode);

PCMonitor = (function(_super) {
  __extends(PCMonitor, _super);

  function PCMonitor() {
    var declarations, name;
    name = arguments[0], declarations = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.name = name;
    PCMonitor.__super__.constructor.apply(this, declarations);
  }

  PCMonitor.prototype.collectClasses = function(env) {
    return env.processNewClass(this, new PCTClassType(true, this.name));
  };

  PCMonitor.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref2;
    env.beginClass(this.name);
    _ref2 = this.children;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      c = _ref2[_i];
      c.collectEnvironment(env);
    }
    return env.endClass();
  };

  PCMonitor.prototype.toString = function() {
    var o;
    return "monitor " + this.name + " {\n" + (((function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.children;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        o = _ref2[_i];
        _results.push(o.toString(PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n}";
  };

  return PCMonitor;

})(PCNode);

PCStruct = (function(_super) {
  __extends(PCStruct, _super);

  function PCStruct() {
    var declarations, name;
    name = arguments[0], declarations = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.name = name;
    PCStruct.__super__.constructor.apply(this, declarations);
  }

  PCStruct.prototype.collectClasses = function(env) {
    return env.processNewClass(this, new PCTClassType(false, this.name));
  };

  PCStruct.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref2;
    env.beginClass(this.name);
    _ref2 = this.children;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      c = _ref2[_i];
      c.collectEnvironment(env);
    }
    return env.endClass();
  };

  PCStruct.prototype.toString = function() {
    var o;
    return "struct " + this.name + " {\n" + (((function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.children;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        o = _ref2[_i];
        _results.push(o.toString(PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n}";
  };

  return PCStruct;

})(PCNode);

PCConditionDecl = (function(_super) {
  __extends(PCConditionDecl, _super);

  function PCConditionDecl(name, expression) {
    this.name = name;
    PCConditionDecl.__super__.constructor.call(this, expression);
  }

  PCConditionDecl.prototype.getExpression = function() {
    return this.children[0];
  };

  PCConditionDecl.prototype.collectEnvironment = function(env) {
    return env.processNewVariable(new PCTVariable(this, this.name, new PCTType(PCTType.CONDITION)));
  };

  PCConditionDecl.prototype.toString = function(indent) {
    return "" + indent + "condition " + this.name + " with " + (this.children[0].toString()) + ";";
  };

  return PCConditionDecl;

})(PCNode);

PCDecl = (function(_super) {
  __extends(PCDecl, _super);

  function PCDecl() {
    var children, isStatement;
    isStatement = arguments[0], children = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.isStatement = isStatement;
    PCDecl.__super__.constructor.apply(this, children);
  }

  PCDecl.prototype.getType = function() {
    return this.children[0];
  };

  PCDecl.prototype.getDeclarators = function() {
    return this.children.slice(1);
  };

  PCDecl.prototype.collectClasses = function(env) {
    return null;
  };

  PCDecl.prototype.collectEnvironment = function(env) {
    var i, type, _i, _ref2, _results;
    type = this.children[0].getType(env).type;
    _results = [];
    for (i = _i = 1, _ref2 = this.children.length; _i < _ref2; i = _i += 1) {
      _results.push(this.children[i].collectEnvironment(env, type));
    }
    return _results;
  };

  PCDecl.prototype.toString = function(indent) {
    var res;
    res = indent + this.children[0].toString() + " " + this.children[1].toString();
    if (this.isStatement) {
      res += ";";
    }
    return res;
  };

  return PCDecl;

})(PCNode);

PCDeclStmt = (function(_super) {
  __extends(PCDeclStmt, _super);

  function PCDeclStmt() {
    var children;
    children = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    PCDeclStmt.__super__.constructor.apply(this, [true].concat(__slice.call(children)));
  }

  return PCDeclStmt;

})(PCDecl);

PCVariableDeclarator = (function(_super) {
  __extends(PCVariableDeclarator, _super);

  function PCVariableDeclarator(name, initializer) {
    this.name = name;
    if (initializer) {
      PCVariableDeclarator.__super__.constructor.call(this, initializer);
    } else {
      PCVariableDeclarator.__super__.constructor.apply(this, []);
    }
  }

  PCVariableDeclarator.prototype.getInitializer = function() {
    if (this.children.length > 0) {
      return this.children[0];
    } else {
      return null;
    }
  };

  PCVariableDeclarator.prototype.getTypeNode = function() {
    return this.parent.getType();
  };

  PCVariableDeclarator.prototype.collectEnvironment = function(env, type) {
    return env.processNewVariable(new PCTVariable(this, this.name, type));
  };

  PCVariableDeclarator.prototype.toString = function() {
    var res;
    res = this.name;
    if (this.children.length > 0) {
      res += " = " + (this.children[0].toString());
    }
    return res;
  };

  return PCVariableDeclarator;

})(PCNode);

PCVariableInitializer = (function(_super) {
  __extends(PCVariableInitializer, _super);

  function PCVariableInitializer() {
    var children, isUncompletedArray;
    isUncompletedArray = arguments[0], children = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.isUncompletedArray = isUncompletedArray != null ? isUncompletedArray : false;
    PCVariableInitializer.__super__.constructor.apply(this, children);
  }

  PCVariableInitializer.prototype.isArray = function() {
    return !(this.children[0] instanceof PCExpression);
  };

  PCVariableInitializer.prototype.getTypeNode = function() {
    return this.parent.getTypeNode();
  };

  PCVariableInitializer.prototype.toString = function() {
    var o;
    if (this.children[0] instanceof PCExpression) {
      return "" + (this.children[0].toString());
    } else {
      return "{" + (((function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.children;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          o = _ref2[_i];
          _results.push(o.toString());
        }
        return _results;
      }).call(this)).join(", ")) + (this.isUncompletedArray ? "," : "") + "}";
    }
  };

  return PCVariableInitializer;

})(PCNode);

PCArrayType = (function(_super) {
  __extends(PCArrayType, _super);

  function PCArrayType(baseType, size) {
    this.size = size;
    PCArrayType.__super__.constructor.call(this, baseType);
  }

  PCArrayType.prototype._getType = function(env) {
    return new PCTTypeType(new PCTArrayType(this.children[0].getType(env).type, this.size));
  };

  PCArrayType.prototype.toString = function() {
    return "" + this.children[0] + "[" + this.size + "]";
  };

  return PCArrayType;

})(PCNode);

PCBaseType = (function(_super) {
  __extends(PCBaseType, _super);

  function PCBaseType() {
    PCBaseType.__super__.constructor.apply(this, []);
  }

  return PCBaseType;

})(PCNode);

PCSimpleType = (function(_super) {
  __extends(PCSimpleType, _super);

  function PCSimpleType(type) {
    this.type = type;
    if (this.type < 0 || this.type > 5) {
      throw "Unknown type";
    }
    PCSimpleType.__super__.constructor.apply(this, arguments);
  }

  PCSimpleType.prototype._getType = function() {
    return new PCTTypeType(new PCTType(PCSimpleType.typeToTypeKind(this.type)));
  };

  PCSimpleType.prototype.toString = function() {
    return PCSimpleType.typeToString(this.type);
  };

  return PCSimpleType;

})(PCBaseType);

PCSimpleType.VOID = 0;

PCSimpleType.BOOL = 1;

PCSimpleType.INT = 2;

PCSimpleType.STRING = 3;

PCSimpleType.MUTEX = 4;

PCSimpleType.AGENT = 5;

PCSimpleType.typeToString = function(type) {
  switch (type) {
    case PCSimpleType.VOID:
      return "void";
    case PCSimpleType.BOOL:
      return "bool";
    case PCSimpleType.INT:
      return "int";
    case PCSimpleType.STRING:
      return "string";
    case PCSimpleType.MUTEX:
      return "mutex";
    case PCSimpleType.AGENT:
      return "agent";
    default:
      throw new Error("Unknown type!");
  }
};

PCSimpleType.typeToTypeKind = function(type) {
  switch (type) {
    case PCSimpleType.MUTEX:
      return PCTType.MUTEX;
    case PCSimpleType.AGENT:
      return PCTType.AGENT;
    case PCSimpleType.VOID:
      return PCTType.VOID;
    case PCSimpleType.BOOL:
      return PCTType.BOOL;
    case PCSimpleType.INT:
      return PCTType.INT;
    case PCSimpleType.STRING:
      return PCTType.STRING;
    default:
      throw new Error("Unknown type!");
  }
};

PCChannelType = (function(_super) {
  __extends(PCChannelType, _super);

  function PCChannelType(valueType, capacity) {
    this.valueType = valueType;
    this.capacity = capacity;
    PCChannelType.__super__.constructor.apply(this, []);
  }

  PCChannelType.prototype._getType = function() {
    return new PCTTypeType(new PCTChannelType(new PCTType(PCSimpleType.typeToTypeKind(this.valueType)), this.capacity));
  };

  PCChannelType.prototype.toString = function() {
    return "" + (PCSimpleType.typeToString(this.valueType)) + "chan" + (this.capacity !== PCChannelType.CAPACITY_UNKNOWN ? this.capacity : "");
  };

  return PCChannelType;

})(PCNode);

PCChannelType.CAPACITY_UNKNOWN = -1;

PCClassType = (function(_super) {
  __extends(PCClassType, _super);

  function PCClassType(className) {
    this.className = className;
    PCClassType.__super__.constructor.apply(this, arguments);
  }

  PCClassType.prototype._getType = function(env) {
    return new PCTTypeType(env.getClassWithName(this.className).type);
  };

  PCClassType.prototype.toString = function() {
    return this.className;
  };

  return PCClassType;

})(PCBaseType);

PCExpression = (function(_super) {
  __extends(PCExpression, _super);

  function PCExpression() {
    _ref2 = PCExpression.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  PCExpression.prototype.childToString = function(i, diff) {
    var res;
    if (i == null) {
      i = 0;
    }
    if (diff == null) {
      diff = 0;
    }
    res = this.children[i].toString();
    if (this.getPrecedence() + diff > this.children[i].getPrecedence()) {
      res = "(" + res + ")";
    }
    return res;
  };

  return PCExpression;

})(PCNode);

PCStartExpression = (function(_super) {
  __extends(PCStartExpression, _super);

  function PCStartExpression() {
    _ref3 = PCStartExpression.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  PCStartExpression.prototype.getPrecedence = function() {
    return 42;
  };

  PCStartExpression.prototype.toString = function() {
    return "start " + (this.childToString(0));
  };

  PCStartExpression.prototype._getType = function() {
    return new PCType(PCType.AGENT);
  };

  return PCStartExpression;

})(PCExpression);

PCAssignExpression = (function(_super) {
  __extends(PCAssignExpression, _super);

  function PCAssignExpression(destination, operator, expression) {
    this.operator = operator;
    PCAssignExpression.__super__.constructor.call(this, destination, expression);
  }

  PCAssignExpression.prototype.getDestination = function() {
    return this.children[0];
  };

  PCAssignExpression.prototype.getExpression = function() {
    return this.children[1];
  };

  PCAssignExpression.prototype._getType = function(env) {
    return this.children[1].getType(env);
  };

  PCAssignExpression.prototype.getPrecedence = function() {
    return 39;
  };

  PCAssignExpression.prototype.toString = function() {
    return "" + (this.getDestination().toString()) + " " + this.operator + " " + (this.childToString(1));
  };

  return PCAssignExpression;

})(PCExpression);

PCAssignDestination = (function(_super) {
  __extends(PCAssignDestination, _super);

  function PCAssignDestination() {
    var arrayIndexExpressions, identifier;
    identifier = arguments[0], arrayIndexExpressions = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.identifier = identifier;
    PCAssignDestination.__super__.constructor.apply(this, arrayIndexExpressions);
  }

  PCAssignDestination.prototype.toString = function() {
    var o;
    return "" + this.identifier + (((function() {
      var _i, _len, _ref4, _results;
      _ref4 = this.children;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        o = _ref4[_i];
        _results.push("[" + (o.toString()) + "]");
      }
      return _results;
    }).call(this)).join(""));
  };

  return PCAssignDestination;

})(PCNode);

PCSendExpression = (function(_super) {
  __extends(PCSendExpression, _super);

  function PCSendExpression() {
    _ref4 = PCSendExpression.__super__.constructor.apply(this, arguments);
    return _ref4;
  }

  PCSendExpression.prototype._getType = function(env) {
    return this.children[1].getType(env);
  };

  PCSendExpression.prototype.getPrecedence = function() {
    return 39;
  };

  PCSendExpression.prototype.toString = function() {
    return "" + (this.childToString(0, 1)) + " <! " + (this.childToString(1));
  };

  return PCSendExpression;

})(PCExpression);

PCConditionalExpression = (function(_super) {
  __extends(PCConditionalExpression, _super);

  function PCConditionalExpression() {
    _ref5 = PCConditionalExpression.__super__.constructor.apply(this, arguments);
    return _ref5;
  }

  PCConditionalExpression.prototype._getType = function(env) {
    return this.children[1].getType(env);
  };

  PCConditionalExpression.prototype.getPrecedence = function() {
    return 45;
  };

  PCConditionalExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " ? " + (this.children[1].toString()) + " : " + (this.children[2].toString());
  };

  return PCConditionalExpression;

})(PCExpression);

PCOrExpression = (function(_super) {
  __extends(PCOrExpression, _super);

  function PCOrExpression() {
    _ref6 = PCOrExpression.__super__.constructor.apply(this, arguments);
    return _ref6;
  }

  PCOrExpression.prototype._getType = function() {
    return new PCTType(PCType.BOOL);
  };

  PCOrExpression.prototype.getPrecedence = function() {
    return 48;
  };

  PCOrExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " || " + (this.childToString(1, 1));
  };

  return PCOrExpression;

})(PCExpression);

PCAndExpression = (function(_super) {
  __extends(PCAndExpression, _super);

  function PCAndExpression() {
    _ref7 = PCAndExpression.__super__.constructor.apply(this, arguments);
    return _ref7;
  }

  PCAndExpression.prototype._getType = function() {
    return new PCTType(PCType.BOOL);
  };

  PCAndExpression.prototype.getPrecedence = function() {
    return 51;
  };

  PCAndExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " && " + (this.childToString(1, 1));
  };

  return PCAndExpression;

})(PCExpression);

PCEqualityExpression = (function(_super) {
  __extends(PCEqualityExpression, _super);

  function PCEqualityExpression(left, operator, right) {
    this.operator = operator;
    PCEqualityExpression.__super__.constructor.call(this, left, right);
  }

  PCEqualityExpression.prototype._getType = function() {
    return new PCTType(PCType.BOOL);
  };

  PCEqualityExpression.prototype.getPrecedence = function() {
    return 54;
  };

  PCEqualityExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  return PCEqualityExpression;

})(PCExpression);

PCRelationalExpression = (function(_super) {
  __extends(PCRelationalExpression, _super);

  function PCRelationalExpression(left, operator, right) {
    this.operator = operator;
    PCRelationalExpression.__super__.constructor.call(this, left, right);
  }

  PCRelationalExpression.prototype._getType = function() {
    return new PCTType(PCType.BOOL);
  };

  PCRelationalExpression.prototype.getPrecedence = function() {
    return 57;
  };

  PCRelationalExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  return PCRelationalExpression;

})(PCExpression);

PCAdditiveExpression = (function(_super) {
  __extends(PCAdditiveExpression, _super);

  function PCAdditiveExpression(left, operator, right) {
    this.operator = operator;
    PCAdditiveExpression.__super__.constructor.call(this, left, right);
  }

  PCAdditiveExpression.prototype._getType = function() {
    return new PCTType(PCType.INT);
  };

  PCAdditiveExpression.prototype.getPrecedence = function() {
    return 60;
  };

  PCAdditiveExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  return PCAdditiveExpression;

})(PCExpression);

PCMultiplicativeExpression = (function(_super) {
  __extends(PCMultiplicativeExpression, _super);

  function PCMultiplicativeExpression(left, operator, right) {
    this.operator = operator;
    PCMultiplicativeExpression.__super__.constructor.call(this, left, right);
  }

  PCMultiplicativeExpression.prototype._getType = function() {
    return new PCTType(PCType.INT);
  };

  PCMultiplicativeExpression.prototype.getPrecedence = function() {
    return 63;
  };

  PCMultiplicativeExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  return PCMultiplicativeExpression;

})(PCExpression);

PCUnaryExpression = (function(_super) {
  __extends(PCUnaryExpression, _super);

  function PCUnaryExpression(operator, expression) {
    this.operator = operator;
    PCUnaryExpression.__super__.constructor.call(this, expression);
  }

  PCUnaryExpression.prototype._getType = function(env) {
    return this.children[0].getType(env);
  };

  PCUnaryExpression.prototype.getPrecedence = function() {
    return 66;
  };

  PCUnaryExpression.prototype.toString = function() {
    return "" + this.operator + (this.childToString(0));
  };

  return PCUnaryExpression;

})(PCExpression);

PCPostfixExpression = (function(_super) {
  __extends(PCPostfixExpression, _super);

  function PCPostfixExpression(assignDestination, operator) {
    this.operator = operator;
    PCPostfixExpression.__super__.constructor.call(this, assignDestination);
  }

  PCPostfixExpression.prototype._getType = function() {
    return new PCTType(PCType.INT);
  };

  PCPostfixExpression.prototype.getPrecedence = function() {
    return 69;
  };

  PCPostfixExpression.prototype.toString = function() {
    return "" + (this.children[0].toString()) + this.operator;
  };

  return PCPostfixExpression;

})(PCExpression);

PCReceiveExpression = (function(_super) {
  __extends(PCReceiveExpression, _super);

  function PCReceiveExpression() {
    _ref8 = PCReceiveExpression.__super__.constructor.apply(this, arguments);
    return _ref8;
  }

  PCReceiveExpression.prototype._getType = function(env) {
    return this.children[0].getType(env).chanelledType;
  };

  PCReceiveExpression.prototype.getPrecedence = function() {
    return 72;
  };

  PCReceiveExpression.prototype.toString = function() {
    return "<? " + (this.childToString(0));
  };

  return PCReceiveExpression;

})(PCExpression);

PCProcedureCall = (function(_super) {
  __extends(PCProcedureCall, _super);

  function PCProcedureCall() {
    var args, procedureName;
    procedureName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.procedureName = procedureName;
    PCProcedureCall.__super__.constructor.apply(this, args);
  }

  PCProcedureCall.prototype.getProcedure = function(env, className) {
    return (className ? env.getClassWithName(className) : env).getProcedureWithName(this.procedureName);
  };

  PCProcedureCall.prototype.getType = function(env, className) {
    if (!className) {
      return PCProcedureCall.__super__.getType.apply(this, arguments);
    } else {
      return this._getType(env, className);
    }
  };

  PCProcedureCall.prototype._getType = function(env, className) {
    return this.getProcedure(env, className).returnType;
  };

  PCProcedureCall.prototype.getPrecedence = function() {
    return 75;
  };

  PCProcedureCall.prototype.toString = function() {
    var o;
    return "" + this.procedureName + "(" + (((function() {
      var _i, _len, _ref9, _results;
      _ref9 = this.children;
      _results = [];
      for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
        o = _ref9[_i];
        _results.push(o.toString());
      }
      return _results;
    }).call(this)).join(", ")) + ")";
  };

  return PCProcedureCall;

})(PCExpression);

PCClassCall = (function(_super) {
  __extends(PCClassCall, _super);

  function PCClassCall() {
    _ref9 = PCClassCall.__super__.constructor.apply(this, arguments);
    return _ref9;
  }

  PCClassCall.prototype.getProcedure = function(env) {
    return this.children[1].getProcedure(env, this.children[0].getType(env).identifier);
  };

  PCClassCall.prototype._getType = function(env) {
    return this.children[1].getType(env, this.children[0].getType(env).identifier);
  };

  PCClassCall.prototype.getPrecedence = function() {
    return 78;
  };

  PCClassCall.prototype.toString = function() {
    return "" + (this.children[0].toString()) + "." + (this.children[1].toString());
  };

  return PCClassCall;

})(PCExpression);

PCArrayExpression = (function(_super) {
  __extends(PCArrayExpression, _super);

  function PCArrayExpression() {
    _ref10 = PCArrayExpression.__super__.constructor.apply(this, arguments);
    return _ref10;
  }

  PCArrayExpression.prototype._getType = function(env) {
    return this.children[0].getType(env).elementsType;
  };

  PCArrayExpression.prototype.getPrecedence = function() {
    return 81;
  };

  PCArrayExpression.prototype.toString = function() {
    return "" + (this.children[0].toString()) + "[" + (this.children[1].toString()) + "]";
  };

  return PCArrayExpression;

})(PCExpression);

PCLiteralExpression = (function(_super) {
  __extends(PCLiteralExpression, _super);

  function PCLiteralExpression(value) {
    this.value = value;
    PCLiteralExpression.__super__.constructor.apply(this, []);
  }

  PCLiteralExpression.prototype._getType = function() {
    switch (typeof this.value) {
      case "boolean":
        return new PCTType(PCTType.BOOL);
      case "string":
        return PCTType(PCTType.STRING);
      default:
        return PCTType(PCTType.INT);
    }
  };

  PCLiteralExpression.prototype.getPrecedence = function() {
    return 84;
  };

  PCLiteralExpression.prototype.toString = function() {
    switch (typeof this.value) {
      case "boolean":
        if (this.value) {
          return "true";
        } else {
          return "false";
        }
      case "string":
        return "\"" + this.value + "\"";
      default:
        return "" + this.value;
    }
  };

  return PCLiteralExpression;

})(PCExpression);

PCIdentifierExpression = (function(_super) {
  __extends(PCIdentifierExpression, _super);

  function PCIdentifierExpression(identifier) {
    this.identifier = identifier;
    PCIdentifierExpression.__super__.constructor.apply(this, []);
  }

  PCIdentifierExpression.prototype._getType = function(env) {
    return env.getVariableWithName(this.identifier).type;
  };

  PCIdentifierExpression.prototype.getPrecedence = function() {
    return 84;
  };

  PCIdentifierExpression.prototype.toString = function() {
    return this.identifier;
  };

  return PCIdentifierExpression;

})(PCExpression);

PCStatement = (function(_super) {
  __extends(PCStatement, _super);

  function PCStatement() {
    _ref11 = PCStatement.__super__.constructor.apply(this, arguments);
    return _ref11;
  }

  PCStatement.prototype.collectEnvironment = function(env) {
    return this.children.length > 0 && this.children[0].collectEnvironment(env);
  };

  PCStatement.prototype.toString = function(indent, expectsNewBlock) {
    var addIndent, res;
    addIndent = expectsNewBlock === true && (this.children.length === 0 || !(this.children[0] instanceof PCStmtBlock));
    if (addIndent) {
      indent += PCIndent;
    }
    if (this.children.length === 0) {
      res = indent + ";";
    } else {
      res = this.children[0].toString(indent);
      if (this.children[0] instanceof PCStmtExpression) {
        res += ";";
      }
    }
    if (addIndent) {
      res = "\n" + res;
    }
    return res;
  };

  return PCStatement;

})(PCNode);

PCBreakStmt = (function(_super) {
  __extends(PCBreakStmt, _super);

  function PCBreakStmt() {
    PCBreakStmt.__super__.constructor.apply(this, []);
  }

  PCBreakStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCBreakStmt.prototype.toString = function(indent) {
    return indent + "break";
  };

  return PCBreakStmt;

})(PCNode);

PCContinueStmt = (function(_super) {
  __extends(PCContinueStmt, _super);

  function PCContinueStmt() {
    PCContinueStmt.__super__.constructor.apply(this, []);
  }

  PCContinueStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCContinueStmt.prototype.toString = function(indent) {
    return indent + "continue";
  };

  return PCContinueStmt;

})(PCNode);

PCStmtBlock = (function(_super) {
  __extends(PCStmtBlock, _super);

  function PCStmtBlock() {
    _ref12 = PCStmtBlock.__super__.constructor.apply(this, arguments);
    return _ref12;
  }

  PCStmtBlock.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref13, _results;
    _ref13 = this.children;
    _results = [];
    for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
      c = _ref13[_i];
      _results.push(c.collectEnvironment(env));
    }
    return _results;
  };

  PCStmtBlock.prototype.toString = function(indent) {
    var o;
    return "{\n" + (((function() {
      var _i, _len, _ref13, _results;
      _ref13 = this.children;
      _results = [];
      for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
        o = _ref13[_i];
        _results.push(o.toString(indent + PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n" + indent + "}";
  };

  return PCStmtBlock;

})(PCNode);

PCStmtExpression = (function(_super) {
  __extends(PCStmtExpression, _super);

  function PCStmtExpression() {
    _ref13 = PCStmtExpression.__super__.constructor.apply(this, arguments);
    return _ref13;
  }

  PCStmtExpression.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCStmtExpression.prototype.toString = function(indent) {
    return indent + this.children[0].toString();
  };

  return PCStmtExpression;

})(PCNode);

PCSelectStmt = (function(_super) {
  __extends(PCSelectStmt, _super);

  function PCSelectStmt() {
    _ref14 = PCSelectStmt.__super__.constructor.apply(this, arguments);
    return _ref14;
  }

  PCSelectStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCSelectStmt.prototype.toString = function(indent) {
    var o;
    return "" + indent + "select {\n" + (((function() {
      var _i, _len, _ref15, _results;
      _ref15 = this.children;
      _results = [];
      for (_i = 0, _len = _ref15.length; _i < _len; _i++) {
        o = _ref15[_i];
        _results.push(o.toString(indent + PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n" + indent + "}";
  };

  return PCSelectStmt;

})(PCNode);

PCCase = (function(_super) {
  __extends(PCCase, _super);

  function PCCase(execution, condition) {
    if (condition) {
      PCCase.__super__.constructor.call(this, execution, condition);
    } else {
      PCCase.__super__.constructor.call(this, execution);
    }
  }

  PCCase.prototype.getCondition = function() {
    if (this.children.length === 2) {
      return this.children[1];
    } else {
      return null;
    }
  };

  PCCase.prototype.getExecution = function() {
    return this.children[0];
  };

  PCCase.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCCase.prototype.toString = function(indent) {
    return "" + indent + (this.children.length === 2 ? "case " + (this.children[1].toString()) : "default") + ": " + (this.children[0].toString(indent, true));
  };

  return PCCase;

})(PCNode);

PCIfStmt = (function(_super) {
  __extends(PCIfStmt, _super);

  function PCIfStmt() {
    _ref15 = PCIfStmt.__super__.constructor.apply(this, arguments);
    return _ref15;
  }

  PCIfStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCIfStmt.prototype.toString = function(indent) {
    return "" + indent + "if (" + (this.children[0].toString()) + ") " + (this.children[1].toString(indent, true)) + (this.children[2] ? " " + (this.children[2].toString(indent, true)) : "");
  };

  return PCIfStmt;

})(PCNode);

PCWhileStmt = (function(_super) {
  __extends(PCWhileStmt, _super);

  function PCWhileStmt() {
    _ref16 = PCWhileStmt.__super__.constructor.apply(this, arguments);
    return _ref16;
  }

  PCWhileStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCWhileStmt.prototype.toString = function(indent) {
    return "" + indent + "while (" + (this.children[0].toString()) + ") " + (this.children[1].toString(indent, true));
  };

  return PCWhileStmt;

})(PCNode);

PCDoStmt = (function(_super) {
  __extends(PCDoStmt, _super);

  function PCDoStmt() {
    _ref17 = PCDoStmt.__super__.constructor.apply(this, arguments);
    return _ref17;
  }

  PCDoStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCDoStmt.prototype.toString = function(indent) {
    return "" + indent + "do " + (this.children[0].toString(indent, true)) + "\n" + indent + "while (" + (this.children[1].toString()) + ")";
  };

  return PCDoStmt;

})(PCNode);

PCForStmt = (function(_super) {
  __extends(PCForStmt, _super);

  function PCForStmt() {
    var body, children, expression, init, update;
    body = arguments[0], init = arguments[1], expression = arguments[2], update = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    this.body = body;
    this.init = init;
    this.expression = expression;
    this.update = update;
    children = this.update.concat([this.body]);
    if (this.expression) {
      children.unshift(this.expression);
    }
    if (this.init) {
      children.unshift(this.init);
    }
    PCForStmt.__super__.constructor.apply(this, children);
  }

  PCForStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCForStmt.prototype.toString = function(indent) {
    var o;
    return "" + indent + "for (" + (this.init ? this.init.toString() : "") + "; " + (this.expression ? this.expression.toString() : "") + "; " + (((function() {
      var _i, _len, _ref18, _results;
      _ref18 = this.update;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        o = _ref18[_i];
        _results.push(o.toString(""));
      }
      return _results;
    }).call(this)).join(", ")) + ") " + (this.body.toString(indent, true));
  };

  return PCForStmt;

})(PCNode);

PCForInit = (function(_super) {
  __extends(PCForInit, _super);

  function PCForInit() {
    _ref18 = PCForInit.__super__.constructor.apply(this, arguments);
    return _ref18;
  }

  PCForInit.prototype.toString = function() {
    var o;
    return "" + (((function() {
      var _i, _len, _ref19, _results;
      _ref19 = this.children;
      _results = [];
      for (_i = 0, _len = _ref19.length; _i < _len; _i++) {
        o = _ref19[_i];
        _results.push(o.toString(""));
      }
      return _results;
    }).call(this)).join(", "));
  };

  return PCForInit;

})(PCNode);

PCReturnStmt = (function(_super) {
  __extends(PCReturnStmt, _super);

  function PCReturnStmt() {
    _ref19 = PCReturnStmt.__super__.constructor.apply(this, arguments);
    return _ref19;
  }

  PCReturnStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCReturnStmt.prototype.toString = function(indent) {
    return "" + indent + "return" + (this.children.length === 1 ? " " + (this.children[0].toString()) : "") + ";";
  };

  return PCReturnStmt;

})(PCNode);

PCPrimitiveStmt = (function(_super) {
  __extends(PCPrimitiveStmt, _super);

  function PCPrimitiveStmt(kind, expression) {
    this.kind = kind;
    if (expression) {
      PCPrimitiveStmt.__super__.constructor.call(this, expression);
    } else {
      PCPrimitiveStmt.__super__.constructor.call(this);
    }
  }

  PCPrimitiveStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCPrimitiveStmt.prototype.toString = function(indent) {
    return "" + indent + (PCPrimitiveStmt.kindToString(this.kind)) + (this.children.length === 1 ? " " + (this.children[0].toString()) : "") + ";";
  };

  return PCPrimitiveStmt;

})(PCNode);

PCPrimitiveStmt.JOIN = 0;

PCPrimitiveStmt.LOCK = 1;

PCPrimitiveStmt.UNLOCK = 2;

PCPrimitiveStmt.WAIT = 3;

PCPrimitiveStmt.SIGNAL = 4;

PCPrimitiveStmt.SIGNAL_ALL = 5;

PCPrimitiveStmt.kindToString = function(kind) {
  switch (kind) {
    case PCPrimitiveStmt.JOIN:
      return "join";
    case PCPrimitiveStmt.LOCK:
      return "lock";
    case PCPrimitiveStmt.UNLOCK:
      return "unlock";
    case PCPrimitiveStmt.WAIT:
      return "waitForCondition";
    case PCPrimitiveStmt.SIGNAL:
      return "signal";
    case PCPrimitiveStmt.SIGNAL_ALL:
      return "signal all";
  }
};

PCPrintStmt = (function(_super) {
  __extends(PCPrintStmt, _super);

  function PCPrintStmt() {
    _ref20 = PCPrintStmt.__super__.constructor.apply(this, arguments);
    return _ref20;
  }

  PCPrintStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCPrintStmt.prototype.toString = function(indent) {
    var o;
    return "" + indent + "println(" + (((function() {
      var _i, _len, _ref21, _results;
      _ref21 = this.children;
      _results = [];
      for (_i = 0, _len = _ref21.length; _i < _len; _i++) {
        o = _ref21[_i];
        _results.push(o.toString());
      }
      return _results;
    }).call(this)).join(", ")) + ");";
  };

  return PCPrintStmt;

})(PCNode);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	This class represents PseuCo's types.
	May be partly incomplete as type checking is not yet completely supported by the PseuCo tree.
*/


PCTType = (function() {
  function PCTType(kind) {
    this.kind = kind;
    if (this.kind < 0 || this.kind > 14) {
      throw new Error("Unknown kind of type!");
    }
  }

  PCTType.prototype.isEqual = function(type) {
    return type.kind === this.kind;
  };

  PCTType.prototype.toString = function() {
    switch (this.kind) {
      case PCTType.INT:
        return "int";
      case PCTType.BOOL:
        return "bool";
      case PCTType.STRING:
        return "string";
      case PCTType.CHANNEL:
        return "channel";
      case PCTType.ARRAY:
        return "array";
      case PCTType.MONITOR:
        return "monitor";
      case PCTType.STRUCTURE:
        return "struct";
      case PCTType.MUTEX:
        return "mutex";
      case PCTType.CONDITION:
        return "condition";
      case PCTType.PROCEDURE:
        return "procedure";
      case PCTType.TYPE:
        return "type";
      case PCTType.MAINAGENT:
        return "mainAgent";
      case PCTType.AGENT:
        return "agent";
      case PCTType.WILDCARD:
        return "wildcard";
      default:
        return "void";
    }
  };

  return PCTType;

})();

PCTType.VOID = 0;

PCTType.BOOL = 1;

PCTType.INT = 2;

PCTType.STRING = 3;

PCTType.CHANNEL = 4;

PCTType.ARRAY = 5;

PCTType.MONITOR = 6;

PCTType.STRUCT = 7;

PCTType.MUTEX = 8;

PCTType.CONDITION = 9;

PCTType.PROCEDURE = 10;

PCTType.TYPE = 11;

PCTType.MAINAGENT = 12;

PCTType.AGENT = 13;

PCTType.WILDCARD = 14;

PCTArrayType = (function(_super) {
  __extends(PCTArrayType, _super);

  function PCTArrayType(elementsType, capacity) {
    this.elementsType = elementsType;
    this.capacity = capacity;
    PCTArrayType.__super__.constructor.call(this, PCTType.ARRAY);
  }

  PCTArrayType.prototype.isEqual = function(type) {
    var capacityFulfilled;
    capacityFulfilled = type.capacity === this.capacity || this.capacity === 0 || type.capacity === 0;
    return type.kind === this.kind && capacityFulfilled && this.elementsType.isEqual(type.elementsType);
  };

  PCTArrayType.prototype.toString = function() {
    return "" + (this.elementsType.toString()) + "[" + this.capacity + "]";
  };

  return PCTArrayType;

})(PCTType);

PCTChannelType = (function(_super) {
  __extends(PCTChannelType, _super);

  function PCTChannelType(channelledType, capacity) {
    this.channelledType = channelledType;
    this.capacity = capacity;
    PCTChannelType.__super__.constructor.call(this, PCTType.CHANNEL);
  }

  PCTChannelType.prototype.isEqual = function(type) {
    return this.kind === type.kind && this.capacity === type.capacity && this.channelledType.isEqual(type.channelledType);
  };

  PCTChannelType.prototype.isAssignableTo = function(type) {
    return this.kind === type.kind && (this.capacity === type.capacity || type.capacity === 0) && this.channelledType.isEqual(type.channelledType);
  };

  PCTChannelType.prototype.getApplicableCapacity = function() {
    if (this.capacity === PCChannelType.CAPACITY_UNKNOWN) {
      return 0;
    } else {
      return this.capacity;
    }
  };

  PCTChannelType.prototype.toString = function() {
    if (this.capacity === PCChannelType.CAPACITY_UNKNOWN) {
      return "handshake " + (this.channelledType.toString()) + " " + PCTChannelType.__super__.toString.apply(this, arguments);
    } else {
      return "" + (this.channelledType.toString()) + " " + PCTChannelType.__super__.toString.apply(this, arguments) + " of capacity " + this.capacity;
    }
  };

  return PCTChannelType;

})(PCTType);

PCTClassType = (function(_super) {
  __extends(PCTClassType, _super);

  function PCTClassType(isMonitor, identifier) {
    this.identifier = identifier;
    PCTClassType.__super__.constructor.call(this, (isMonitor ? PCTType.MONITOR : PCTType.STRUCT));
  }

  PCTClassType.prototype.isMonitor = function() {
    return this.kind === PCTType.MONITOR;
  };

  PCTClassType.prototype.isEqual = function(type) {
    return this.kind === type.kind && this.identifier === type.identifier;
  };

  PCTClassType.prototype.toString = function() {
    return "" + PCTClassType.__super__.toString.apply(this, arguments) + " " + this.identifier;
  };

  return PCTClassType;

})(PCTType);

PCTProcedureType = (function(_super) {
  __extends(PCTProcedureType, _super);

  function PCTProcedureType(returnType, argumentTypes) {
    this.returnType = returnType;
    this.argumentTypes = argumentTypes;
    PCTProcedureType.__super__.constructor.call(this, PCTType.PROCEDURE);
  }

  PCTProcedureType.prototype.isEqual = function(type) {
    var i, _i, _ref21;
    if (type.argumentTypes.length !== this.argumentTypes) {
      return false;
    }
    for (i = _i = 0, _ref21 = this.argumentTypes.length; _i < _ref21; i = _i += 1) {
      if (!type.argumentTypes[i].isEqual(this.argumentTypes[i])) {
        return false;
      }
    }
    return type.returnType.isEqual(this.returnType);
  };

  PCTProcedureType.prototype.toString = function() {
    var args, t;
    args = ((function() {
      var _i, _len, _ref21, _results;
      _ref21 = this.argumentTypes;
      _results = [];
      for (_i = 0, _len = _ref21.length; _i < _len; _i++) {
        t = _ref21[_i];
        _results.push(t.toString());
      }
      return _results;
    }).call(this)).join(" x ");
    return "" + (this.returnType.toString()) + " -> (" + args + ")";
  };

  return PCTProcedureType;

})(PCTType);

PCTTypeType = (function(_super) {
  __extends(PCTTypeType, _super);

  function PCTTypeType(type) {
    this.type = type;
    PCTTypeType.__super__.constructor.call(this, PCTType.TYPE);
  }

  PCTTypeType.prototype.isEqual = function(type) {
    return this.kind === type.kind && this.type.isEqual(type.type);
  };

  return PCTTypeType;

})(PCTType);

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
	ToDo
*/


PCTEnvironmentController = (function() {
  function PCTEnvironmentController() {
    this.root = new PCTEnvironmentNode(null, "");
    this.classes = {};
    this._envStack = this.root;
  }

  PCTEnvironmentController.prototype.getGlobal = function() {
    return this.root;
  };

  PCTEnvironmentController.prototype.getClassWithName = function(name) {
    var result;
    result = this.classes[name];
    if (result === void 0) {
      throw new Error("Unknown class");
    }
    return result;
  };

  PCTEnvironmentController.prototype.getAllClasses = function() {
    return this.root.getAllClasses();
  };

  PCTEnvironmentController.prototype.getVariableWithName = function(name) {
    return this._envStack.getVariableWithName(name);
  };

  PCTEnvironmentController.prototype.getProcedureWithName = function(name) {
    return this._envStack.getProcedureWithName(name);
  };

  PCTEnvironmentController.prototype.processNewClass = function(node, classType) {
    var tnode;
    tnode = new PCTClass(node, classType);
    return this._processNewClass(tnode);
  };

  PCTEnvironmentController.prototype._processNewClass = function(node) {
    if (this.classes[node.getName()]) {
      throw new Error("Class already registered!");
    }
    this._envStack.addChild(node);
    return this.classes[node.getName()] = node;
  };

  PCTEnvironmentController.prototype.beginClass = function(className) {
    var node;
    node = this.getClassWithName(className);
    if (!node) {
      throw new Error("Node must not be null!");
    }
    this._envStack = node;
    return node;
  };

  PCTEnvironmentController.prototype.endClass = function() {
    if (!this._envStack instanceof PCTClass) {
      throw new Error("No class did begin!");
    }
    return this._envStack = this._envStack.parent;
  };

  PCTEnvironmentController.prototype.beginNewProcedure = function(node, procedureName, returnType, args) {
    var tnode;
    tnode = new PCTProcedure(node, procedureName, returnType, args);
    return this._beginNewProcedure(tnode);
  };

  PCTEnvironmentController.prototype._beginNewProcedure = function(node) {
    this._envStack.addChild(node);
    return this.beginProcedure(node.getName());
  };

  PCTEnvironmentController.prototype.beginProcedure = function(procedureName) {
    var node;
    node = this._envStack.getProcedureWithName(procedureName);
    if (!node) {
      throw new Error("Node must not be null!");
    }
    this._envStack = node;
    return node;
  };

  PCTEnvironmentController.prototype.endProcedure = function() {
    if (!this._envStack instanceof PCTProcedure) {
      throw new Error("No procedure did begin!");
    }
    return this._envStack = this._envStack.parent;
  };

  PCTEnvironmentController.prototype.beginMainAgent = function(node) {
    if (this._envStack.getProcedureWithName("#mainAgent")) {
      return this.beginProcedure("#mainAgent");
    } else {
      return this.beginNewProcedure(node, "#mainAgent", new PCTType(PCTType.VOID), []);
    }
  };

  PCTEnvironmentController.prototype.endMainAgent = function() {
    return this.endProcedure();
  };

  PCTEnvironmentController.prototype.processNewVariable = function(variable) {
    return this._processNewVariable(variable);
  };

  PCTEnvironmentController.prototype._processNewVariable = function(node) {
    this._envStack.addChild(node);
    return node;
  };

  return PCTEnvironmentController;

})();

PCTEnvironmentNode = (function() {
  function PCTEnvironmentNode(node, label) {
    this.node = node;
    this.label = label;
    this.parent = null;
    this.children = [];
    this.variables = {};
    this.procedures = {};
  }

  PCTEnvironmentNode.prototype.addChild = function(child) {
    this.children.push(child);
    child.parent = this;
    if (child instanceof PCTProcedure) {
      this.procedures[child.getName()] = child;
    } else if (child instanceof PCTVariable) {
      this.variables[child.getIdentifier()] = child;
    }
    return child;
  };

  PCTEnvironmentNode.prototype.getVariableWithName = function(name) {
    return this.variables[name];
  };

  PCTEnvironmentNode.prototype.getProcedureWithName = function(name) {
    return this.procedures[name];
  };

  PCTEnvironmentNode.prototype.getComposedLabel = function() {
    return "" + (this.parent ? "" + (this.parent.getComposedLabel()) + "_" : "") + this.label;
  };

  PCTEnvironmentNode.prototype.getAllClasses = function() {
    var c, result, _i, _len, _ref21;
    result = [];
    _ref21 = this.children;
    for (_i = 0, _len = _ref21.length; _i < _len; _i++) {
      c = _ref21[_i];
      if (c instanceof PCTClass) {
        result.push(c);
      }
    }
    return result;
  };

  return PCTEnvironmentNode;

})();

PCTClass = (function(_super) {
  __extends(PCTClass, _super);

  function PCTClass(node, type) {
    this.type = type;
    PCTClass.__super__.constructor.call(this, node, this.type.identifier);
  }

  PCTClass.prototype.getName = function() {
    return this.label;
  };

  PCTClass.prototype.isMonitor = function() {
    return this.type.isMonitor();
  };

  return PCTClass;

})(PCTEnvironmentNode);

PCTProcedure = (function(_super) {
  __extends(PCTProcedure, _super);

  function PCTProcedure(node, name, returnType, _arguments) {
    this.returnType = returnType;
    this["arguments"] = _arguments;
    PCTProcedure.__super__.constructor.call(this, node, name);
  }

  PCTProcedure.prototype.getName = function() {
    return this.label;
  };

  PCTProcedure.prototype.isClassProcedure = function() {
    return this.parent instanceof PCClass;
  };

  PCTProcedure.prototype.isMonitorProcedure = function() {
    return this.parent instanceof PCClass && this.parent.isMonitor();
  };

  return PCTProcedure;

})(PCTEnvironmentNode);

PCTVariable = (function() {
  function PCTVariable(node, name, type) {
    this.node = node;
    this.type = type;
    if (typeof this.node === "string") {
      debugger;
    }
    this.label = name;
    this.parent = null;
  }

  PCTVariable.prototype.getName = function() {
    return this.label;
  };

  PCTVariable.prototype.getIdentifier = function() {
    return this.label;
  };

  PCTVariable.prototype.getComposedLabel = function() {
    return "" + (this.parent ? "" + (this.parent.getComposedLabel()) + "_" : "") + this.label;
  };

  return PCTVariable;

})();

/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


exports = module && module.exports ? module.exports : {};

exports["parser"] = PseuCoParser;

exports["EnvironmentController"] = PCTEnvironmentController;

exports["EnvironmentNode"] = PCTEnvironmentNode;

exports["Class"] = PCTClass;

exports["Procedure"] = PCTProcedure;

exports["Variable"] = PCTVariable;

exports["Type"] = PCTType;

exports["ArrayType"] = PCTArrayType;

exports["ChannelType"] = PCTChannelType;

exports["ClassType"] = PCTClassType;

exports["ProcedureType"] = PCTProcedureType;

exports["TypeType"] = PCTTypeType;

exports["Node"] = PCNode;

exports["Program"] = PCProgram;

exports["MainAgent"] = PCMainAgent;

exports["ProcedureDecl"] = PCProcedureDecl;

exports["FormalParameter"] = PCFormalParameter;

exports["Monitor"] = PCMonitor;

exports["Struct"] = PCStruct;

exports["ConditionDecl"] = PCConditionDecl;

exports["Decl"] = PCDecl;

exports["DeclStmt"] = PCDeclStmt;

exports["VariableDeclarator"] = PCVariableDeclarator;

exports["VariableInitializer"] = PCVariableInitializer;

exports["ArrayTypeNode"] = PCArrayType;

exports["BaseTypeNode"] = PCBaseType;

exports["SimpleTypeNode"] = PCSimpleType;

exports["ChannelTypeNode"] = PCChannelType;

exports["ClassTypeNode"] = PCClassType;

exports["Expression"] = PCExpression;

exports["StartExpression"] = PCStartExpression;

exports["AssignExpression"] = PCAssignExpression;

exports["AssignDestination"] = PCAssignDestination;

exports["SendExpression"] = PCSendExpression;

exports["ConditionalExpression"] = PCConditionalExpression;

exports["OrExpression"] = PCOrExpression;

exports["AndExpression"] = PCAndExpression;

exports["EqualityExpression"] = PCEqualityExpression;

exports["RelationalExpression"] = PCRelationalExpression;

exports["AdditiveExpression"] = PCAdditiveExpression;

exports["MultiplicativeExpression"] = PCMultiplicativeExpression;

exports["UnaryExpression"] = PCUnaryExpression;

exports["PostfixExpression"] = PCPostfixExpression;

exports["ReceiveExpression"] = PCReceiveExpression;

exports["ProcedureCall"] = PCProcedureCall;

exports["ClassCall"] = PCClassCall;

exports["ArrayExpression"] = PCArrayExpression;

exports["LiteralExpression"] = PCLiteralExpression;

exports["IdentifierExpression"] = PCIdentifierExpression;

exports["Statement"] = PCStatement;

exports["BreakStmt"] = PCBreakStmt;

exports["ContinueStmt"] = PCContinueStmt;

exports["StmtBlock"] = PCStmtBlock;

exports["StmtExpression"] = PCStmtExpression;

exports["SelectStmt"] = PCSelectStmt;

exports["Case"] = PCCase;

exports["IfStmt"] = PCIfStmt;

exports["WhileStmt"] = PCWhileStmt;

exports["DoStmt"] = PCDoStmt;

exports["ForStmt"] = PCForStmt;

exports["ForInit"] = PCForInit;

exports["ReturnStmt"] = PCReturnStmt;

exports["PrimitiveStmt"] = PCPrimitiveStmt;

exports["PrintStmt"] = PCPrintStmt;

},{}]},{},[1])