// Generated by CoffeeScript 1.6.3
/*
PseuCo Compiler
Copyright (C) 2013 Sebastian Biewer

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var ActionSets, CCS, CCSAction, CCSAdditiveExpression, CCSBaseStep, CCSChannel, CCSChoice, CCSChoiceLRule, CCSChoiceRRule, CCSConcatenatingExpression, CCSCondRule, CCSCondition, CCSConstantExpression, CCSEqualityExpression, CCSExit, CCSExitChannel, CCSExitRule, CCSExpression, CCSGetMostGeneralType, CCSInput, CCSInputRule, CCSInternalActionCreate, CCSInternalChannel, CCSMatch, CCSMatchRule, CCSMultiplicativeExpression, CCSOutput, CCSOutputRule, CCSParLRule, CCSParRRule, CCSParallel, CCSPrefix, CCSPrefixRule, CCSProcess, CCSProcessApplication, CCSProcessDefinition, CCSRecRule, CCSRelationalExpression, CCSResRule, CCSRestriction, CCSSeq1Rule, CCSSeq2Rule, CCSSequence, CCSSimpleAction, CCSStep, CCSStop, CCSSyncExitRule, CCSSyncRule, CCSTypeChannel, CCSTypeUnknown, CCSTypeValue, CCSUIChannel, CCSVariableExpression, DP, DS, DSteps, ObjID, _DEBUG, _ref, _ref1, _ref2,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CCSInternalChannel = "\u03c4";

CCSExitChannel = "\u03b4";

CCSUIChannel = "\u03c8";

ObjID = 1;

_DEBUG = [];

DSteps = [];

DS = function() {
  var i, s, _i, _len;
  console.log(ccs.system.toString());
  DSteps = ccs.getPossibleSteps();
  for (i = _i = 0, _len = DSteps.length; _i < _len; i = ++_i) {
    s = DSteps[i];
    console.log("\"" + i + "\": " + (s.toString()));
  }
  return null;
};

DP = function(i) {
  ccs.performStep(DSteps[i]);
  return DS();
};

CCSTypeUnknown = 0;

CCSTypeChannel = 1;

CCSTypeValue = 2;

CCSGetMostGeneralType = function(t1, t2) {
  if (t2 === CCSTypeUnknown) {
    return t1;
  }
  if (t1 === CCSTypeUnknown) {
    return t2;
  }
  if (t1 === t2) {
    return t1;
  }
  throw new Error("Incopatible Types: " + t1 + " and " + t2 + "!");
};

CCS = (function() {
  function CCS(processDefinitions, system) {
    var pd, _i, _len, _ref;
    this.processDefinitions = processDefinitions;
    this.system = system;
    this.system.setCCS(this);
    _ref = this.processDefinitions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pd = _ref[_i];
      pd.setCCS(this);
      pd.computeArgTypes();
    }
  }

  CCS.prototype.getProcessDefinition = function(name, argCount) {
    var pd, result, _i, _len, _ref;
    result = null;
    _ref = this.processDefinitions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pd = _ref[_i];
      if (pd.name === name && argCount === pd.getArgCount()) {
        result = pd;
      }
    }
    return result;
  };

  CCS.prototype.getPossibleSteps = function(env) {
    return this.system.getPossibleSteps(env);
  };

  CCS.prototype.performStep = function(step) {
    return this.system = step.perform();
  };

  CCS.prototype.toString = function() {
    var process;
    return "" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.processDefinitions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        process = _ref[_i];
        _results.push(process.toString());
      }
      return _results;
    }).call(this)).join("")) + "\n" + (this.system.toString());
  };

  return CCS;

})();

CCSProcessDefinition = (function() {
  function CCSProcessDefinition(name, process, params) {
    var p;
    this.name = name;
    this.process = process;
    this.params = params;
    if (this.params) {
      this.types = (function() {
        var _i, _len, _ref, _results;
        _ref = this.params;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(CCSTypeUnknown);
        }
        return _results;
      }).call(this);
    }
  }

  CCSProcessDefinition.prototype.getArgCount = function() {
    if (this.params) {
      return this.params.length;
    } else {
      return 0;
    }
  };

  CCSProcessDefinition.prototype.setCCS = function(ccs) {
    return this.process.setCCS(ccs);
  };

  CCSProcessDefinition.prototype.computeArgTypes = function() {
    var x;
    if (!this.params) {
      return null;
    }
    return this.types = (function() {
      var _i, _len, _ref, _results;
      _ref = this.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(this.process.getTypeOfIdentifier(x, CCSTypeUnknown));
      }
      return _results;
    }).call(this);
  };

  CCSProcessDefinition.prototype.toString = function() {
    var result, _ref;
    result = this.name;
    if (((_ref = this.params) != null ? _ref.length : void 0) > 0) {
      result += "[" + (this.params.join(", ")) + "]";
    }
    result += " := " + (this.process.toString()) + "\n";
    return result;
  };

  return CCSProcessDefinition;

})();

CCSProcess = (function() {
  function CCSProcess() {
    var subprocesses;
    subprocesses = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.subprocesses = subprocesses;
    this.__id = ObjID++;
  }

  CCSProcess.prototype.setCCS = function(ccs) {
    var p, _i, _len, _ref, _results;
    this.ccs = ccs;
    _ref = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(p.setCCS(this.ccs));
    }
    return _results;
  };

  CCSProcess.prototype._setCCS = function(ccs) {
    this.ccs = ccs;
    if (!this.ccs) {
      throw "no ccs";
    }
    return this;
  };

  CCSProcess.prototype.getLeft = function() {
    return this.subprocesses[0];
  };

  CCSProcess.prototype.getRight = function() {
    return this.subprocesses[1];
  };

  CCSProcess.prototype.setLeft = function(left) {
    return this.subprocesses[0] = left;
  };

  CCSProcess.prototype.setRight = function(right) {
    return this.subprocesses[1] = right;
  };

  CCSProcess.prototype.replaceVariable = function(varName, exp) {
    var p, _i, _len, _ref, _results;
    _ref = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(p.replaceVariable(varName, exp));
    }
    return _results;
  };

  CCSProcess.prototype.replaceVariableWithValue = function(varName, val) {
    return this.replaceVariable(varName, new CCSConstantExpression(val));
  };

  CCSProcess.prototype.replaceChannelName = function(old, newID) {
    var p, _i, _len, _ref, _results;
    _ref = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(p.replaceChannelName(old, newID));
    }
    return _results;
  };

  CCSProcess.prototype.getTypeOfIdentifier = function(identifier, type) {
    var p, t, _i, _len, _ref;
    _ref = (function() {
      var _j, _len, _ref, _results;
      _ref = this.subprocesses;
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        p = _ref[_j];
        _results.push(p.getTypeOfIdentifier(identifier, type));
      }
      return _results;
    }).call(this);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      type = CCSGetMostGeneralType(type, t);
    }
    return type;
  };

  CCSProcess.prototype.getApplicapleRules = function() {
    return [];
  };

  CCSProcess.prototype.getPossibleSteps = function() {
    var rule;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.getApplicapleRules();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _results.push(rule.getPossibleSteps(this));
      }
      return _results;
    }).call(this)).concatChildren();
  };

  CCSProcess.prototype.needsBracketsForSubprocess = function(process) {
    return (this.getPrecedence != null) && (process.getPrecedence != null) && process.getPrecedence() < this.getPrecedence();
  };

  CCSProcess.prototype.stringForSubprocess = function(process) {
    if (this.needsBracketsForSubprocess(process)) {
      return "(" + (process.toString()) + ")";
    } else {
      return "" + (process.toString());
    }
  };

  CCSProcess.prototype.getPrefixes = function() {
    var p;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.subprocesses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.getPrefixes());
      }
      return _results;
    }).call(this)).concatChildren();
  };

  CCSProcess.prototype.getExits = function() {
    var p;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.subprocesses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.getExits());
      }
      return _results;
    }).call(this)).concatChildren();
  };

  return CCSProcess;

})();

CCSStop = (function(_super) {
  __extends(CCSStop, _super);

  function CCSStop() {
    _ref = CCSStop.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  CCSStop.prototype.getPrecedence = function() {
    return 12;
  };

  CCSStop.prototype.toString = function() {
    return "0";
  };

  CCSStop.prototype.copy = function() {
    return (new CCSStop())._setCCS(this.ccs);
  };

  return CCSStop;

})(CCSProcess);

CCSExit = (function(_super) {
  __extends(CCSExit, _super);

  function CCSExit() {
    _ref1 = CCSExit.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  CCSExit.prototype.getPrecedence = function() {
    return 12;
  };

  CCSExit.prototype.getApplicapleRules = function() {
    return [CCSExitRule];
  };

  CCSExit.prototype.getExits = function() {
    return [this];
  };

  CCSExit.prototype.toString = function() {
    return "1";
  };

  CCSExit.prototype.copy = function() {
    return (new CCSExit())._setCCS(this.ccs);
  };

  return CCSExit;

})(CCSProcess);

CCSProcessApplication = (function(_super) {
  __extends(CCSProcessApplication, _super);

  function CCSProcessApplication(processName, valuesToPass) {
    this.processName = processName;
    this.valuesToPass = valuesToPass != null ? valuesToPass : [];
    CCSProcessApplication.__super__.constructor.call(this);
  }

  CCSProcessApplication.prototype.getArgCount = function() {
    return this.valuesToPass.length;
  };

  CCSProcessApplication.prototype.getProcess = function() {
    var i, id, pd, _i, _ref2;
    if (this.process) {
      return this.process;
    }
    pd = this.ccs.getProcessDefinition(this.processName, this.getArgCount());
    this.process = pd.process.copy();
    if (pd.params) {
      for (i = _i = 0, _ref2 = pd.params.length - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        id = pd.params[i];
        if (pd.types[i] === CCSTypeChannel) {
          this.process.replaceChannelName(id, this.valuesToPass[i].variableName);
        } else {
          this.process.replaceVariable(id, this.valuesToPass[i]);
        }
      }
    }
    return this.process;
  };

  CCSProcessApplication.prototype.getPrecedence = function() {
    return 12;
  };

  CCSProcessApplication.prototype.getTypeOfIdentifier = function(identifier, type) {
    var i, pd, _i, _ref2;
    pd = this.ccs.getProcessDefinition(this.processName, this.getArgCount());
    if (pd.params) {
      for (i = _i = 0, _ref2 = pd.params.length - 1; _i <= _ref2; i = _i += 1) {
        type = this.valuesToPass[i].getTypeOfIdentifier(identifier, type);
        type = CCSGetMostGeneralType(type, pd.types[i]);
      }
    }
    return type;
  };

  CCSProcessApplication.prototype.getApplicapleRules = function() {
    return [CCSRecRule];
  };

  CCSProcessApplication.prototype.getPrefixes = function() {
    return this.getProcess().getPrefixes();
  };

  CCSProcessApplication.prototype.getExits = function() {
    if (this.process) {
      return this.process.getExits();
    } else {
      return [];
    }
  };

  CCSProcessApplication.prototype.replaceVariable = function(varName, exp) {
    var e;
    return this.valuesToPass = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.valuesToPass;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        e = _ref2[_i];
        _results.push(e.replaceVariable(varName, exp));
      }
      return _results;
    }).call(this);
  };

  CCSProcessApplication.prototype.replaceChannelName = function(old, newID) {
    var e, _i, _len, _ref2, _results;
    _ref2 = this.valuesToPass;
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      e = _ref2[_i];
      _results.push(e.replaceChannelName(old, newID));
    }
    return _results;
  };

  /*getProxy: -> 	# ToDo: cache result
  		pd = @ccs.getProcessDefinition(@processName, @getArgCount())
  		new ProcessApplicationProxy(@, pd.process.copy())
  */


  CCSProcessApplication.prototype.toString = function() {
    var e, result;
    result = this.processName;
    if (this.getArgCount() > 0) {
      result += "[" + (((function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.valuesToPass;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          e = _ref2[_i];
          _results.push(e.toString());
        }
        return _results;
      }).call(this)).join(", ")) + "]";
    }
    return result;
  };

  CCSProcessApplication.prototype.copy = function() {
    var v;
    return (new CCSProcessApplication(this.processName, (function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.valuesToPass;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        v = _ref2[_i];
        _results.push(v.copy());
      }
      return _results;
    }).call(this)))._setCCS(this.ccs);
  };

  return CCSProcessApplication;

})(CCSProcess);

CCSPrefix = (function(_super) {
  __extends(CCSPrefix, _super);

  function CCSPrefix(action, process) {
    this.action = action;
    CCSPrefix.__super__.constructor.call(this, process);
  }

  CCSPrefix.prototype.getPrecedence = function() {
    return 12;
  };

  CCSPrefix.prototype.getApplicapleRules = function() {
    return [CCSPrefixRule, CCSOutputRule, CCSInputRule];
  };

  CCSPrefix.prototype.getProcess = function() {
    return this.subprocesses[0];
  };

  CCSPrefix.prototype.replaceVariable = function(varName, exp) {
    if (this.action.replaceVariable(varName, exp)) {
      return CCSPrefix.__super__.replaceVariable.call(this, varName, exp);
    }
  };

  CCSPrefix.prototype.replaceChannelName = function(old, newID) {
    if (this.action.replaceChannelName(old, newID)) {
      return CCSPrefix.__super__.replaceChannelName.call(this, old, newID);
    }
  };

  CCSPrefix.prototype.getPrefixes = function() {
    return [this];
  };

  CCSPrefix.prototype.getTypeOfIdentifier = function(identifier, type) {
    type = this.action.getTypeOfIdentifier(identifier, type);
    if (this.action.isInputAction() && this.action.variable === identifier) {
      CCSPrefix.__super__.getTypeOfIdentifier.call(this, identifier, CCSTypeValue);
      return type;
    } else {
      return CCSPrefix.__super__.getTypeOfIdentifier.call(this, identifier, type);
    }
  };

  CCSPrefix.prototype.toString = function() {
    return "" + (this.action.toString()) + "." + (this.stringForSubprocess(this.getProcess()));
  };

  CCSPrefix.prototype.copy = function() {
    return (new CCSPrefix(this.action.copy(), this.getProcess().copy()))._setCCS(this.ccs);
  };

  return CCSPrefix;

})(CCSProcess);

CCSCondition = (function(_super) {
  __extends(CCSCondition, _super);

  function CCSCondition(expression, process) {
    this.expression = expression;
    CCSCondition.__super__.constructor.call(this, process);
  }

  CCSCondition.prototype.getPrecedence = function() {
    return 12;
  };

  CCSCondition.prototype.getApplicapleRules = function() {
    return [CCSCondRule];
  };

  CCSCondition.prototype.getProcess = function() {
    return this.subprocesses[0];
  };

  CCSCondition.prototype.getTypeOfIdentifier = function(identifier, type) {
    type = this.expression.getTypeOfIdentifier(identifier, type);
    return CCSCondition.__super__.getTypeOfIdentifier.call(this, identifier, type);
  };

  CCSCondition.prototype.replaceVariable = function(varName, exp) {
    this.expression = this.expression.replaceVariable(varName, exp);
    return CCSCondition.__super__.replaceVariable.call(this, varName, exp);
  };

  CCSCondition.prototype.toString = function() {
    return "when (" + (this.expression.toString()) + ") " + (this.stringForSubprocess(this.getProcess()));
  };

  CCSCondition.prototype.copy = function() {
    return (new CCSCondition(this.expression.copy(), this.getProcess().copy()))._setCCS(this.ccs);
  };

  return CCSCondition;

})(CCSProcess);

CCSChoice = (function(_super) {
  __extends(CCSChoice, _super);

  function CCSChoice(left, right) {
    CCSChoice.__super__.constructor.call(this, left, right);
  }

  CCSChoice.prototype.getPrecedence = function() {
    return 9;
  };

  CCSChoice.prototype.getApplicapleRules = function() {
    return [CCSChoiceLRule, CCSChoiceRRule];
  };

  CCSChoice.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getLeft())) + " + " + (this.stringForSubprocess(this.getRight()));
  };

  CCSChoice.prototype.copy = function() {
    return (new CCSChoice(this.getLeft().copy(), this.getRight().copy()))._setCCS(this.ccs);
  };

  return CCSChoice;

})(CCSProcess);

CCSParallel = (function(_super) {
  __extends(CCSParallel, _super);

  function CCSParallel(left, right) {
    CCSParallel.__super__.constructor.call(this, left, right);
  }

  CCSParallel.prototype.getPrecedence = function() {
    return 6;
  };

  CCSParallel.prototype.getApplicapleRules = function() {
    return [CCSParLRule, CCSParRRule, CCSSyncRule, CCSSyncExitRule];
  };

  CCSParallel.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getLeft())) + " | " + (this.stringForSubprocess(this.getRight()));
  };

  CCSParallel.prototype.copy = function() {
    return (new CCSParallel(this.getLeft().copy(), this.getRight().copy()))._setCCS(this.ccs);
  };

  return CCSParallel;

})(CCSProcess);

CCSSequence = (function(_super) {
  __extends(CCSSequence, _super);

  function CCSSequence(left, right) {
    CCSSequence.__super__.constructor.call(this, left, right);
  }

  CCSSequence.prototype.getPrecedence = function() {
    return 3;
  };

  CCSSequence.prototype.getApplicapleRules = function() {
    return [CCSSeq1Rule, CCSSeq2Rule];
  };

  CCSSequence.prototype.getPrefixes = function() {
    return this.getLeft().getPrefixes();
  };

  CCSSequence.prototype.getExits = function() {
    return this.getLeft().getExits();
  };

  CCSSequence.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getLeft())) + " ; " + (this.stringForSubprocess(this.getRight()));
  };

  CCSSequence.prototype.copy = function() {
    return (new CCSSequence(this.getLeft().copy(), this.getRight().copy()))._setCCS(this.ccs);
  };

  return CCSSequence;

})(CCSProcess);

CCSRestriction = (function(_super) {
  __extends(CCSRestriction, _super);

  function CCSRestriction(process, restrictedChannels) {
    this.restrictedChannels = restrictedChannels;
    CCSRestriction.__super__.constructor.call(this, process);
  }

  CCSRestriction.prototype.getPrecedence = function() {
    return 1;
  };

  CCSRestriction.prototype.getApplicapleRules = function() {
    return [CCSResRule];
  };

  CCSRestriction.prototype.getProcess = function() {
    return this.subprocesses[0];
  };

  CCSRestriction.prototype.setProcess = function(process) {
    return this.subprocesses[0] = process;
  };

  CCSRestriction.prototype.toString = function() {
    return "" + (this.stringForSubprocess(this.getProcess())) + " \\ {" + (this.restrictedChannels.join(", ")) + "}";
  };

  CCSRestriction.prototype.copy = function() {
    return (new CCSRestriction(this.getProcess().copy(), this.restrictedChannels))._setCCS(this.ccs);
  };

  return CCSRestriction;

})(CCSProcess);

CCSChannel = (function() {
  function CCSChannel(name, expression) {
    this.name = name;
    this.expression = expression != null ? expression : null;
  }

  CCSChannel.prototype.isEqual = function(channel) {
    if (channel.name !== this.name) {
      return false;
    }
    if (!channel.expression && !this.expression) {
      return true;
    }
    if (!channel.expression || !this.expression) {
      return false;
    }
    return channel.expression.evaluate() === this.expression.evaluate();
  };

  CCSChannel.prototype.replaceVariable = function(varName, exp) {
    if (this.expression) {
      this.expression = this.expression.replaceVariable(varName, exp);
    }
    return null;
  };

  CCSChannel.prototype.replaceChannelName = function(old, newID) {
    if (this.name === old) {
      this.name = newID;
    }
    return null;
  };

  CCSChannel.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this.name === identifier) {
      type = CCSGetMostGeneralType(type, CCSTypeChannel);
    }
    if (this.expression) {
      type = this.expression.getTypeOfIdentifier(identifier, type);
    }
    return type;
  };

  CCSChannel.prototype.toString = function() {
    var result;
    result = "" + this.name;
    if (this.expression) {
      if (this.expression.isEvaluatable()) {
        result += "(" + (this.expression.evaluate()) + ")";
      } else {
        result += "(" + (this.expression.toString()) + ")";
      }
    }
    return result;
  };

  CCSChannel.prototype.copy = function() {
    var _ref2;
    return new CCSChannel(this.name, (_ref2 = this.expression) != null ? _ref2.copy() : void 0);
  };

  return CCSChannel;

})();

/*
class CCSInternalChannel extends CCSChannel
	constructor: (name) ->
		if name != CCSInternalChannel or name != CCSExitChannel
			throw new Error("Only internal channel names are allowed!")
		super name, null
	isEqual: (channel) -> channel.name == @name and channel.expression == null
	replaceVariable: (varName, exp) -> null
	replaceChannelName: (old, newID) -> null
	getTypeOfIdentifier: (identifier, type) -> type
	toString: -> @name
*/


CCSAction = (function() {
  function CCSAction(channel) {
    this.channel = channel;
    if (this.channel === "i") {
      if (!this.isSimpleAction()) {
        throw new Error("Internal channel i is only allowed as simple action!");
      }
      this.channel = CCSInternalChannel;
    } else if (this.channel === "e") {
      if (!this.isSimpleAction()) {
        throw new Error("Exit channel e is only allowed as simple action!");
      }
      this.channel = CCSExitChannel;
    }
  }

  CCSAction.prototype.isSimpleAction = function() {
    return false;
  };

  CCSAction.prototype.isInputAction = function() {
    return false;
  };

  CCSAction.prototype.isMatchAction = function() {
    return false;
  };

  CCSAction.prototype.isOutputAction = function() {
    return false;
  };

  CCSAction.prototype.toString = function() {
    return this.channel.toString();
  };

  CCSAction.prototype.transferDescription = function() {
    return this.channel.toString();
  };

  CCSAction.prototype.isSyncableWithAction = function(action) {
    return false;
  };

  CCSAction.prototype.replaceVariable = function(varName, exp) {
    this.channel.replaceVariable(varName, exp);
    return true;
  };

  CCSAction.prototype.replaceChannelName = function(old, newID) {
    return this.channel.replaceChannelName(old, newID);
  };

  CCSAction.prototype.getTypeOfIdentifier = function(identifier, type) {
    return this.channel.getTypeOfIdentifier(identifier, type);
  };

  return CCSAction;

})();

CCSSimpleAction = (function(_super) {
  __extends(CCSSimpleAction, _super);

  function CCSSimpleAction() {
    _ref2 = CCSSimpleAction.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  CCSSimpleAction.prototype.isSimpleAction = function() {
    return true;
  };

  CCSSimpleAction.prototype.supportsValuePassing = function() {
    return false;
  };

  CCSSimpleAction.prototype.copy = function() {
    return new CCSSimpleAction(this.channel.copy());
  };

  return CCSSimpleAction;

})(CCSAction);

CCSInternalActionCreate = function(name) {
  if (name !== CCSInternalChannel && name !== CCSExitChannel) {
    throw new Error("Only internal channel names are allowed!");
  }
  return new CCSSimpleAction(new CCSChannel(name, null));
};

CCSInput = (function(_super) {
  __extends(CCSInput, _super);

  function CCSInput(channel, variable, range) {
    this.variable = variable;
    this.range = range;
    CCSInput.__super__.constructor.call(this, channel);
    this.incommingValue = null;
  }

  CCSInput.prototype.isInputAction = function() {
    return true;
  };

  CCSInput.prototype.supportsValuePassing = function() {
    return typeof this.variable === "string" && this.variable.length > 0;
  };

  CCSInput.prototype.isSyncableWithAction = function(action) {
    return (action != null ? action.isOutputAction() : void 0) && action.channel.isEqual(this.channel) && action.supportsValuePassing() === this.supportsValuePassing();
  };

  CCSInput.prototype.replaceVariable = function(varName, exp) {
    CCSInput.__super__.replaceVariable.call(this, varName, exp);
    return this.variable !== varName;
  };

  CCSInput.prototype.toString = function() {
    return "" + CCSInput.__super__.toString.apply(this, arguments) + "?" + (this.supportsValuePassing() ? this.variable : "");
  };

  CCSInput.prototype.transferDescription = function() {
    return "" + CCSInput.__super__.transferDescription.apply(this, arguments) + (this.supportsValuePassing() ? ": " + this.incommingValue : "");
  };

  CCSInput.prototype.copy = function() {
    return new CCSInput(this.channel.copy(), this.variable, this.range);
  };

  return CCSInput;

})(CCSAction);

CCSMatch = (function(_super) {
  __extends(CCSMatch, _super);

  function CCSMatch(channel, expression) {
    this.expression = expression;
    CCSMatch.__super__.constructor.call(this, channel);
  }

  CCSMatch.prototype.isMatchAction = function() {
    return true;
  };

  CCSMatch.prototype.supportsValuePassing = function() {
    return true;
  };

  CCSMatch.prototype.isSyncableWithAction = function(action) {
    return (action != null ? action.isOutputAction() : void 0) && action.channel.isEqual(this.channel) && action.supportsValuePassing() && action.expression.evaluate() === this.expression.evaluate();
  };

  CCSMatch.prototype.replaceVariable = function(varName, exp) {
    CCSMatch.__super__.replaceVariable.call(this, varName, exp);
    this.expression = this.expression.replaceVariable(varName, exp);
    return true;
  };

  CCSMatch.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this.expression) {
      type = this.expression.getTypeOfIdentifier(identifier, type);
    }
    return CCSMatch.__super__.getTypeOfIdentifier.call(this, identifier, type);
  };

  CCSMatch.prototype.toString = function() {
    return "" + CCSMatch.__super__.toString.apply(this, arguments) + "?=" + (this.expression ? this.expression.toString() : "");
  };

  CCSMatch.prototype.transferDescription = function() {
    throw new Error("Currently unsupported action");
  };

  CCSMatch.prototype.copy = function() {
    var _ref3;
    return new CCSMatch(this.channel.copy(), (_ref3 = this.expression) != null ? _ref3.copy() : void 0);
  };

  return CCSMatch;

})(CCSAction);

CCSOutput = (function(_super) {
  __extends(CCSOutput, _super);

  function CCSOutput(channel, expression) {
    this.expression = expression;
    CCSOutput.__super__.constructor.call(this, channel);
  }

  CCSOutput.prototype.isOutputAction = function() {
    return true;
  };

  CCSOutput.prototype.supportsValuePassing = function() {
    return this.expression instanceof CCSExpression;
  };

  CCSOutput.prototype.isSyncableWithAction = function(action) {
    if ((action != null ? action.isInputAction() : void 0) || action.isMatchAction()) {
      return action.isSyncableWithAction(this);
    } else {
      return false;
    }
  };

  CCSOutput.prototype.replaceVariable = function(varName, exp) {
    CCSOutput.__super__.replaceVariable.call(this, varName, exp);
    if (this.expression) {
      this.expression = this.expression.replaceVariable(varName, exp);
    }
    return true;
  };

  CCSOutput.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this.expression) {
      type = this.expression.getTypeOfIdentifier(identifier, type);
    }
    return CCSOutput.__super__.getTypeOfIdentifier.call(this, identifier, type);
  };

  CCSOutput.prototype.toString = function() {
    return "" + CCSOutput.__super__.toString.apply(this, arguments) + "!" + (this.expression ? this.expression.toString() : "");
  };

  CCSOutput.prototype.transferDescription = function() {
    return "" + CCSOutput.__super__.transferDescription.apply(this, arguments) + (this.expression ? ": " + this.expression.evaluate() : "");
  };

  CCSOutput.prototype.copy = function() {
    var _ref3;
    return new CCSOutput(this.channel.copy(), (_ref3 = this.expression) != null ? _ref3.copy() : void 0);
  };

  return CCSOutput;

})(CCSAction);

CCSExpression = (function() {
  function CCSExpression() {
    var subExps;
    subExps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.subExps = subExps;
  }

  CCSExpression.prototype.getLeft = function() {
    return this.subExps[0];
  };

  CCSExpression.prototype.getRight = function() {
    return this.subExps[1];
  };

  CCSExpression.prototype.replaceVariable = function(varName, exp) {
    var e;
    this.subExps = (function() {
      var _i, _len, _ref3, _results;
      _ref3 = this.subExps;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        e = _ref3[_i];
        _results.push(e.replaceVariable(varName, exp));
      }
      return _results;
    }).call(this);
    return this;
  };

  CCSExpression.prototype.replaceChannelName = function(old, newID) {
    return null;
  };

  CCSExpression.prototype.usesIdentifier = function(identifier) {
    return this._childrenUseIdentifier(identifier);
  };

  CCSExpression.prototype._childrenUseIdentifier = function(identifier) {
    var e, result, _i, _len, _ref3;
    result = false;
    _ref3 = this.subExps;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      e = _ref3[_i];
      result || e.usesIdentifier();
    }
    return result;
  };

  CCSExpression.prototype.getTypeOfIdentifier = function(identifier, type) {
    if (this._childrenUseIdentifier(identifier)) {
      type = CCSGetMostGeneralType(type, CCSTypeValue);
    }
    return type;
  };

  CCSExpression.prototype.evaluate = function() {
    throw new Error("Abstract method!");
  };

  CCSExpression.prototype.isEvaluatable = function() {
    return false;
  };

  CCSExpression.prototype.needsBracketsForSubExp = function(exp) {
    return (this.getPrecedence != null) && (exp.getPrecedence != null) && exp.getPrecedence() < this.getPrecedence();
  };

  CCSExpression.prototype.stringForSubExp = function(exp) {
    if (this.needsBracketsForSubExp(exp)) {
      return "(" + (exp.toString()) + ")";
    } else {
      return "" + (exp.toString());
    }
  };

  CCSExpression.prototype.toString = function() {
    throw new Error("Abstract method not implemented!");
  };

  CCSExpression.prototype.copy = function() {
    throw new Error("Abstract method not implemented!");
  };

  return CCSExpression;

})();

CCSConstantExpression = (function(_super) {
  __extends(CCSConstantExpression, _super);

  function CCSConstantExpression(value) {
    this.value = value;
    CCSConstantExpression.__super__.constructor.call(this);
  }

  CCSConstantExpression.prototype.getPrecedence = function() {
    return 18;
  };

  CCSConstantExpression.prototype.evaluate = function() {
    return CCSConstantExpression.valueToString(this.value);
  };

  CCSConstantExpression.prototype.isEvaluatable = function() {
    return true;
  };

  CCSConstantExpression.prototype.toString = function() {
    if (typeof this.value === "string") {
      return '"' + this.value + '"';
    } else {
      return "" + this.value;
    }
  };

  CCSConstantExpression.prototype.copy = function() {
    return new CCSConstantExpression(this.value);
  };

  return CCSConstantExpression;

})(CCSExpression);

CCSConstantExpression.valueToString = function(value) {
  if (typeof value === "boolean") {
    value = (value === true ? "1" : "0");
  }
  return value = "" + value;
};

CCSVariableExpression = (function(_super) {
  __extends(CCSVariableExpression, _super);

  function CCSVariableExpression(variableName) {
    this.variableName = variableName;
    CCSVariableExpression.__super__.constructor.call(this);
  }

  CCSVariableExpression.prototype.getPrecedence = function() {
    return 18;
  };

  CCSVariableExpression.prototype.usesIdentifier = function(identifier) {
    return identifier === this.variableName;
  };

  CCSVariableExpression.prototype.replaceVariable = function(varName, exp) {
    if (varName === this.variableName) {
      return exp;
    } else {
      return this;
    }
  };

  CCSVariableExpression.prototype.replaceChannelName = function(old, newID) {
    if (this.variableName === old) {
      return this.variableName = newID;
    }
  };

  CCSVariableExpression.prototype.evaluate = function() {
    throw new Error('Unbound identifier!');
  };

  CCSVariableExpression.prototype.isEvaluatable = function() {
    return false;
  };

  CCSVariableExpression.prototype.toString = function() {
    return this.variableName;
  };

  CCSVariableExpression.prototype.copy = function() {
    return new CCSVariableExpression(this.variableName);
  };

  return CCSVariableExpression;

})(CCSExpression);

CCSAdditiveExpression = (function(_super) {
  __extends(CCSAdditiveExpression, _super);

  function CCSAdditiveExpression(left, right, op) {
    this.op = op;
    CCSAdditiveExpression.__super__.constructor.call(this, left, right);
  }

  CCSAdditiveExpression.prototype.getPrecedence = function() {
    return 15;
  };

  CCSAdditiveExpression.prototype.evaluate = function() {
    var l, r;
    l = parseInt(this.getLeft().evaluate());
    r = parseInt(this.getRight().evaluate());
    return "" + ((function() {
      if (this.op === "+") {
        return l + r;
      } else if (this.op === "-") {
        return l - r;
      } else {
        throw new Error("Invalid operator!");
      }
    }).call(this));
  };

  CCSAdditiveExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSAdditiveExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSAdditiveExpression.prototype.copy = function() {
    return new CCSAdditiveExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSAdditiveExpression;

})(CCSExpression);

CCSMultiplicativeExpression = (function(_super) {
  __extends(CCSMultiplicativeExpression, _super);

  function CCSMultiplicativeExpression(left, right, op) {
    this.op = op;
    CCSMultiplicativeExpression.__super__.constructor.call(this, left, right);
  }

  CCSMultiplicativeExpression.prototype.getPrecedence = function() {
    return 12;
  };

  CCSMultiplicativeExpression.prototype.evaluate = function() {
    var l, r;
    l = parseInt(this.getLeft().evaluate());
    r = parseInt(this.getRight().evaluate());
    if (this.op === "*") {
      return l * r;
    } else if (this.op === "/") {
      return Math.floor(l / r);
    } else {
      throw new Error("Invalid operator!");
    }
  };

  CCSMultiplicativeExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSMultiplicativeExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSMultiplicativeExpression.prototype.copy = function() {
    return new CCSMultiplicativeExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSMultiplicativeExpression;

})(CCSExpression);

CCSConcatenatingExpression = (function(_super) {
  __extends(CCSConcatenatingExpression, _super);

  function CCSConcatenatingExpression(left, right) {
    CCSConcatenatingExpression.__super__.constructor.call(this, left, right);
  }

  CCSConcatenatingExpression.prototype.getPrecedence = function() {
    return 9;
  };

  CCSConcatenatingExpression.prototype.evaluate = function() {
    return "" + this.getLeft().evaluate() + this.getRight().evaluate();
  };

  CCSConcatenatingExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSConcatenatingExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + "^" + this.stringForSubExp(this.getRight());
  };

  CCSConcatenatingExpression.prototype.copy = function() {
    return new CCSConcatenatingExpression(this.getLeft().copy(), this.getRight().copy());
  };

  return CCSConcatenatingExpression;

})(CCSExpression);

CCSRelationalExpression = (function(_super) {
  __extends(CCSRelationalExpression, _super);

  function CCSRelationalExpression(left, right, op) {
    this.op = op;
    CCSRelationalExpression.__super__.constructor.call(this, left, right);
  }

  CCSRelationalExpression.prototype.getPrecedence = function() {
    return 6;
  };

  CCSRelationalExpression.prototype.evaluate = function() {
    var l, r, res;
    l = parseInt(this.getLeft().evaluate());
    r = parseInt(this.getRight().evaluate());
    res = (function() {
      if (this.op === "<") {
        return l < r;
      } else if (this.op === "<=") {
        return l <= r;
      } else if (this.op === ">") {
        return l > r;
      } else if (this.op === ">=") {
        return l >= r;
      } else {
        throw new Error("Invalid operator!");
      }
    }).call(this);
    return CCSConstantExpression.valueToString(res);
  };

  CCSRelationalExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSRelationalExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSRelationalExpression.prototype.copy = function() {
    return new CCSRelationalExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSRelationalExpression;

})(CCSExpression);

CCSEqualityExpression = (function(_super) {
  __extends(CCSEqualityExpression, _super);

  function CCSEqualityExpression(left, right, op) {
    this.op = op;
    CCSEqualityExpression.__super__.constructor.call(this, left, right);
  }

  CCSEqualityExpression.prototype.getPrecedence = function() {
    return 3;
  };

  CCSEqualityExpression.prototype.evaluate = function() {
    var l, r, res;
    l = this.getLeft().evaluate();
    r = this.getRight().evaluate();
    res = (function() {
      if (this.op === "==") {
        return l === r;
      } else if (this.op === "!=") {
        return l !== r;
      } else {
        throw new Error("Invalid operator!");
      }
    }).call(this);
    return CCSConstantExpression.valueToString(res);
  };

  CCSEqualityExpression.prototype.isEvaluatable = function() {
    return this.getLeft().isEvaluatable() && this.getRight().isEvaluatable();
  };

  CCSEqualityExpression.prototype.toString = function() {
    return this.stringForSubExp(this.getLeft()) + this.op + this.stringForSubExp(this.getRight());
  };

  CCSEqualityExpression.prototype.copy = function() {
    return new CCSEqualityExpression(this.getLeft().copy(), this.getRight().copy(), this.op);
  };

  return CCSEqualityExpression;

})(CCSExpression);

ActionSets = {
  isActionInK: function(action) {
    return ActionSets.isActionInCom(action) && action.isSimpleAction();
  },
  isActionInCom: function(action) {
    return ActionSets.isActionInAct(action) && action.channel.name !== CCSInternalChannel;
  },
  isActionInAct: function(action) {
    return ActionSets.isActionInActPlus(action) && action.channel.name !== CCSExitChannel;
  },
  isActionInActPlus: function(action) {
    return !action.supportsValuePassing();
  },
  isActionInComVP: function(action) {
    return ActionSets.isActionInActVP(action) && action.channel.name !== CCSInternalChannel;
  },
  isActionInActVP: function(action) {
    return action.channel.name !== CCSExitChannel;
  },
  isActionInActVPPlus: function(action) {
    return true;
  }
};

Array.prototype.filterKSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInK(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterComSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInCom(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInAct(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActPlusSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInActPlus(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterComVPSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInComVP(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActVPSteps = function() {
  var filter;
  filter = function(step) {
    return ActionSets.isActionInActVP(step.action);
  };
  return this.filter(filter);
};

Array.prototype.filterActVPPlusSteps = function() {
  return this;
};

String.prototype.replaceAll = function(needle, replacement) {
	var t = this
	var tt = this
	do {
		t = tt;
		tt = t.replace(needle, replacement);
	} while (t != tt);
	return t;
}

Array.prototype.concatChildren = function() {
	if (this.length == 0)
		return [];
	var target = this.concat([]);	// Copy
	var result = target.shift().concat([]);	// Result should always be a copy
	while (target.length > 0) {
		result = result.concat(target.shift());
	}
	return result;
}

Array.prototype.joinChildren = function(separator) {
	var result = [];
	var i = 0;
	while(true) {
		var joinTarget = [];
		for (var c = 0; c < this.length; c++) {
			if (this[c][i]) joinTarget.push(this[c][i]);
		}
		if (joinTarget.length == 0)
			break;
		result[i++] = joinTarget.join(separator);
	}
	return result;
};

Array.prototype.assertNonNull = function() {
  var e, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = this.length; _i < _len; _i++) {
    e = this[_i];
    _results.push((function() {
      if (typeof e === "undefined" || e === null) {
        throw new Error("Null element found!");
      }
    })());
  }
  return _results;
};

CCSProcess.prototype.findApp = function(name) {
  var c;
  return ((function() {
    var _i, _len, _ref3, _results;
    _ref3 = this.subprocesses;
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      c = _ref3[_i];
      _results.push(c.findApp(name));
    }
    return _results;
  }).call(this)).joinChildren();
};

CCSProcessApplication.prototype.findApp = function(name) {
  debugger;
  if (name === this.processName) {
    return [this];
  } else {
    return [];
  }
};

CCSPrefix.prototype.findApp = function() {
  return [];
};

/*
PseuCo Compiler
Copyright (C) 2013 Sebastian Biewer

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


CCSStep = (function() {
  function CCSStep() {
    var action, actionDetails, index, process, rule, s, substeps, _i, _len, _ref3;
    index = arguments[0], process = arguments[1], action = arguments[2], rule = arguments[3], actionDetails = arguments[4], substeps = 6 <= arguments.length ? __slice.call(arguments, 5) : [];
    this.index = index;
    this.process = process;
    this.action = action;
    this.rule = rule;
    this.actionDetails = actionDetails;
    this.substeps = substeps;
    _ref3 = this.substeps;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      s = _ref3[_i];
      if (s === void 0 || s === null) {
        throw "substep must not be nil!";
      }
    }
    if (!this.actionDetails) {
      this.actionDetails = this.substeps.length === 1 ? this.substeps[0].actionDetails : "";
    }
  }

  CCSStep.prototype.getLeafProcesses = function() {
    var step;
    if (this.substeps.length === 0) {
      return [this.process];
    } else {
      return ((function() {
        var _i, _len, _ref3, _results;
        _ref3 = this.substeps;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          step = _ref3[_i];
          _results.push(step.getLeafProcesses());
        }
        return _results;
      }).call(this)).concatChildren();
    }
  };

  CCSStep.prototype.perform = function() {
    return this.rule.performStep(this);
  };

  CCSStep.prototype.toString = function() {
    return this.action.toString() + (this.actionDetails.length > 0 ? " " + this.actionDetails : "");
  };

  return CCSStep;

})();

CCSBaseStep = (function(_super) {
  __extends(CCSBaseStep, _super);

  function CCSBaseStep(prefix, rule) {
    CCSBaseStep.__super__.constructor.call(this, 0, prefix, prefix.action, rule);
  }

  return CCSBaseStep;

})(CCSStep);

CCSPrefixRule = {
  getPossibleSteps: function(prefix) {
    if ((prefix != null ? prefix.action.isSimpleAction() : void 0) || !prefix.action.supportsValuePassing()) {
      return [new CCSBaseStep(prefix, this)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.process.getProcess();
  }
};

CCSOutputRule = {
  getPossibleSteps: function(prefix) {
    if ((prefix != null ? prefix.action.isOutputAction() : void 0) && prefix.action.supportsValuePassing()) {
      return [new CCSBaseStep(prefix, this)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.process.getProcess();
  }
};

CCSInputRule = {
  getPossibleSteps: function(prefix) {
    if ((prefix != null ? prefix.action.isInputAction() : void 0) && prefix.action.supportsValuePassing()) {
      return [new CCSBaseStep(prefix, this)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    var result;
    if (step.process.action.incommingValue === void 0) {
      throw new Error("Input action's incomming value was not set!");
    }
    result = step.process.getProcess();
    result.replaceVariableWithValue(step.process.action.variable, step.process.action.incommingValue);
    return result;
  }
};

CCSMatchRule = {
  getPossibleSteps: function(prefix) {
    if (prefix != null ? prefix.action.isMatchAction() : void 0) {
      return [new CCSBaseStep(prefix, this)];
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.process.getProcess();
  }
};

CCSChoiceLRule = {
  getPossibleSteps: function(choice) {
    var i, step, _i, _len, _ref3, _results;
    i = 0;
    _ref3 = choice.getLeft().getPossibleSteps().filterActVPPlusSteps();
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      step = _ref3[_i];
      _results.push(new CCSStep(i++, choice, step.action, this, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

CCSChoiceRRule = {
  getPossibleSteps: function(choice) {
    var i, step, _i, _len, _ref3, _results;
    i = 0;
    _ref3 = choice.getRight().getPossibleSteps().filterActVPPlusSteps();
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      step = _ref3[_i];
      _results.push(new CCSStep(i++, choice, step.action, this, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

CCSParLRule = {
  getPossibleSteps: function(parallel) {
    var i, step;
    if (!parallel._CCSParLRule) {
      i = 0;
      parallel._CCSParLRule = (function() {
        var _i, _len, _ref3, _results;
        _ref3 = parallel.getLeft().getPossibleSteps().filterActVPSteps();
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          step = _ref3[_i];
          _results.push(new CCSStep(i++, parallel, step.action, this, null, step));
        }
        return _results;
      }).call(this);
    }
    return parallel._CCSParLRule;
  },
  performStep: function(step) {
    step.process._CCSSyncRule = void 0;
    step.process._CCSParRRule = void 0;
    step.process._CCSParLRule = void 0;
    step.process.setLeft(step.substeps[0].perform());
    return step.process;
  }
};

CCSParRRule = {
  getPossibleSteps: function(parallel) {
    var i, step;
    if (!parallel._CCSParRRule) {
      i = 0;
      parallel._CCSParRRule = (function() {
        var _i, _len, _ref3, _results;
        _ref3 = parallel.getRight().getPossibleSteps().filterActVPSteps();
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          step = _ref3[_i];
          _results.push(new CCSStep(i++, parallel, step.action, this, null, step));
        }
        return _results;
      }).call(this);
    }
    return parallel._CCSParRRule;
  },
  performStep: function(step) {
    step.process._CCSSyncRule = void 0;
    step.process._CCSParRRule = void 0;
    step.process._CCSParLRule = void 0;
    step.process.setRight(step.substeps[0].perform());
    return step.process;
  }
};

CCSSyncRule = {
  filterStepsSyncableWithStep: function(step, steps) {
    var result, s, _i, _len;
    result = [];
    for (_i = 0, _len = steps.length; _i < _len; _i++) {
      s = steps[_i];
      if (s.action.isSyncableWithAction(step.action)) {
        result.push(s);
      }
    }
    return result;
  },
  getPossibleSteps: function(parallel) {
    var c, l, left, r, result, right, _i, _j, _len, _len1, _right;
    if (!parallel._CCSSyncRule) {
      left = parallel.getLeft().getPossibleSteps();
      right = parallel.getRight().getPossibleSteps();
      result = [];
      c = 0;
      for (_i = 0, _len = left.length; _i < _len; _i++) {
        l = left[_i];
        _right = CCSSyncRule.filterStepsSyncableWithStep(l, right);
        for (_j = 0, _len1 = _right.length; _j < _len1; _j++) {
          r = _right[_j];
          result.push(new CCSStep(c++, parallel, new CCSInternalActionCreate(CCSInternalChannel), this, "" + (l.action.isOutputAction() ? l.action.transferDescription() : r.action.transferDescription()), l, r));
        }
      }
      parallel._CCSSyncRule = result;
    }
    return parallel._CCSSyncRule;
  },
  performStep: function(step) {
    var inp, out, prefix;
    step.process._CCSSyncRule = void 0;
    step.process._CCSParRRule = void 0;
    step.process._CCSParLRule = void 0;
    inp = null;
    out = null;
    prefix = step.substeps[0].getLeafProcesses()[0];
    if (prefix.action.supportsValuePassing()) {
      if (prefix.action.isInputAction()) {
        inp = prefix;
        out = step.substeps[1].getLeafProcesses()[0];
      } else {
        out = prefix;
        inp = step.substeps[1].getLeafProcesses()[0];
      }
      inp.action.incommingValue = out.action.expression.evaluate();
    }
    step.process.setLeft(step.substeps[0].perform());
    step.process.setRight(step.substeps[1].perform());
    return step.process;
  }
};

CCSResRule = {
  shouldRestrictChannel: function(chan, restr) {
    if (chan === CCSInternalChannel || chan === CCSExitChannel) {
      return false;
    }
    if (restr.length === 0) {
      return false;
    }
    if (restr[0] === "*") {
      return restr.indexOf(chan) === -1;
    } else {
      return restr.indexOf(chan) !== -1;
    }
  },
  getPossibleSteps: function(restriction) {
    var c, result, step, steps, _i, _len;
    steps = restriction.getProcess().getPossibleSteps().filterActVPPlusSteps();
    result = [];
    c = 0;
    for (_i = 0, _len = steps.length; _i < _len; _i++) {
      step = steps[_i];
      if (!this.shouldRestrictChannel(step.action.channel.name, restriction.restrictedChannels)) {
        result.push(new CCSStep(c++, restriction, step.action, this, null, step));
      }
    }
    return result;
  },
  performStep: function(step) {
    step.process.setProcess(step.substeps[0].perform());
    return step.process;
  }
};

CCSCondRule = {
  getPossibleSteps: function(condition) {
    if (CCSCondRule.DEBUGGER) {
      debugger;
    }
    if (condition.expression.evaluate() === "1") {
      return condition.getProcess().getPossibleSteps().filterActVPPlusSteps();
    } else {
      return [];
    }
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};

CCSExitRule = {
  getPossibleSteps: function(exit) {
    return [new CCSStep(0, exit, new CCSInternalActionCreate(CCSExitChannel), this)];
  },
  performStep: function(step) {
    return new CCSStop();
  }
};

CCSSyncExitRule = {
  getPossibleSteps: function(parallel) {
    var c, filter, l, left, r, result, right, _i, _j, _len, _len1;
    filter = function(step) {
      return step.action.channel.name === CCSExitChannel;
    };
    left = parallel.getLeft().getPossibleSteps().filter(filter);
    right = parallel.getRight().getPossibleSteps().filter(filter);
    c = 0;
    result = [];
    for (_i = 0, _len = left.length; _i < _len; _i++) {
      l = left[_i];
      for (_j = 0, _len1 = right.length; _j < _len1; _j++) {
        r = right[_j];
        result.push(new CCSStep(c++, parallel, CCSInternalActionCreate(CCSExitChannel), this, "" + (l.action.isOutput() ? l.action.transferDescription() : r.action.transferDescription()), l, r));
      }
    }
    return result;
  },
  performStep: function(step) {
    return SyncRule.performStep(step);
  }
};

CCSSeq1Rule = {
  getPossibleSteps: function(sequence) {
    var c, step, _i, _len, _ref3, _results;
    c = 0;
    _ref3 = sequence.getLeft().getPossibleSteps().filterActVPSteps();
    _results = [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      step = _ref3[_i];
      _results.push(new CCSStep(c++, sequence, step.action, this, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    step.process.setLeft(step.substeps[0].perform());
    return step.process;
  }
};

CCSSeq2Rule = {
  getPossibleSteps: function(sequence) {
    var c, filter, result, rho, rhos, _i, _len;
    filter = function(step) {
      return step.action.channel.name === CCSExitChannel;
    };
    rhos = sequence.getLeft().getPossibleSteps().filter(filter);
    result = [];
    c = 0;
    for (_i = 0, _len = rhos.length; _i < _len; _i++) {
      rho = rhos[_i];
      result.push(new CCSStep(c++, sequence, new CCSInternalActionCreate(CCSInternalChannel), this, "" + CCSExitChannel, rho));
    }
    return result;
  },
  performStep: function(step) {
    return step.process.getRight();
  }
};

CCSRecRule = {
  getPossibleSteps: function(application) {
    var c, step, steps, _i, _len, _results;
    steps = application.getProcess().getPossibleSteps();
    c = 0;
    _results = [];
    for (_i = 0, _len = steps.length; _i < _len; _i++) {
      step = steps[_i];
      _results.push(new CCSStep(c++, application, step.action, this, null, step));
    }
    return _results;
  },
  performStep: function(step) {
    return step.substeps[0].perform();
  }
};
