// Generated by CoffeeScript 1.6.2
/*
	Manages multiple versions of process frames. A process frame is the set of all arguments, local variables and temporary containers of a compile unit, also called a process groupable (e.g. a procedure) at a specific time.
	Process frames may exist in multiple versions: One version for each CCS process. Because of restrictions of CCS it is not always possible to compile into a single process. This class helps to manage the fragmentation of code into multiple processes.
	Versions are partially ordered.
*/

/*
	Groupable implements:
	 getProcessName()
*/

var PCCApplicationPlaceholderStackElement, PCCApplicationStackElement, PCCBinaryCCSStackElement, PCCBinaryContainer, PCCBinaryStackElement, PCCBinaryTarget, PCCChoiceStackElement, PCCClass, PCCClassStackElement, PCCCompiler, PCCCompilerStack, PCCComposedContainer, PCCCondition, PCCConditionStackElement, PCCConstantContainer, PCCConstructor, PCCContainer, PCCExitStackElement, PCCField, PCCGlobal, PCCGlobalStackElement, PCCGlobalVariable, PCCGroupable, PCCInputStackElement, PCCInternalReadOnlyField, PCCLocalVariable, PCCOutputStackElement, PCCParallelStackElement, PCCPrefixStackElement, PCCProcedure, PCCProcedureFrame, PCCProcedureStackElement, PCCProcessDefinitionStackElement, PCCProcessFrame, PCCProcessFrameStackElement, PCCProgramController, PCCRestrictionStackElement, PCCScopeStackElement, PCCSequenceStackElement, PCCStackElement, PCCStackResult, PCCStackResultContainer, PCCStopStackElement, PCCSystemProcessStackElement, PCCType, PCCUnaryContainer, PCCUnaryStackElement, PCCVariable, PCCVariableContainer, PCCVariableInfo, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PCCProcessFrame = (function() {
  function PCCProcessFrame(groupable, variables, tempTypes, autoInit) {
    this.groupable = groupable;
    this.variables = variables != null ? variables : [];
    this.tempTypes = tempTypes != null ? tempTypes : [];
    if (autoInit == null) {
      autoInit = true;
    }
    if (autoInit) {
      this._freshInit();
    }
    null;
  }

  PCCProcessFrame.prototype._freshInit = function() {
    var i, v, _i, _len, _ref;

    if (this.groupable.frameCount === void 0) {
      this.groupable.frameCount = 0;
    }
    this.processID = this.groupable.frameCount++;
    this.containerIndex = 0;
    this.usedContainers = [];
    this.varTable = {};
    _ref = this.variables;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      this.varTable[v.getIdentifier()] = this.createContainer(v.getCCSType(), v.getSuggestedContainerName());
    }
    this.protections = (function() {
      var _j, _ref1, _results;

      _results = [];
      for (i = _j = 0, _ref1 = this.tempTypes.length; _j < _ref1; i = _j += 1) {
        _results.push(this.createContainer(this.tempTypes[i], "t" + i));
      }
      return _results;
    }).call(this);
    return this.initialVariableCount = this.variables.length;
  };

  PCCProcessFrame.prototype._argumentsForProcessDefinition = function() {
    var args, v;

    args = (function() {
      var _i, _len, _ref, _results;

      _ref = this.variables;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(this.varTable[v.getIdentifier()]);
      }
      return _results;
    }).call(this);
    return args.concat(this.protections);
  };

  PCCProcessFrame.prototype.emitProcessDefinition = function(compiler) {
    var args;

    args = this._argumentsForProcessDefinition();
    return compiler._silentlyAddProcessDefinition(this._getProcessName(), args);
  };

  PCCProcessFrame.prototype._getProcessName = function() {
    return "" + (this.groupable.getProcessName()) + (this.processID > 0 ? "_" + this.processID : "");
  };

  PCCProcessFrame.prototype._getProcessArgCount = function() {
    return this.initialVariableCount + this.tempTypes.length;
  };

  PCCProcessFrame.prototype._didAlreadyUseContainerWithIdentifier = function(id) {
    var c, _i, _len, _ref;

    _ref = this.usedContainers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (c.identifier === id) {
        return true;
      }
    }
    return false;
  };

  PCCProcessFrame.prototype.createContainer = function(ccsType, wish) {
    var container, id;

    if (typeof wish === "string" && wish.length > 0 && wish.indexOf("f_") !== 0 && !this._didAlreadyUseContainerWithIdentifier(wish)) {
      id = wish;
    } else {
      id = "f_" + (this.containerIndex++);
    }
    container = new PCCVariableContainer(id, ccsType);
    this.usedContainers.push(container);
    return container;
  };

  PCCProcessFrame.prototype.getContainerForVariable = function(identifier) {
    if (this.varTable[identifier] === void 0) {
      throw new Error("Unknown variable!");
    }
    return this.varTable[identifier];
  };

  PCCProcessFrame.prototype.assignContainerToVariable = function(identifier, container) {
    if (this.varTable[identifier] === void 0) {
      throw new Error("Unknown variable!");
    }
    return this.varTable[identifier] = container;
  };

  PCCProcessFrame.prototype.addLocalVariable = function(variable, container) {
    if (!this.varTable[variable.getIdentifier()]) {
      this.variables.push(variable);
    }
    return this.varTable[variable.getIdentifier()] = container;
  };

  PCCProcessFrame.prototype.protectContainer = function(container) {
    return this.protections.push(container);
  };

  PCCProcessFrame.prototype.unprotectContainer = function() {
    return this.protections.pop();
  };

  PCCProcessFrame.prototype.getProtectedContainer = function() {
    if (this.protections.length === 0) {
      throw new Error("No protected containers available");
    }
    return this.protections[this.protections.length - 1];
  };

  PCCProcessFrame.prototype.isContainerLocalVariable = function(container) {
    var c, v, _ref;

    _ref = this.varTable;
    for (v in _ref) {
      c = _ref[v];
      if (container.isEqual(c)) {
        return true;
      }
    }
    return false;
  };

  PCCProcessFrame.prototype.createFollowupFrame = function() {
    return PCCProcessFrame.createFollowupFrameForFrames([this]);
  };

  PCCProcessFrame.prototype._createFollowupFrameAcceptingTempTypes = function(tempTypes) {
    return new PCCProcessFrame(this.groupable, this.variables.slice(0), tempTypes);
  };

  PCCProcessFrame.prototype.createNewScope = function() {
    return this.copy();
  };

  PCCProcessFrame.prototype._checkHierarchyConsistency = function(frame) {
    if (this.parentFrame === frame || this === frame) {
      return;
    }
    while (frame.parentFrame) {
      frame = frame.parentFrame;
      if (frame === this.parentFrame) {
        return;
      }
    }
    throw new Error("Frame must be connected in hierarchy");
  };

  PCCProcessFrame.prototype._argumentsToCallProcessFromFrame = function(frame) {
    var args, i;

    args = (function() {
      var _i, _ref, _results;

      _results = [];
      for (i = _i = 0, _ref = this.initialVariableCount; _i < _ref; i = _i += 1) {
        _results.push(frame.varTable[this.variables[i].getIdentifier()]);
      }
      return _results;
    }).call(this);
    return args.concat(frame.protections.slice(0, this.tempTypes.length));
  };

  PCCProcessFrame.prototype.emitCallProcessFromFrame = function(compiler, frame, appPlaceholder) {
    var args;

    args = this._argumentsToCallProcessFromFrame(frame);
    return this.emitCallProcessWithArgumentContainers(compiler, args, appPlaceholder);
  };

  PCCProcessFrame.prototype.emitCallProcessWithArgumentContainers = function(compiler, containers, appPlaceholder) {
    if (containers.length !== this._getProcessArgCount()) {
      throw new Error("Number of argument containers does not match number of required arguments");
    }
    if (appPlaceholder) {
      return appPlaceholder.set(this._getProcessName(), containers);
    } else {
      return compiler.emitProcessApplication(this._getProcessName(), containers);
    }
  };

  PCCProcessFrame.prototype.copy = function() {
    var res;

    res = new PCCProcessFrame(this.groupable, this.variables.slice(0), this.tempTypes, false);
    this._copyVariablesToCopy(res);
    res.parentFrame = this;
    return res;
  };

  PCCProcessFrame.prototype._copyVariablesToCopy = function(res) {
    var v, _i, _len, _ref;

    res.processID = this.processID;
    res.containerIndex = this.containerIndex;
    res.usedContainers = this.usedContainers.slice(0);
    res.varTable = {};
    _ref = this.variables;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      res.varTable[v.getIdentifier()] = this.varTable[v.getIdentifier()];
    }
    res.protections = this.protections.slice(0);
    return res.initialVariableCount = this.initialVariableCount;
  };

  return PCCProcessFrame;

})();

PCCProcedureFrame = (function(_super) {
  __extends(PCCProcedureFrame, _super);

  function PCCProcedureFrame(procedure, variables, tempTypes, autoInit) {
    if (!variables) {
      variables = procedure["arguments"];
      if (procedure.isClassProcedure()) {
        variables.unshift(new PCCVariableInfo(null, "i", null, true));
      }
      variables.unshift(new PCCVariableInfo(null, "r", null, true));
    }
    PCCProcedureFrame.__super__.constructor.call(this, procedure, variables, tempTypes, autoInit);
  }

  PCCProcedureFrame.prototype.getProcedure = function() {
    return this.groupable;
  };

  /*
  	getContainerForVariable: (identifier) ->
  		if identifier == "i_r" then PCCContainer.RETURN()
  		else if identifier == "i_i" then PCCContainer.INSTANCE()
  		else if identifier == "i_g" then PCCContainer.GUARD()
  		else super
  	
  	assignContainerToVariable: (identifier, container) ->
  		throw new Error("Tried to assign read-only variable!") if identifier == "i_r" or identifier == "i_i" or identifier == "i_g"
  		super
  	
  	addLocalVariable: (variable, container) ->
  		identifier = variable.getName()
  		throw new Error("Tried to add internal read-only variable!") if identifier == "i_r" or identifier == "i_i" or identifier == "i_g"
  		super
  */


  PCCProcedureFrame.prototype._createFollowupFrameAcceptingTempTypes = function(tempTypes) {
    return new PCCProcedureFrame(this.groupable, this.variables.slice(0), tempTypes);
  };

  /*
  	_argumentsToCallProcessFromFrame: (frame) ->
  		args = super
  		#args.unshift(PCCContainer.GUARD()) if @groupable.isMonitorProcedure()
  		args.unshift(PCCContainer.INSTANCE()) if @groupable.isClassProcedure()
  		args.unshift(PCCContainer.RETURN())
  		args
  */


  PCCProcedureFrame.prototype.copy = function() {
    var res;

    res = new PCCProcedureFrame(this.groupable, this.variables.slice(0), this.tempTypes, false);
    this._copyVariablesToCopy(res);
    res.parentFrame = this;
    return res;
  };

  return PCCProcedureFrame;

})(PCCProcessFrame);

PCCProcessFrame.prototype.parentFrame = null;

PCCProcessFrame.prototype.mark = function(m) {
  if (!this.marked) {
    this.marked = [];
  }
  return this.marked.push(m);
};

PCCProcessFrame.checkTempTypesEquality = function(types1, types2) {
  var i, _i, _ref;

  if (types1.length !== types2.length) {
    return false;
  }
  for (i = _i = 0, _ref = types1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (!types1[i].isEqual(types2[i])) {
      return false;
    }
  }
  return true;
};

PCCProcessFrame.checkFramesForConsistency = function(frames) {
  var groupable, i, tempTypes, _i, _ref;

  groupable = frames[0].groupable;
  tempTypes = frames[0].tempTypes;
  for (i = _i = 1, _ref = frames.length; _i < _ref; i = _i += 1) {
    if (frames[i].groupable !== groupable || !PCCProcessFrame.checkTempTypesEquality(tempTypes, frames[i].tempTypes)) {
      throw new Error("Inconsistent process frames");
    }
  }
  return null;
};

PCCProcessFrame.findClosesAncestorForFrames = function(frames) {
  var closestAncestor, currentFrames, f, i, markedFrames, _i, _j, _len, _ref;

  closestAncestor = null;
  markedFrames = [];
  currentFrames = frames.concat([]);
  while (closestAncestor === null) {
    for (i = _i = 0, _ref = frames.length; _i < _ref; i = _i += 1) {
      if (currentFrames[i] !== null) {
        currentFrames[i].mark(frames[i]);
        markedFrames.push(currentFrames[i]);
        if (currentFrames[i].marked.length === frames.length) {
          closestAncestor = currentFrames[i];
          break;
        }
        currentFrames[i] = currentFrames[i].parentFrame;
      }
    }
  }
  for (_j = 0, _len = markedFrames.length; _j < _len; _j++) {
    f = markedFrames[_j];
    f.marked = null;
  }
  return closestAncestor;
};

PCCProcessFrame.createFollowupFrameForFrames = function(frames) {
  var c, closestAncestor, result;

  PCCProcessFrame.checkFramesForConsistency(frames);
  closestAncestor = PCCProcessFrame.findClosesAncestorForFrames(frames);
  result = closestAncestor._createFollowupFrameAcceptingTempTypes((function() {
    var _i, _len, _ref, _results;

    _ref = frames[0].protections;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.ccsType);
    }
    return _results;
  })());
  result.parentFrame = closestAncestor;
  return result;
};

PCCProcessFrame.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
  var c;

  c = variable.compileDefaultValue(compiler);
  compiler.getProcessFrame().addLocalVariable(variable, c);
  return variable;
};

PCCProcessFrame.prototype.compilerGetVariable = function(compiler, identifier) {
  var v, _i, _len, _ref;

  _ref = this.variables;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    v = _ref[_i];
    if (v.getIdentifier() === identifier) {
      return new PCCLocalVariable(v.node, v.getName(), v.type, v.isInternal);
    }
  }
  return null;
};

PCCProcessFrame.prototype.compilerGetProcedure = function(compiler, identifier, instanceContainer) {
  return null;
};

PCCProcedureFrame.prototype.compilerGetProcedure = function(compiler, identifier, instanceContainer) {
  var p;

  p = this.getProcedure();
  if (p.getName() === identifier) {
    return p;
  } else {
    return p.getProcedureWithName(identifier);
  }
};

/*
class PCCContainerInfo
	constructor: (@payload, @isLocalVariable) ->


class PCCContainerInfoArray
	constructor: (temporaryItems=[]) -> @infos = (new PCCContainerInfo(c, false) for c in temporaryItems)
	copy: ->
		res = new PCCContainerProtectionArray()
		res.infos = @infos[..]
		res
	getCount: ->
		res = 0
		++res for ci in @infos
		res
	
	# Protecting Containers
	protectContainer: (container, isLocalVariable) ->
		@protections.push(new PCCContainerInfo(container, isLocalVariable))
	unprotectContainer: -> @infos.pop().container
	getContainer: ->
		throw new Error("getProtection: Nothing protected at the moment!") if @infos.length == 0
		@infos[@infos.length-1].payload
	getTemporaryContainers: ->
		res = []
		(res.push(ci.payload) if not ci.isLocalVariable) for ci in @infos
		res
	
	getCCSTypes: ->
		res = new PCCContainerInfoArray()
		res.infos = (new PCCContainerInfo(ci.payload.ccsType, ci.isLocalVariable) for ci in @infos)
		res
		
	getTemporaryTypes: ->
		res = []
		return res if infos.length == 0
		if @infos[0].payload instanceof PCCContainer
			(res.push(ci.payload.ccsType) if not cp.isLocalVariable) for ci in @infos
		else if infos[0].payload instanceof PCCType
			(res.push(ci.payload) if not cp.isLocalVariable) for ci in @infos
		else
			throw new Error("getTemporaryTypes not applicable on payload!")
		res
*/


PCCGroupable = (function() {
  function PCCGroupable(processName) {
    this.processName = processName;
  }

  PCCGroupable.prototype.getProcessName = function() {
    return this.processName;
  };

  return PCCGroupable;

})();

/*

{version: "1.0", tree: (new PCProgram((new PCMonitor("M", (new PCConditionDecl("c", (new PCRelationalExpression((new PCLiteralExpression(parseInt(3))), "<", (new PCLiteralExpression(parseInt(4))))))), (new PCConditionDecl("c2", (new PCLiteralExpression(true)))), (new PCConditionDecl("c3", (new PCLiteralExpression(false)))), (new PCProcedureDecl((new PCSimpleType(PCSimpleType.VOID)), "f", (new PCStmtBlock((new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.WAIT, (new PCIdentifierExpression("c")))))), (new PCStatement((new PCPrintStmt((new PCLiteralExpression("condition fulfilled!")))))))))), (new PCProcedureDecl((new PCSimpleType(PCSimpleType.VOID)), "g", (new PCStmtBlock((new PCStatement((new PCPrintStmt((new PCLiteralExpression("Before signal")))))), (new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.SIGNAL, (new PCIdentifierExpression("c")))))), (new PCStatement((new PCPrintStmt((new PCLiteralExpression("Behind signal")))))), (new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.SIGNAL_ALL)))), (new PCStatement((new PCPrintStmt((new PCLiteralExpression("Behind signallAll")))))))))))), (new PCDeclStmt((new PCSimpleType(PCSimpleType.MUTEX)), (new PCVariableDeclarator("guard", null)))), (new PCMainAgent((new PCStmtBlock((new PCDeclStmt((new PCClassType("M")), (new PCVariableDeclarator("m", null)))), (new PCDeclStmt((new PCSimpleType(PCSimpleType.AGENT)), (new PCVariableDeclarator("a", (new PCVariableInitializer(false, (new PCStartExpression((new PCProcedureCall("agent1", (new PCIdentifierExpression("m")))))))))))), (new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.LOCK, (new PCIdentifierExpression("guard")))))), (new PCStatement((new PCStmtExpression((new PCClassCall((new PCIdentifierExpression("m")), (new PCProcedureCall("f")))))))), (new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.UNLOCK, (new PCIdentifierExpression("guard")))))), (new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.JOIN, (new PCIdentifierExpression("a")))))))))), (new PCProcedureDecl((new PCSimpleType(PCSimpleType.VOID)), "agent1", (new PCStmtBlock((new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.LOCK, (new PCIdentifierExpression("guard")))))), (new PCStatement((new PCStmtExpression((new PCClassCall((new PCIdentifierExpression("m")), (new PCProcedureCall("g")))))))), (new PCStatement((new PCPrimitiveStmt(PCPrimitiveStmt.UNLOCK, (new PCIdentifierExpression("guard")))))))), (new PCFormalParameter((new PCClassType("M")), "m"))))))}

	
{version: "1.0", tree: (new PCProgram((new PCDeclStmt((new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("x", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(41))))))))), (new PCMainAgent((new PCStmtBlock((new PCStatement((new PCPrintStmt((new PCAdditiveExpression((new PCIdentifierExpression("x")), "+", (new PCLiteralExpression(parseInt(1)))))))))))))))}


{version: "1.0", tree: (new PCProgram((new PCDeclStmt((new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("n", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(0))))))))), (new PCProcedureDecl((new PCSimpleType(PCSimpleType.VOID)), "count", (new PCStmtBlock((new PCStatement((new PCForStmt((new PCStatement((new PCStmtBlock((new PCStatement((new PCStmtExpression((new PCPostfixExpression((new PCAssignDestination("n")), "++")))))), (new PCStatement((new PCPrintStmt((new PCLiteralExpression("Der neue Wert von n ist ")), (new PCIdentifierExpression("n")))))))))), (new PCForInit((new PCDecl((new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("i", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(0))))))))))), (new PCRelationalExpression((new PCIdentifierExpression("i")), "<", (new PCLiteralExpression(parseInt(10))))), (new PCStmtExpression((new PCPostfixExpression((new PCAssignDestination("i")), "++")))))))))))), (new PCMainAgent((new PCStmtBlock((new PCDeclStmt((new PCSimpleType(PCSimpleType.AGENT)), (new PCVariableDeclarator("a1", (new PCVariableInitializer(false, (new PCStartExpression((new PCProcedureCall("count")))))))))), (new PCDeclStmt((new PCSimpleType(PCSimpleType.AGENT)), (new PCVariableDeclarator("a2", (new PCVariableInitializer(false, (new PCStartExpression((new PCProcedureCall("count")))))))))), (new PCStatement((new PCPrintStmt((new PCLiteralExpression("Main agent ist terminiert! n = ")), (new PCIdentifierExpression("n"))))))))))))}



{version: "1.0", tree: (new PCProgram((new PCDeclStmt((new PCChannelType(PCSimpleType.INT, 5)), (new PCVariableDeclarator("c", null)))), (new PCProcedureDecl((new PCSimpleType(PCSimpleType.VOID)), "f", (new PCStmtBlock((new PCStatement((new PCForStmt((new PCStatement((new PCStmtExpression((new PCSendExpression((new PCIdentifierExpression("cc")), (new PCIdentifierExpression("i")))))))), (new PCForInit((new PCDecl((new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("i", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(0))))))))))), (new PCRelationalExpression((new PCIdentifierExpression("i")), "<", (new PCLiteralExpression(parseInt(5))))), (new PCStmtExpression((new PCPostfixExpression((new PCAssignDestination("i")), "++")))))))))), (new PCFormalParameter((new PCChannelType(PCSimpleType.INT, PCChannelType.CAPACITY_UNKNOWN)), "cc")))), (new PCMainAgent((new PCStmtBlock((new PCStatement((new PCStmtExpression((new PCStartExpression((new PCProcedureCall("f", (new PCIdentifierExpression("c")))))))))), (new PCStatement((new PCForStmt((new PCStatement((new PCPrintStmt((new PCReceiveExpression((new PCIdentifierExpression("c")))))))), (new PCForInit((new PCDecl((new PCSimpleType(PCSimpleType.INT)), (new PCVariableDeclarator("i", (new PCVariableInitializer(false, (new PCLiteralExpression(parseInt(0))))))))))), (new PCRelationalExpression((new PCIdentifierExpression("i")), "<", (new PCLiteralExpression(parseInt(5))))), (new PCStmtExpression((new PCPostfixExpression((new PCAssignDestination("i")), "++"))))))))))))))}
*/


/*
	PCCProgramController manages all variables, classes, procedures and the relationships between each other that occur in a PseuCo program.
*/


PCCGlobal = (function(_super) {
  __extends(PCCGlobal, _super);

  function PCCGlobal(program) {
    PCCGlobal.__super__.constructor.call(this, program, "");
  }

  PCCGlobal.prototype.getVariableClass = function() {
    return PCCGlobalVariable;
  };

  PCCGlobal.prototype.compilerGetVariable = function(compiler, identifier) {
    return this.getVariableWithName(identifier);
  };

  PCCGlobal.prototype.compilerGetProcedure = function(compiler, identifier) {
    return this.getProcedureWithName(identifier);
  };

  PCCGlobal.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
    variable = this.getVariableWithName(variable.getName());
    if (variable === void 0) {
      throw new Error("Unexpected new identifier found!");
    }
    variable.emitConstructor(compiler);
    return variable;
  };

  return PCCGlobal;

})(PCEnvironmentNode);

PCCClass = (function(_super) {
  __extends(PCCClass, _super);

  function PCCClass() {
    PCCClass.__super__.constructor.apply(this, arguments);
    this.addChild(new PCCInternalReadOnlyField(null, "guard", new PCTType(PCTType.MUTEX), true));
  }

  PCCClass.prototype.getAllConditions = function() {
    var n, result, v, _ref;

    result = [];
    _ref = this.variables;
    for (n in _ref) {
      v = _ref[n];
      if (v.type && v.type.kind === PCTType.CONDITION) {
        result.push(v);
      }
    }
    return result;
  };

  PCCClass.prototype.getVariableClass = function() {
    return PCCField;
  };

  PCCClass.prototype.compilerGetVariable = function(compiler, identifier) {
    return this.getVariableWithName(identifier);
  };

  PCCClass.prototype.compilerGetProcedure = function(compiler, identifier) {
    return this.getProcedureWithName(identifier);
  };

  PCCClass.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable) {
    return this.getVariableWithName(variable.getName());
  };

  PCCClass.prototype.emitEnvironment = function(compiler) {
    var control, i, instance, n, names, v, variables, _i, _ref;

    variables = (function() {
      var _ref, _results;

      _ref = this.variables;
      _results = [];
      for (n in _ref) {
        v = _ref[n];
        _results.push(v);
      }
      return _results;
    }).call(this);
    instance = new PCCVariableInfo(null, "i", this.type, true);
    variables.unshift(instance);
    compiler.beginProcessGroup(new PCCGroupable(this.getEnvProcessName()), variables);
    variables = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(compiler.getVariableWithName(v.getIdentifier()));
      }
      return _results;
    })();
    names = (function() {
      var _results;

      _results = [];
      for (n in this.variables) {
        _results.push(n);
      }
      return _results;
    }).call(this);
    for (i = _i = 0, _ref = names.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      control = compiler.emitChoice();
      this.variables[names[i]].emitAccessors(compiler, variables, variables[0].getContainer(compiler));
      control.setBranchFinished();
    }
    this.variables[names[names.length - 1]].emitAccessors(compiler, variables, variables[0].getContainer(compiler));
    return compiler.endProcessGroup();
  };

  PCCClass.prototype.emitConstructor = function(compiler) {
    var hasVariables, n;

    hasVariables = false;
    for (n in this.variables) {
      hasVariables = true;
      break;
    }
    if (!hasVariables) {
      return;
    }
    this.emitEnvironment(compiler);
    PCCConstructor.emitConstructor(compiler, this);
    return compiler.emitSystemProcessApplication(this.getProcessName(), [new PCCConstantContainer(1)]);
  };

  PCCClass.prototype.constructorGetName = function() {
    return this.getEnvProcessName();
  };

  PCCClass.prototype.constructorGetArguments = function() {
    return [new PCCVariableInfo(null, "next_i", this.type, true)];
  };

  PCCClass.prototype.constructorProtectEnvironmentArguments = function(cons, compiler, variables) {
    var c, instance, n, res, v, _ref;

    instance = variables[0];
    compiler.emitOutput("class_" + (this.getName()) + "_create", null, instance.getContainer(compiler));
    compiler.protectContainer(instance.getContainer(compiler));
    res = 1;
    _ref = this.variables;
    for (n in _ref) {
      v = _ref[n];
      c = v.compileDefaultValue(compiler);
      compiler.protectContainer(c);
      res++;
    }
    return res;
  };

  PCCClass.prototype.constructorShouldCallRecursively = function() {
    return true;
  };

  PCCClass.prototype.constructorUpdateVariablesForRecursiveCall = function(cons, compiler, entry, variables) {
    var instance, new_i;

    instance = variables[0];
    new_i = new PCCBinaryContainer(instance.getContainer(compiler), new PCCConstantContainer(1), "+");
    return instance.setContainer(compiler, new_i);
  };

  PCCClass.prototype.getProcessName = function() {
    return "Env_class_" + (this.getName()) + "_cons";
  };

  PCCClass.prototype.getEnvProcessName = function() {
    return "Env_class_" + (this.getName());
  };

  return PCCClass;

})(PCClass);

PCCProcedure = (function(_super) {
  __extends(PCCProcedure, _super);

  function PCCProcedure() {
    _ref = PCCProcedure.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PCCProcedure.prototype.getProcessName = function() {
    return "Proc" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getAgentStarterChannel = function() {
    return "start" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getAgentProcessName = function() {
    return "Agent" + (this.getComposedLabel());
  };

  PCCProcedure.prototype.getVariableClass = function() {
    return PCCLocalVariable;
  };

  PCCProcedure.prototype.getAllArgumentContainers = function(compiler, explicitArgumentContainers, instanceContainer) {
    var argumentContainers;

    argumentContainers = explicitArgumentContainers.slice(0);
    if (this.isClassProcedure()) {
      if (!instanceContainer) {
        instanceContainer = compiler.getVariableWithName("i", null, true).getContainer(compiler);
      }
      argumentContainers.unshift(instanceContainer);
    } else {
      if (instanceContainer) {
        throw new Error("Illegal instance value");
      }
    }
    argumentContainers.unshift(compiler.getVariableWithName("r", null, true).getContainer(compiler));
    return argumentContainers;
  };

  PCCProcedure.prototype.getImplicitAndExplicitArgumentCount = function() {
    var res;

    res = this["arguments"].length + 1;
    if (this.isClassProcedure()) {
      res++;
    }
    return res;
  };

  PCCProcedure.prototype.emitAgentConstructor = function(compiler) {
    var a, args, control1, control2, control3, definitionName, i, j, _i, _ref1;

    definitionName = this.getAgentProcessName();
    compiler.beginProcessDefinition(definitionName, []);
    i = new PCCVariableContainer("i", PCCType.INT);
    compiler.emitInput("agent_new", null, i);
    compiler.emitOutput(this.getAgentStarterChannel(), null, i);
    args = [];
    for (j = _i = 0, _ref1 = this.getImplicitAndExplicitArgumentCount(); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; j = 0 <= _ref1 ? ++_i : --_i) {
      a = new PCCVariableContainer("a" + j, PCCType.VOID);
      compiler.emitInput("start_set_arg", i, a);
      args.push(a);
    }
    control1 = compiler.emitParallel();
    compiler.emitProcessApplication(definitionName, []);
    control1.setBranchFinished();
    control2 = compiler.emitParallel();
    control3 = compiler.emitSequence();
    compiler.emitProcessApplication(this.getProcessName(), args);
    control3.setBranchFinished();
    compiler.emitOutput("agent_terminate", i, null);
    compiler.emitStop();
    control3.setBranchFinished();
    control2.setBranchFinished();
    compiler.emitProcessApplication("AgentJoiner", [i, new PCCConstantContainer(0)]);
    control2.setBranchFinished();
    control1.setBranchFinished();
    return compiler.endProcessDefinition();
  };

  PCCProcedure.prototype.emitExit = function(compiler) {
    var guard;

    if (this.isMonitorProcedure()) {
      guard = compiler.getVariableWithName("guard", null, true);
      compiler.emitOutput("unlock", guard.getContainer(compiler));
    }
    return compiler.emitExit();
  };

  return PCCProcedure;

})(PCProcedure);

PCCType = (function() {
  function PCCType(_type, _className) {
    this._type = _type;
    this._className = _className;
    if (!this._type && this._className) {
      this._type = 1;
    }
  }

  PCCType.prototype.isVoid = function() {
    return this._type === -1;
  };

  PCCType.prototype.isBool = function() {
    return this._type === 0;
  };

  PCCType.prototype.isInt = function() {
    return this._type === 1;
  };

  PCCType.prototype.isString = function() {
    return this._type === 2;
  };

  PCCType.prototype.isArray = function() {
    return this._type instanceof PCCType;
  };

  PCCType.prototype.isClass = function() {
    if (this._className) {
      return true;
    } else {
      return false;
    }
  };

  PCCType.prototype.getClassName = function() {
    if (!this._className) {
      throw new Error("Can't get class name for non-class type!");
    }
    return this._className;
  };

  PCCType.prototype.isEqual = function(type) {
    if (this.isArray()) {
      return type.isArray() && this._type.isEqual(type._type);
    } else {
      return this._type === type._type;
    }
  };

  PCCType.prototype.getSubtype = function() {
    if (!this.isArray()) {
      throw new Error("Cannot get subtype for non-array type!");
    }
    return this._type._type;
  };

  PCCType.prototype.getDefaultContainer = function() {
    if (this.isArray() || this.isClass()) {
      return new PCCConstantContainer(0);
    }
    return new PCCConstantContainer((function() {
      switch (this._type) {
        case 0:
          return false;
        case 1:
          return 0;
        case 2:
          return "";
        default:
          throw new Error("Void does not have a default value");
      }
    }).call(this));
  };

  return PCCType;

})();

PCCType.VOID = new PCCType(-1);

PCCType.BOOL = new PCCType(0);

PCCType.INT = new PCCType(1);

PCCType.STRING = new PCCType(2);

PCTType.prototype.getCCSType = function() {
  switch (this.kind) {
    case PCTType.INT:
      return PCCType.INT;
    case PCTType.BOOL:
      return PCCType.BOOL;
    case PCTType.STRING:
      return PCCType.STRING;
    case PCTType.CHANNEL:
      throw new Error("Unexpected type kind!");
      break;
    case PCTType.ARRAY:
      throw new Error("Unexpected type kind!");
      break;
    case PCTType.MONITOR:
      return PCCType.INT;
    case PCTType.STRUCTURE:
      return PCCType.INT;
    case PCTType.MUTEX:
      return PCCType.INT;
    case PCTType.CONDITION:
      return PCCType.INT;
    case PCTType.PROCEDURE:
      throw new Error("Unexpected type kind!");
      break;
    case PCTType.TYPE:
      throw new Error("Unexpected type kind!");
      break;
    case PCTType.MAINAGENT:
      throw new Error("Unexpected type kind!");
      break;
    case PCTType.AGENT:
      return PCCType.INT;
    case PCTType.WILDCARD:
      throw new Error("Unexpected type kind!");
      break;
    default:
      return PCCType.VOID;
  }
};

PCTArrayType.prototype.getCCSType = function() {
  return new PCCType(this.elementsType.getCCSType());
};

PCTChannelType.prototype.getCCSType = function() {
  return new PCCType(this.channelledType.getCCSType());
};

PCTProcedureType.prototype.getCCSType = function() {
  return this.returnType.getCCSType();
};

PCTProcedureType.prototype.getCCSArgumentTypes = function() {
  var t, _i, _len, _ref1, _results;

  _ref1 = this.argumentTypes;
  _results = [];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    t = _ref1[_i];
    _results.push(t.getCCSType());
  }
  return _results;
};

/*
PCTArrayType::fulfillAssignment = (compiler, container) ->
	result = compiler.getFreshContainer(container.ccsType)
	compiler.emitInput("array_copy", container, result)
	result
*/


PCTArrayType.prototype.createContainer = function(compiler, containers) {
  var c, i, result, _i, _j, _len, _ref1, _ref2;

  if (containers == null) {
    containers = [];
  }
  result = compiler.getFreshContainer(this.getCCSType());
  compiler.emitInput("array" + this.capacity + "_create", null, result);
  compiler.emitOutput("array_setDefault", result, this.elementsType.getCCSType().getDefaultContainer());
  if (this.elementsType.requiresCustomDefaultContainer()) {
    for (i = _i = _ref1 = containers.length, _ref2 = this.capacity; _i < _ref2; i = _i += 1) {
      containers.push(this.elementsType.createContainer(compiler));
    }
  }
  for (i = _j = 0, _len = containers.length; _j < _len; i = ++_j) {
    c = containers[i];
    compiler.emitOutput("array_access", result, new PCCConstantContainer(i));
    compiler.emitOutput("array_set", result, c);
  }
  return result;
};

PCTType.prototype.requiresCustomDefaultContainer = function() {
  return this.kind !== PCTType.INT && this.kind !== PCTType.BOOL && this.kind !== PCTType.STRING;
};

PCTType.prototype.createContainer = function(compiler, container) {
  var result;

  if (container) {
    return container;
  }
  if (this.kind === PCTType.AGENT) {
    throw new Error("No default value for agents available");
  }
  if (this.kind === PCTType.VOID) {
    throw new Error("No default value for void available");
  }
  if (this.kind === PCTType.MUTEX) {
    result = compiler.getFreshContainer(PCCType.INT);
    compiler.emitInput("mutex_create", null, result);
    return result;
  } else if (this.kind === PCTType.STRING) {
    return new PCCConstantContainer("");
  } else {
    return new PCCConstantContainer(0);
  }
};

PCTChannelType.prototype.createContainer = function(compiler, container) {
  var buffered, channel, res;

  if (container) {
    return container;
  }
  res = compiler.getFreshContainer(this.getCCSType());
  buffered = this.capacity !== PCChannelType.CAPACITY_UNKNOWN && this.capacity !== 0;
  channel = "channel" + (buffered ? this.capacity : "") + "_create";
  compiler.emitInput(channel, null, res);
  if (buffered) {
    compiler.emitOutput("channel_setDefault", res, this.channelledType.getCCSType().getDefaultContainer());
  }
  return res;
};

PCTClassType.prototype.createContainer = function(compiler, container) {
  var result;

  if (container) {
    return container;
  }
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput("class_" + this.identifier + "_create", null, result);
  return result;
};

PCCVariableInfo = (function(_super) {
  __extends(PCCVariableInfo, _super);

  function PCCVariableInfo(node, name, type, isInternal) {
    this.isInternal = isInternal != null ? isInternal : false;
    PCCVariableInfo.__super__.constructor.call(this, node, name, type);
  }

  PCCVariableInfo.prototype.getIdentifier = function() {
    return "" + (this.isInternal ? "#" : "") + (this.getName());
  };

  PCCVariableInfo.prototype.getSuggestedContainerName = function() {
    return this.getName() + (this.isInternal ? "H" : "L");
  };

  return PCCVariableInfo;

})(PCVariable);

PCCVariableInfo.getNameForInternalVariableWithName = function(name) {
  return "#" + name;
};

PCVariable.prototype.getSuggestedContainerName = function() {
  return this.getName() + "L";
};

PCVariable.prototype.getCCSType = function() {
  return this.type.getCCSType();
};

PCVariable.prototype.compileDefaultValue = function(compiler) {
  if (this.node) {
    return this.node.compileDefaultValue(compiler);
  } else {
    return this.type.createContainer(compiler);
  }
};

PCCVariableInfo.prototype.getCCSType = function() {
  if (this.type || !this.isInternal) {
    return PCCVariableInfo.__super__.getCCSType.apply(this, arguments);
  } else {
    return PCCType.INT;
  }
};

PCCVariable = (function(_super) {
  __extends(PCCVariable, _super);

  function PCCVariable() {
    _ref1 = PCCVariable.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  PCCVariable.prototype.getContainer = function(compiler) {
    throw new Error("Not implemented!");
  };

  PCCVariable.prototype.setContainer = function(compiler, container) {
    throw new Error("Not implemented");
  };

  return PCCVariable;

})(PCCVariableInfo);

PCCGlobalVariable = (function(_super) {
  __extends(PCCGlobalVariable, _super);

  function PCCGlobalVariable() {
    _ref2 = PCCGlobalVariable.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  PCCGlobalVariable.prototype.accessorChannel = function(set) {
    return "env_global_" + (set ? "set" : "get") + "_" + (this.getName());
  };

  PCCGlobalVariable.prototype.getContainer = function(compiler) {
    var result;

    result = compiler.getFreshContainer(this.type.getCCSType());
    compiler.emitInput(this.accessorChannel(false), null, result);
    return result;
  };

  PCCGlobalVariable.prototype.setContainer = function(compiler, container) {
    compiler.emitOutput(this.accessorChannel(true), null, container);
    return null;
  };

  PCCGlobalVariable.prototype.emitAccessors = function(compiler, variables, instance) {
    var c, containers, control, local, v;

    if (instance == null) {
      instance = null;
    }
    local = compiler.getVariableWithName(this.getIdentifier());
    containers = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(v.getContainer(compiler));
      }
      return _results;
    })();
    control = compiler.emitChoice();
    c = local.getContainer(compiler);
    compiler.emitOutput(this.accessorChannel(false), instance, c);
    compiler.emitProcessApplication(this.getEnvProcessName(), containers);
    control.setBranchFinished();
    compiler.emitInput(this.accessorChannel(true), instance, c);
    compiler.emitProcessApplication(this.getEnvProcessName(), containers);
    return control.setBranchFinished();
  };

  PCCGlobalVariable.prototype.emitConstructor = function(compiler) {
    var container;

    compiler.beginProcessGroup(new PCCGroupable(this.getEnvProcessName()), [this]);
    this.emitAccessors(compiler, [compiler.getVariableWithName(this.getName())]);
    compiler.endProcessGroup();
    compiler.beginProcessGroup(this);
    container = this.compileDefaultValue(compiler);
    compiler.emitProcessApplication(this.getEnvProcessName(), [container]);
    compiler.endProcessGroup();
    return compiler.emitSystemProcessApplication(this.getProcessName(), []);
  };

  PCCGlobalVariable.prototype.getProcessName = function() {
    return "Env_global_" + (this.getName()) + "_cons";
  };

  PCCGlobalVariable.prototype.getEnvProcessName = function() {
    return "Env_global_" + (this.getName());
  };

  return PCCGlobalVariable;

})(PCCVariable);

PCCField = (function(_super) {
  __extends(PCCField, _super);

  function PCCField() {
    _ref3 = PCCField.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  PCCField.prototype.accessorChannel = function(set) {
    return "env_class_" + (this.parent.getName()) + "_" + (set ? "set" : "get") + "_" + (this.getName());
  };

  PCCField.prototype.getContainer = function(compiler) {
    var result;

    if (this.getIdentifier() === "#guard") {
      result = compiler.getFreshContainer(PCCType.INT);
      compiler.emitInput("env_class_get_guard", compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    } else {
      result = compiler.getFreshContainer(this.type.getCCSType());
      compiler.emitInput(this.accessorChannel(false), compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    }
    return result;
  };

  PCCField.prototype.setContainer = function(compiler, container) {
    compiler.emitOutput(this.accessorChannel(true), compiler.getVariableWithName("i", null, true).getContainer(compiler), container);
    return null;
  };

  PCCField.prototype.getEnvProcessName = function() {
    return "Env_class_" + (this.parent.getName());
  };

  return PCCField;

})(PCCGlobalVariable);

PCCInternalReadOnlyField = (function(_super) {
  __extends(PCCInternalReadOnlyField, _super);

  function PCCInternalReadOnlyField() {
    _ref4 = PCCInternalReadOnlyField.__super__.constructor.apply(this, arguments);
    return _ref4;
  }

  PCCInternalReadOnlyField.prototype.emitAccessors = function(compiler, variables, instance) {
    var c, containers, local, v;

    local = compiler.getVariableWithName(this.getIdentifier());
    containers = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(v.getContainer(compiler));
      }
      return _results;
    })();
    c = local.getContainer(compiler);
    compiler.emitOutput("env_class_guard", instance, c);
    return compiler.emitProcessApplication(this.getEnvProcessName(), containers);
  };

  PCCInternalReadOnlyField.prototype.getContainer = function(compiler) {
    var result;

    result = compiler.getFreshContainer(PCCType.INT);
    compiler.emitInput("env_class_guard", compiler.getVariableWithName("i", null, true).getContainer(compiler), result);
    return result;
  };

  PCCInternalReadOnlyField.prototype.setContainer = function() {
    throw new Error("Setting container for read only variable!");
  };

  return PCCInternalReadOnlyField;

})(PCCField);

PCCCondition = (function(_super) {
  __extends(PCCCondition, _super);

  function PCCCondition(name, expressionNode) {
    this.expressionNode = expressionNode;
    PCCCondition.__super__.constructor.call(this, name, new PCTType(PCTType.CONDITION));
  }

  return PCCCondition;

})(PCCField);

PCCLocalVariable = (function(_super) {
  __extends(PCCLocalVariable, _super);

  function PCCLocalVariable() {
    _ref5 = PCCLocalVariable.__super__.constructor.apply(this, arguments);
    return _ref5;
  }

  PCCLocalVariable.prototype.getContainer = function(compiler) {
    return compiler.getProcessFrame().getContainerForVariable(this.getIdentifier());
  };

  PCCLocalVariable.prototype.setContainer = function(compiler, container) {
    return compiler.getProcessFrame().assignContainerToVariable(this.getIdentifier(), container);
  };

  return PCCLocalVariable;

})(PCCVariable);

PCCProgramController = (function(_super) {
  __extends(PCCProgramController, _super);

  function PCCProgramController() {
    PCCProgramController.__super__.constructor.apply(this, arguments);
    this.root = new PCCGlobal();
    this.agents = {};
    this._envStack = this.root;
  }

  PCCProgramController.prototype.processNewClass = function(node, classType) {
    var tnode;

    tnode = new PCCClass(node, classType);
    return this._processNewClass(tnode);
  };

  PCCProgramController.prototype.beginNewProcedure = function(node, procedureName, returnType, args) {
    var tnode;

    tnode = new PCCProcedure(node, procedureName, returnType, args);
    return this._beginNewProcedure(tnode);
  };

  PCCProgramController.prototype.processNewVariable = function(variable) {
    var tnode, varClass;

    varClass = this._envStack.getVariableClass();
    tnode = new varClass(variable.node, variable.getName(), variable.type);
    return this._processNewVariable(tnode);
  };

  PCCProgramController.prototype.processProcedureAsAgent = function(procedure) {
    return this.agents[procedure.getName()] = procedure;
  };

  PCCProgramController.prototype.getAgents = function() {
    var p, proc, res;

    res = [];
    for (p in this.agents) {
      proc = this.agents[p];
      if (proc instanceof PCProcedure) {
        res.push(proc);
      }
    }
    return res;
  };

  PCCProgramController.prototype.getUsedTypes = function() {
    var res;

    res = {
      arrays: {},
      channels: {}
    };
    this.root.getUsedTypes(res);
    return res;
  };

  return PCCProgramController;

})(PCEnvironmentController);

PCEnvironmentNode.prototype.getUsedTypes = function(res) {
  var c, _i, _len, _ref6;

  _ref6 = this.children;
  for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
    c = _ref6[_i];
    c.getUsedTypes(res);
  }
  return null;
};

PCVariable.prototype.getUsedTypes = function(res) {
  return this.type.getUsedTypes(res);
};

PCTType.prototype.getUsedTypes = function() {
  return null;
};

PCTArrayType.prototype.getUsedTypes = function(res) {
  res.arrays[this.capacity] = true;
  this.elementsType.getUsedTypes(res);
  return null;
};

PCTChannelType.prototype.getUsedTypes = function(res) {
  res.channels[this.getApplicableCapacity()] = true;
  return null;
};

PCNode.prototype.collectAgents = function(env) {
  var c, _i, _len, _ref6, _results;

  _ref6 = this.children;
  _results = [];
  for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
    c = _ref6[_i];
    _results.push(c.collectAgents(env));
  }
  return _results;
};

PCMonitor.prototype.collectAgents = function(env) {
  env.beginClass(this.name);
  PCMonitor.__super__.collectAgents.apply(this, arguments);
  return env.endClass();
};

PCStruct.prototype.collectAgents = function(env) {
  env.beginClass(this.name);
  PCStruct.__super__.collectAgents.apply(this, arguments);
  return env.endClass();
};

PCProcedure.prototype.collectAgents = function(env) {
  env.beginProcedure(this.name);
  PCProcedure.__super__.collectAgents.apply(this, arguments);
  return env.endProcedure();
};

PCStartExpression.prototype.collectAgents = function(env) {
  return env.processProcedureAsAgent(this.children[0].getProcedure(env));
};

/*
	The central coordination class for the compile process of PseuCo to CCS.
	You start the compilation process by creating a new PCCCompiler object with the node of your PseuCo tree and call compile() on it. You'll get a CCS tree on success
*/


PCCCompiler = (function() {
  function PCCCompiler(program) {
    this.program = program;
    this.controller = null;
    this.stack = null;
    this.groupElements = [];
    this.controller = new PCCProgramController(this.program);
    this.systemProcesses = [];
  }

  PCCCompiler.prototype.compile = function() {
    var cls, global, n, p, usedTypes, _i, _j, _len, _len1, _ref6, _ref7;

    this.program.collectClasses(this.controller);
    this.program.collectEnvironment(this.controller);
    this.program.collectAgents(this.controller);
    global = new PCCGlobalStackElement(this.controller.getGlobal());
    this.stack = new PCCCompilerStack(global);
    usedTypes = this.controller.getUsedTypes();
    this.compileReturn();
    this.compileMutex();
    this.compileWaitRoom();
    this.compileArrayManager();
    for (n in usedTypes.arrays) {
      this.compileArrayWithCapacity(n);
    }
    this.compileChannelManager();
    for (n in usedTypes.channels) {
      this.compileChannelWithCapacity(n);
    }
    this.compileAgentTools();
    _ref6 = this.controller.getAgents();
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      p = _ref6[_i];
      p.emitAgentConstructor(this);
      this.beginSystemProcess();
      this.emitProcessApplication(p.getAgentProcessName(), []);
      this.endSystemProcess();
    }
    _ref7 = this.controller.getAllClasses();
    for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
      cls = _ref7[_j];
      cls.emitConstructor(this);
    }
    this.program.compile(this);
    return new CCS(this.controller.root.collectPDefs(), this._getSystem());
  };

  PCCCompiler.prototype._getSystem = function() {
    var i, system, _i, _ref6;

    this.beginSystemProcess();
    this.emitProcessApplication("MainAgent", []);
    this.endSystemProcess();
    system = this.systemProcesses[0];
    for (i = _i = 1, _ref6 = this.systemProcesses.length; _i < _ref6; i = _i += 1) {
      system = new CCSParallel(system, this.systemProcesses[i]);
    }
    return new CCSRestriction(system, ["*", "println"]);
  };

  /*
  		Delegates must implement the following methods:
  		 compilerGetVariable(compiler, identifier)
  		 compilerGetProcedure(compiler, identifier)
  		 compilerHandleNewIdentifierWithDefaultValueCallback(compiler, identifier, callback, context)
  		When these methods are called, the receiver may modify the compiler state by emitting CCS processes, pushing processes, ...
  */


  PCCCompiler.prototype.getVariableWithName = function(name, className, isInternal) {
    if (isInternal) {
      name = PCCVariableInfo.getNameForInternalVariableWithName(name);
    }
    if (className) {
      return this.controller.getClassWithName(className).compilerGetVariable(this, name);
    }
    return this.stack.compilerGetVariable(this, name);
  };

  PCCCompiler.prototype.getProcedureWithName = function(name, className) {
    if (className) {
      return this.controller.getClassWithName(className).compilerGetProcedure(this, name);
    }
    return this.stack.compilerGetProcedure(this, name);
  };

  PCCCompiler.prototype.getClassWithName = function(name) {
    return this.controller.getClassWithName(name);
  };

  PCCCompiler.prototype.getCurrentClass = function() {
    var e, _i, _len, _ref6;

    _ref6 = this.groupElements;
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      e = _ref6[_i];
      if (e instanceof PCCClassStackElement) {
        return e.classInfo;
      }
    }
  };

  PCCCompiler.prototype.getCurrentProcedure = function() {
    var e, _i, _len, _ref6;

    _ref6 = this.groupElements;
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      e = _ref6[_i];
      if (e instanceof PCCProcedureStackElement) {
        return e.procedure;
      }
    }
  };

  PCCCompiler.prototype.getGlobal = function() {
    return this.controller.getGlobal();
  };

  PCCCompiler.prototype.getFreshContainer = function(ccsType, wish) {
    return this.getProcessFrame().createContainer(ccsType, wish);
  };

  PCCCompiler.prototype.handleNewVariableWithDefaultValueCallback = function(variable, callback, context) {
    return this.stack.compilerHandleNewVariableWithDefaultValueCallback(this, variable, callback, context);
  };

  PCCCompiler.prototype._getControlElement = function() {
    return this.stack.getCurrentControlElement();
  };

  PCCCompiler.prototype._handleStackResult = function(resultContainer, controlElement) {
    var result, _i, _len, _ref6, _results;

    _ref6 = resultContainer.results;
    _results = [];
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      result = _ref6[_i];
      _results.push(result.type === PCCStackResult.TYPE_CCSPROCESS_DEFINITION ? controlElement.compilerPushPDef(result.data) : void 0);
    }
    return _results;
  };

  PCCCompiler.prototype.beginSystemProcess = function() {
    var element;

    element = new PCCSystemProcessStackElement();
    this.groupElements.push(element);
    return this.stack.pushElement(element);
  };

  PCCCompiler.prototype.endSystemProcess = function() {
    var element, res;

    element = this.groupElements.pop();
    if (!(element instanceof PCCSystemProcessStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    res = element.removeFromStack();
    return this.systemProcesses.push(res.data);
  };

  PCCCompiler.prototype.emitSystemProcessApplication = function(processName, argumentContainers) {
    this.beginSystemProcess();
    this.emitProcessApplication(processName, argumentContainers);
    return this.endSystemProcess();
  };

  PCCCompiler.prototype.beginProcessGroup = function(groupable, variables) {
    var element, frame;

    frame = new PCCProcessFrame(groupable, variables);
    element = new PCCProcessFrameStackElement(frame);
    this.groupElements.push(element);
    this.stack.pushElement(element);
    return frame.emitProcessDefinition(this);
  };

  PCCCompiler.prototype.endProcessGroup = function() {
    var controlElement, frame;

    frame = this.groupElements.pop();
    if (!(frame instanceof PCCProcessFrameStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(frame.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.getProcessFrame = function() {
    return this.stack.getCurrentProcessFrame();
  };

  PCCCompiler.prototype.addProcessGroupFrame = function(nextFrame) {
    this.stack.pushElement(new PCCProcessFrameStackElement(nextFrame));
    nextFrame.emitProcessDefinition(this);
    return null;
  };

  PCCCompiler.prototype.emitNewScope = function() {
    var frame, scope;

    frame = this.getProcessFrame();
    scope = frame.createNewScope();
    this.stack.pushElement(new PCCScopeStackElement(scope));
    return scope;
  };

  PCCCompiler.prototype.emitNextProcessFrame = function() {
    var frame, next;

    frame = this.getProcessFrame();
    next = frame.createFollowupFrame();
    next.emitCallProcessFromFrame(this, frame);
    this.addProcessGroupFrame(next);
    return next;
  };

  PCCCompiler.prototype.emitMergeOfProcessFramesOfPlaceholders = function(placeholders) {
    var followup, frames, p, _i, _len;

    if (placeholders.length === 0) {
      return null;
    }
    frames = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = placeholders.length; _i < _len; _i++) {
        p = placeholders[_i];
        _results.push(p.frame);
      }
      return _results;
    })();
    followup = PCCProcessFrame.createFollowupFrameForFrames(frames);
    for (_i = 0, _len = placeholders.length; _i < _len; _i++) {
      p = placeholders[_i];
      followup.emitCallProcessFromFrame(this, p.frame, p);
    }
    this.addProcessGroupFrame(followup);
    return followup;
  };

  PCCCompiler.prototype.protectContainer = function(container) {
    return this.getProcessFrame().protectContainer(container);
  };

  PCCCompiler.prototype.unprotectContainer = function() {
    return this.getProcessFrame().unprotectContainer();
  };

  PCCCompiler.prototype.getProtectedContainer = function() {
    return this.getProcessFrame().getProtectedContainer();
  };

  PCCCompiler.prototype._silentlyAddProcessDefinition = function(processName, argumentContainers) {
    var element;

    element = new PCCProcessDefinitionStackElement(processName, argumentContainers);
    this.stack.pushElement(element);
    return element;
  };

  PCCCompiler.prototype.beginProcessDefinition = function(processName, argumentContainers) {
    var element;

    element = this._silentlyAddProcessDefinition(processName, argumentContainers);
    return this.groupElements.push(element);
  };

  PCCCompiler.prototype.isCurrentProcessCompleted = function() {
    return this.stack.isCurrentProcessCompleted();
  };

  PCCCompiler.prototype.endProcessDefinition = function() {
    var controlElement, def;

    def = this.groupElements.pop();
    if (!(def instanceof PCCProcessDefinitionStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(def.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.beginClass = function(className) {
    var curClass, element;

    this.controller.beginClass(className);
    curClass = this.controller.getClassWithName(className);
    if (!curClass) {
      throw new Error("Tried to begin unknown class!");
    }
    element = new PCCClassStackElement(curClass);
    this.stack.pushElement(element);
    return this.groupElements.push(element);
  };

  PCCCompiler.prototype.endClass = function() {
    var cls;

    this.controller.endClass();
    cls = this.groupElements.pop();
    if (!(cls instanceof PCCClassStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    return cls.removeFromStack();
  };

  PCCCompiler.prototype.beginProgram = function() {
    /*
    		throw new Error("Stack already existed before beginning of program!") if @stack != null
    		global = new PCCGlobalStackElement(@controller.getGlobal())
    		@stack = new PCCCompilerStack(global)
    		@groupElements.push(global)
    */

  };

  PCCCompiler.prototype.endProgram = function() {};

  /*
  		global = @groupElements.pop()
  		throw new Error("Unexpected stack element!") if not (global instanceof PCCGlobalStackElement)
  		global.removeFromStack()
  		@stack = null
  */


  PCCCompiler.prototype.beginMainAgent = function() {
    this.controller.beginMainAgent();
    return this.beginProcessGroup(new PCCGroupable("MainAgent"));
  };

  PCCCompiler.prototype.endMainAgent = function() {
    this.controller.endMainAgent();
    return this.endProcessGroup();
  };

  PCCCompiler.prototype.beginProcedure = function(procedureName) {
    var element, frame, procedure;

    this.controller.beginProcedure(procedureName);
    procedure = this.stack.compilerGetProcedure(this, procedureName);
    if (!procedure) {
      throw new Error("Tried to begin unknown procedure!");
    }
    frame = new PCCProcedureFrame(procedure);
    element = new PCCProcedureStackElement(procedure);
    this.stack.pushElement(element);
    this.groupElements.push(element);
    return this.addProcessGroupFrame(frame);
  };

  PCCCompiler.prototype.endProcedure = function() {
    var controlElement, proc;

    this.controller.endProcedure();
    proc = this.groupElements.pop();
    if (!(proc instanceof PCCProcedureStackElement)) {
      throw new Error("Unexpected stack element!");
    }
    controlElement = this._getControlElement();
    return this._handleStackResult(proc.removeFromStack(), controlElement);
  };

  PCCCompiler.prototype.beginStatement = function(statement) {};

  PCCCompiler.prototype.endStatement = function() {};

  PCCCompiler.prototype.beginExpression = function(expression) {};

  PCCCompiler.prototype.endExpression = function() {};

  PCCCompiler.prototype.emitStop = function() {
    return this.stack.pushElement(new PCCStopStackElement());
  };

  PCCCompiler.prototype.emitExit = function() {
    return this.stack.pushElement(new PCCExitStackElement());
  };

  PCCCompiler.prototype.emitProcessApplication = function(processName, argumentContainers) {
    if (argumentContainers == null) {
      argumentContainers = [];
    }
    return this.stack.pushElement(new PCCApplicationStackElement(processName, argumentContainers));
  };

  PCCCompiler.prototype.emitOutput = function(channel, specificChannel, valueContainer) {
    return this.stack.pushElement(new PCCOutputStackElement(channel, specificChannel, valueContainer));
  };

  PCCCompiler.prototype.emitInput = function(channel, specificChannel, container) {
    return this.stack.pushElement(new PCCInputStackElement(channel, specificChannel, container));
  };

  PCCCompiler.prototype.emitCondition = function(condition) {
    return this.stack.pushElement(new PCCConditionStackElement(condition));
  };

  PCCCompiler.prototype.emitChoice = function() {
    var res;

    res = new PCCChoiceStackElement();
    this.stack.pushElement(res);
    if (this.groupElements.length > 1) {
      this.emitNewScope();
    }
    return res;
  };

  PCCCompiler.prototype.emitParallel = function() {
    var res;

    res = new PCCParallelStackElement();
    this.stack.pushElement(res);
    if (this.groupElements.length > 1) {
      this.emitNewScope();
    }
    return res;
  };

  PCCCompiler.prototype.emitSequence = function() {
    var res;

    res = new PCCSequenceStackElement();
    this.stack.pushElement(res);
    return res;
  };

  PCCCompiler.prototype.emitRestriction = function(restrictedChannelNames) {
    return this.stack.pushElement(new PCCRestrictionStackElement(restrictedChannelNames));
  };

  PCCCompiler.prototype.emitProcessApplicationPlaceholder = function() {
    var ph;

    ph = new PCCApplicationPlaceholderStackElement(this.getProcessFrame());
    this.stack.pushElement(ph);
    return ph;
  };

  PCCCompiler.prototype.compileMutex = function() {
    var control, i;

    i = new PCCVariableContainer("i", PCCType.INT);
    this.beginProcessDefinition("Mutex", [i]);
    this.emitInput("lock", i, null);
    this.emitInput("unlock", i, null);
    this.emitProcessApplication("Mutex", [i]);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Mutex_cons", [i]);
    this.emitOutput("mutex_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("Mutex_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitProcessApplication("Mutex", [i]);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Mutex_cons", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileWaitRoom = function() {
    var c, control, control1, control2, control3, i, inner;

    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("WaitRoom", [i, c]);
    control1 = this.emitChoice();
    this.emitInput("signal", i, null);
    inner = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "=="));
    this.emitProcessApplication("WaitRoom", [i, c]);
    inner.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("wait", i, null);
    this.emitProcessApplication("WaitRoom", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    inner.setBranchFinished();
    control1.setBranchFinished();
    control2 = this.emitChoice();
    this.emitInput("add", i, null);
    this.emitProcessApplication("WaitRoom", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "+")]);
    control2.setBranchFinished();
    control3 = this.emitSequence();
    this.emitInput("signal_all", i, null);
    this.emitProcessApplication("WaitDistributor", [i, c]);
    control3.setBranchFinished();
    this.emitProcessApplication("WaitRoom", [i, new PCCConstantContainer(0)]);
    control3.setBranchFinished();
    control2.setBranchFinished();
    control1.setBranchFinished();
    this.endProcessDefinition();
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("WaitDistributor", [i, c]);
    control = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<="));
    this.emitExit();
    control.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("wait", i, null);
    this.emitProcessApplication("WaitDistributor", [i, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    control.setBranchFinished();
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("WaitRoom_cons", [i]);
    this.emitOutput("wait_create", null, i);
    control = this.emitParallel();
    this.emitProcessApplication("WaitRoom_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitProcessApplication("WaitRoom", [i, new PCCConstantContainer(0)]);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("WaitRoom_cons", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileArrayWithCapacity = function(size) {
    var args, control, def, emitAccessors, i, index, j, _i, _j, _k, _ref6;

    i = new PCCVariableContainer("i", PCCType.INT);
    args = [i];
    for (j = _i = 0; 0 <= size ? _i < size : _i > size; j = 0 <= size ? ++_i : --_i) {
      args.push(new PCCVariableContainer("v" + j, PCCType.INT));
    }
    this.beginProcessDefinition("Array" + size, args);
    index = new PCCVariableContainer("index", PCCType.INT);
    this.emitInput("array_access", i, index);
    emitAccessors = function(compiler, i, size, j, args) {
      var inner;

      compiler.emitCondition(new PCCBinaryContainer(index, new PCCConstantContainer(j), "=="));
      inner = compiler.emitChoice();
      compiler.emitOutput("array_get", i, args[j + 1]);
      compiler.emitProcessApplication("Array" + size, args);
      inner.setBranchFinished();
      compiler.emitInput("array_set", i, args[j + 1]);
      compiler.emitProcessApplication("Array" + size, args);
      return inner.setBranchFinished();
    };
    for (j = _j = 0, _ref6 = size - 1; 0 <= _ref6 ? _j < _ref6 : _j > _ref6; j = 0 <= _ref6 ? ++_j : --_j) {
      control = this.emitChoice();
      emitAccessors(this, i, size, j, args);
      control.setBranchFinished();
    }
    emitAccessors(this, i, size, size - 1, args);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Array" + size + "_cons", []);
    this.emitInput("array_new", null, i);
    def = new PCCVariableContainer("d", PCCType.VOID);
    this.emitOutput("array" + size + "_create", null, i);
    this.emitInput("array_setDefault", i, def);
    control = this.emitParallel();
    this.emitProcessApplication("Array" + size + "_cons", []);
    control.setBranchFinished();
    args = [i];
    for (j = _k = 0; 0 <= size ? _k < size : _k > size; j = 0 <= size ? ++_k : --_k) {
      args.push(def);
    }
    this.emitProcessApplication("Array" + size, args);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Array" + size + "_cons", []);
  };

  PCCCompiler.prototype.compileArrayManager = function() {
    var i;

    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("ArrayManager", [i]);
    this.emitOutput("array_new", null, i);
    this.emitProcessApplication("ArrayManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("ArrayManager", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileChannelWithCapacity = function(capacity) {
    var args, c, control, def, i, j, v, _i, _j, _k;

    if (capacity <= 0) {
      return this.compileUnbufferedChannelCons();
    }
    i = new PCCVariableContainer("i", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    args = [i, c];
    for (j = _i = 0; 0 <= capacity ? _i < capacity : _i > capacity; j = 0 <= capacity ? ++_i : --_i) {
      args.push(new PCCVariableContainer("v" + j, PCCType.INT));
    }
    this.beginProcessDefinition("Channel" + capacity, args);
    args[1] = new PCCBinaryContainer(c, new PCCConstantContainer(1), "+");
    for (j = _j = 0; 0 <= capacity ? _j < capacity : _j > capacity; j = 0 <= capacity ? ++_j : --_j) {
      control = this.emitChoice();
      this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(j), "=="));
      v = new PCCVariableContainer("v" + j, PCCType.INT);
      this.emitInput("put", i, v);
      this.emitProcessApplication("Channel" + capacity, args);
      control.setBranchFinished();
    }
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitOutput("receive", i, new PCCVariableContainer("v0", PCCType.INT));
    args.splice(2, 1);
    args.push(new PCCConstantContainer(0));
    args[1] = new PCCBinaryContainer(c, new PCCConstantContainer(1), "-");
    this.emitProcessApplication("Channel" + capacity, args);
    this.endProcessDefinition();
    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("Channel" + capacity + "_cons", []);
    this.emitInput("channel_new", null, i);
    def = new PCCVariableContainer("d", PCCType.VOID);
    this.emitOutput("channel" + capacity + "_create", null, i);
    this.emitInput("channel_setDefault", i, def);
    control = this.emitParallel();
    this.emitProcessApplication("Channel" + capacity + "_cons", []);
    control.setBranchFinished();
    args = [i, new PCCConstantContainer(0)];
    for (j = _k = 0; 0 <= capacity ? _k < capacity : _k > capacity; j = 0 <= capacity ? ++_k : --_k) {
      args.push(def);
    }
    this.emitProcessApplication("Channel" + capacity, args);
    control.setBranchFinished();
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Channel" + capacity + "_cons", []);
  };

  PCCCompiler.prototype.compileUnbufferedChannelCons = function() {
    var i;

    i = new PCCVariableContainer("i", PCCType.INT);
    this.beginProcessDefinition("Channel_cons", [i]);
    this.emitOutput("channel_create", null, i);
    this.emitProcessApplication("Channel_cons", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "-")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Channel_cons", [new PCCConstantContainer(-1)]);
  };

  PCCCompiler.prototype.compileChannelManager = function() {
    var i;

    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("ChannelManager", [i]);
    this.emitOutput("channel_new", null, i);
    this.emitProcessApplication("ChannelManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("ChannelManager", [new PCCConstantContainer(1)]);
  };

  PCCCompiler.prototype.compileAgentTools = function() {
    var a, c, control, i;

    i = new PCCVariableContainer("next_i", PCCType.INT);
    this.beginProcessDefinition("AgentManager", [i]);
    this.emitOutput("agent_new", null, i);
    this.emitProcessApplication("AgentManager", [new PCCBinaryContainer(i, new PCCConstantContainer(1), "+")]);
    this.endProcessDefinition();
    this.emitSystemProcessApplication("AgentManager", [new PCCConstantContainer(1)]);
    a = new PCCVariableContainer("a", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("AgentJoiner", [a, c]);
    control = this.emitChoice();
    this.emitInput("join_register", a, null);
    this.emitProcessApplication("AgentJoiner", [a, new PCCBinaryContainer(c, new PCCConstantContainer(1), "+")]);
    control.setBranchFinished();
    this.emitInput("agent_terminate", a, null);
    this.emitProcessApplication("JoinDistributor", [a, c]);
    control.setBranchFinished();
    this.endProcessDefinition();
    a = new PCCVariableContainer("a", PCCType.INT);
    c = new PCCVariableContainer("c", PCCType.INT);
    this.beginProcessDefinition("JoinDistributor", [a, c]);
    control = this.emitChoice();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<="));
    this.emitInput("join_register", a, null);
    this.emitInput("join", a, null);
    this.emitProcessApplication("JoinDistributor", [a, new PCCConstantContainer(0)]);
    control.setBranchFinished();
    this.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">"));
    this.emitInput("join", a, null);
    this.emitProcessApplication("JoinDistributor", [a, new PCCBinaryContainer(c, new PCCConstantContainer(1), "-")]);
    control.setBranchFinished();
    return this.endProcessDefinition();
  };

  PCCCompiler.prototype.compileReturn = function() {
    var v;

    this.beginProcessDefinition("Return", []);
    v = new PCCVariableContainer("v", PCCType.INT);
    this.emitInput("return", null, v);
    this.emitOutput("rreturn", null, v);
    this.emitProcessApplication("Return", []);
    this.endProcessDefinition();
    return this.emitSystemProcessApplication("Return", []);
  };

  return PCCCompiler;

})();

PCEnvironmentNode.prototype.compilerPushPDef = function(pdef) {
  if (!this.PCCCompilerPDefs) {
    this.PCCCompilerPDefs = [];
  }
  return this.PCCCompilerPDefs.push(pdef);
};

PCVariable.prototype.compilerPushPDef = PCEnvironmentNode.prototype.compilerPushPDef;

PCEnvironmentNode.prototype.collectPDefs = function() {
  var c;

  if (!this.PCCCompilerPDefs) {
    this.PCCCompilerPDefs = [];
  }
  return this.PCCCompilerPDefs.concat(((function() {
    var _i, _len, _ref6, _results;

    _ref6 = this.children;
    _results = [];
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      c = _ref6[_i];
      _results.push(c.collectPDefs());
    }
    return _results;
  }).call(this)).concatChildren());
};

PCVariable.prototype.collectPDefs = function() {
  if (this.PCCCompilerPDefs) {
    return this.PCCCompilerPDefs;
  } else {
    return [];
  }
};

/*
PCStmtExpression::collectAgents = (env) -> 
	@children[0].collectAgents(env)
PCVariableDeclarator::collectEnvironment = (env, type) ->
	@children.length > 0 and @children[0].collectEnvironment(env)
PCVariableInitializer::collectEnvironment = (env) ->
	!@isArray() and @children[0].collectEnvironment(env)
PCExpression::collectEnvironment = (env) -> c.collectEnvironment(env) for c in @children
PCStartExpression::collectEnvironment = (env) ->
	env instanceof PCCProgramController and env.processProcedureAsAgent(@children[0].getProcedure(env))
*/


PCCConstructor = (function() {
  function PCCConstructor(compiler, delegate, context) {
    this.compiler = compiler;
    this.delegate = delegate;
    this.context = context;
  }

  PCCConstructor.prototype.emit = function() {
    var control, entry, envArgCount, envName, i, recursion, v, variables, vars, _base, _i;

    envName = this.delegate.constructorGetName(this, this.context);
    variables = this.delegate.constructorGetArguments(this, this.compiler, this.context);
    this.compiler.beginProcessGroup(new PCCGroupable(envName + "_cons"), variables);
    entry = this.compiler.getProcessFrame();
    variables = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = variables.length; _i < _len; _i++) {
        v = variables[_i];
        _results.push(this.compiler.getVariableWithName(v.getName(), null, v.isInternal));
      }
      return _results;
    }).call(this);
    envArgCount = this.delegate.constructorProtectEnvironmentArguments(this, this.compiler, variables, this.context);
    vars = [];
    for (i = _i = 0; 0 <= envArgCount ? _i < envArgCount : _i > envArgCount; i = 0 <= envArgCount ? ++_i : --_i) {
      vars.unshift(this.compiler.unprotectContainer());
    }
    recursion = typeof (_base = this.delegate).constructorShouldCallRecursively === "function" ? _base.constructorShouldCallRecursively(this, this.context) : void 0;
    control = null;
    if (recursion) {
      control = this.compiler.emitParallel();
    }
    this.compiler.emitProcessApplication(envName, vars);
    if (recursion) {
      control.setBranchFinished();
      this.delegate.constructorUpdateVariablesForRecursiveCall(this, this.compiler, entry, variables, this.context);
      entry.emitCallProcessFromFrame(this.compiler, this.compiler.getProcessFrame());
      control.setBranchFinished();
    }
    return this.compiler.endProcessGroup();
  };

  return PCCConstructor;

})();

PCCConstructor.emitConstructor = function(compiler, delegate, context) {
  return (new PCCConstructor(compiler, delegate, context)).emit();
};

/*
	Manages different kinds of containers. Containers basically wrap CCS Expressions.
*/


PCCContainer = (function() {
  function PCCContainer(ccsType) {
    this.ccsType = ccsType;
  }

  PCCContainer.prototype.isReadonly = function() {
    throw new Error("Abstract");
  };

  PCCContainer.prototype.ccsTree = function() {
    throw new Error("Abstract");
  };

  PCCContainer.prototype.isEqual = function(container) {
    throw new Error("Abstract");
  };

  return PCCContainer;

})();

PCCConstantContainer = (function(_super) {
  __extends(PCCConstantContainer, _super);

  function PCCConstantContainer(value) {
    this.value = value;
    if (typeof this.value === "boolean") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (typeof this.value === "number") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (typeof this.value === "string") {
      PCCConstantContainer.__super__.constructor.call(this, PCCType.STRING);
    } else {
      throw new Error("Unknown type");
    }
  }

  PCCConstantContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCConstantContainer.prototype.ccsTree = function() {
    return new CCSConstantExpression(this.value);
  };

  PCCConstantContainer.prototype.isEqual = function(container) {
    return container instanceof PCCConstantContainer && container.value === this.value;
  };

  return PCCConstantContainer;

})(PCCContainer);

PCCVariableContainer = (function(_super) {
  __extends(PCCVariableContainer, _super);

  function PCCVariableContainer(identifier, ccsType) {
    this.identifier = identifier;
    PCCVariableContainer.__super__.constructor.call(this, ccsType);
  }

  PCCVariableContainer.prototype.isReadonly = function() {
    return false;
  };

  PCCVariableContainer.prototype.ccsTree = function() {
    return new CCSVariableExpression(this.identifier);
  };

  PCCVariableContainer.prototype.isEqual = function(container) {
    return container instanceof PCCVariableContainer && container.identifier === this.identifier;
  };

  return PCCVariableContainer;

})(PCCContainer);

PCCComposedContainer = (function(_super) {
  __extends(PCCComposedContainer, _super);

  function PCCComposedContainer(ccsType) {
    PCCComposedContainer.__super__.constructor.call(this, ccsType);
  }

  return PCCComposedContainer;

})(PCCContainer);

PCCBinaryContainer = (function(_super) {
  __extends(PCCBinaryContainer, _super);

  function PCCBinaryContainer(leftContainer, rightContainer, operator) {
    this.leftContainer = leftContainer;
    this.rightContainer = rightContainer;
    this.operator = operator;
    if (this.operator === "+" || this.operator === "^") {
      if (this.leftContainer.ccsType.isString() || this.rightContainer.ccsType.isString() || this.operator === "^") {
        this.exp = new CCSConcatenatingExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree());
        PCCBinaryContainer.__super__.constructor.call(this, PCCType.STRING);
      } else {
        this.exp = new CCSAdditiveExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
        PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
      }
    } else if (this.operator === "-") {
      this.exp = new CCSAdditiveExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator === "*" || this.operator === "/" || this.operator === "%") {
      this.exp = new CCSMultiplicativeExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator === "<" || this.operator === "<=" || this.operator === ">" || this.operator === ">=") {
      this.exp = new CCSRelationalExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "==" || this.operator === "!=") {
      this.exp = new CCSEqualityExpression(this.leftContainer.ccsTree(), this.rightContainer.ccsTree(), this.operator);
      PCCBinaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "&&") {
      throw new Error("Not available in CCS");
    } else if (this.operator === "||") {
      throw new Error("Not available in CCS");
    } else {
      throw new Error("Unknown operator");
    }
  }

  PCCBinaryContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCBinaryContainer.prototype.ccsTree = function() {
    return this.exp;
  };

  PCCBinaryContainer.prototype.isEqual = function(container) {
    return container instanceof PCCBinaryContainer && container.operator === this.operator && container.leftContainer.isEqual(this.leftContainer) && container.rightContainer.isEqual(this.rightContainer);
  };

  return PCCBinaryContainer;

})(PCCComposedContainer);

PCCUnaryContainer = (function(_super) {
  __extends(PCCUnaryContainer, _super);

  function PCCUnaryContainer(operator, container) {
    this.operator = operator;
    this.container = container;
    if (this.operator === "!") {
      this.exp = new CCSEqualityExpression(this.container.ccsTree(), new CCSConstantExpression(false), "==");
      PCCUnaryContainer.__super__.constructor.call(this, PCCType.BOOL);
    } else if (this.operator === "-") {
      this.exp = new CCSAdditiveExpression(new CCSConstantExpression(0), this.container.ccsTree(), "-");
      PCCUnaryContainer.__super__.constructor.call(this, PCCType.INT);
    } else if (this.operator !== "+") {
      throw new Error("Unknown operator");
    }
  }

  PCCUnaryContainer.prototype.isReadonly = function() {
    return true;
  };

  PCCUnaryContainer.prototype.ccsTree = function() {
    return this.exp;
  };

  PCCUnaryContainer.prototype.isEqual = function(container) {
    return container instanceof PCCConstantContainer && container.operator === this.operator && container.container.isEqual(this.container);
  };

  return PCCUnaryContainer;

})(PCCComposedContainer);

/*
PCCContainer.RETURN = -> new PCCVariableContainer("i_r")
PCCContainer.INSTANCE = -> new PCCVariableContainer("i_i")
PCCContainer.GUARD = -> new PCCVariableContainer("i_g")
*/


PCCStackElement = (function() {
  function PCCStackElement() {
    this.parent = null;
  }

  PCCStackElement.prototype.getResult = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.getNext = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.setNext = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.removeNext = function(next) {
    throw new Error("Abstract and not implemented!");
  };

  PCCStackElement.prototype.getTopElement = function() {
    var next;

    next = this.getNext();
    if (next === null) {
      return this;
    } else {
      return next.getTopElement();
    }
  };

  PCCStackElement.prototype.getCurrentProcessFrame = function() {
    var _ref6;

    return (_ref6 = this.parent) != null ? _ref6.getCurrentProcessFrame() : void 0;
  };

  PCCStackElement.prototype.getCurrentControlElement = function() {
    var _ref6;

    return (_ref6 = this.parent) != null ? _ref6.getCurrentControlElement() : void 0;
  };

  PCCStackElement.prototype.getResults = function() {
    throw new Error("Not implemented");
  };

  PCCStackElement.prototype.removeFromStack = function() {
    var _ref6;

    this.getStack().setTopElement(this.parent);
    if ((_ref6 = this.parent) != null) {
      _ref6.removeNext(this);
    }
    return this.getResults();
  };

  PCCStackElement.prototype.isCompletedProcess = function() {
    return false;
  };

  PCCStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var _ref6;

    return (_ref6 = this.parent) != null ? _ref6.compilerGetVariable(compiler, identifier) : void 0;
  };

  PCCStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var _ref6;

    return (_ref6 = this.parent) != null ? _ref6.compilerGetProcedure(compiler, identifier) : void 0;
  };

  PCCStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var _ref6;

    return (_ref6 = this.parent) != null ? _ref6.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context) : void 0;
  };

  return PCCStackElement;

})();

PCCUnaryStackElement = (function(_super) {
  __extends(PCCUnaryStackElement, _super);

  function PCCUnaryStackElement() {
    this.next = null;
    PCCUnaryStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCUnaryStackElement.prototype.getResults = function() {
    if (this.next === null) {
      return new PCCStackResultContainer();
    } else {
      return this.next.getResults();
    }
  };

  PCCUnaryStackElement.prototype.getNext = function() {
    return this.next;
  };

  PCCUnaryStackElement.prototype.setNext = function(next) {
    if (this.next !== null) {
      throw new Error("Can't set next twice!");
    }
    next.parent = this;
    return this.next = next;
  };

  PCCUnaryStackElement.prototype.removeNext = function(next) {
    if (this.next !== next) {
      throw new Error("Unknown next");
    }
    next.parent = null;
    return this.next = null;
  };

  return PCCUnaryStackElement;

})(PCCStackElement);

PCCBinaryStackElement = (function(_super) {
  __extends(PCCBinaryStackElement, _super);

  function PCCBinaryStackElement() {
    this.leftStack = null;
    this.rightStack = null;
    this.topStack = null;
    this.target = 0;
    PCCBinaryStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCBinaryStackElement.prototype.getResults = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCBinaryStackElement.prototype.getNext = function() {
    if (this.target === PCCBinaryTarget.LEFT) {
      return this.leftStack;
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      return this.rightStack;
    } else {
      return this.topStack;
    }
  };

  PCCBinaryStackElement.prototype.setNext = function(next) {
    if (next) {
      next.parent = this;
    }
    if (this.target === PCCBinaryTarget.LEFT) {
      if (this.leftStack) {
        throw new Error("Can't set next twice!");
      }
      return this.leftStack = next;
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      if (this.rightStack) {
        throw new Error("Can't set next twice!");
      }
      return this.rightStack = next;
    } else {
      if (this.topStack) {
        throw new Error("Can't set next twice!");
      }
      return this.topStack = next;
    }
  };

  PCCBinaryStackElement.prototype.removeNext = function(next) {
    if (this.next !== this.getNext()) {
      throw new Error("Unknown next");
    }
    return this.setNext(null);
  };

  PCCBinaryStackElement.prototype.setTarget = function(target) {
    if (target < 0 || target > 2) {
      raise(new Error("Illegal target!"));
    }
    if (target === PCCBinaryTarget.TOP && this.topStack) {
      raise(new Error("Left and right target are not allowed once top was modified!"));
    }
    this.target = target;
    this.getStack().setTopElement(this.getTopElement());
    return this.parent.updateBinaryTargets(this);
  };

  PCCBinaryStackElement.prototype.setBranchFinished = function() {
    if (this.target === PCCBinaryTarget.TOP) {
      throw new Error("All branches are already finished!");
    } else if (this.target === PCCBinaryTarget.RIGHT) {
      this.setTarget(PCCBinaryTarget.TOP);
    } else if (this.target === PCCBinaryTarget.LEFT) {
      this.setTarget(PCCBinaryTarget.RIGHT);
    } else {
      throw new Error("Unknown target is currently specified!");
    }
    return null;
  };

  PCCBinaryStackElement.prototype.updateBinaryTargets = function(destination) {
    if (destination === this.leftStack) {
      return this.target = PCCBinaryTarget.LEFT;
    } else if (destination === this.rightStack) {
      return this.target = PCCBinaryTarget.RIGHT;
    } else if (destination === this.topStack) {
      return this.target = PCCBinaryTarget.TOP;
    } else {
      throw new Error("Unknown destination!");
    }
  };

  return PCCBinaryStackElement;

})(PCCStackElement);

PCCBinaryTarget = {};

PCCBinaryTarget.LEFT = 0;

PCCBinaryTarget.RIGHT = 1;

PCCBinaryTarget.TOP = 2;

PCCStackElement.prototype.updateBinaryTargets = function(destination) {
  var _ref6;

  return (_ref6 = this.parent) != null ? _ref6.updateBinaryTargets(this) : void 0;
};

PCCStopStackElement = (function(_super) {
  __extends(PCCStopStackElement, _super);

  function PCCStopStackElement() {
    _ref6 = PCCStopStackElement.__super__.constructor.apply(this, arguments);
    return _ref6;
  }

  PCCStopStackElement.prototype.getResults = function() {
    var more;

    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, new CCSStop());
    return more;
  };

  PCCStopStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCStopStackElement;

})(PCCUnaryStackElement);

PCCExitStackElement = (function(_super) {
  __extends(PCCExitStackElement, _super);

  function PCCExitStackElement() {
    _ref7 = PCCExitStackElement.__super__.constructor.apply(this, arguments);
    return _ref7;
  }

  PCCExitStackElement.prototype.getResults = function() {
    var more;

    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, new CCSExit());
    return more;
  };

  PCCExitStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCExitStackElement;

})(PCCUnaryStackElement);

PCCPrefixStackElement = (function(_super) {
  __extends(PCCPrefixStackElement, _super);

  function PCCPrefixStackElement(channel, specificChannel) {
    this.channel = channel;
    this.specificChannel = specificChannel;
    PCCPrefixStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCPrefixStackElement.prototype._getChannel = function() {
    return new CCSChannel(this.channel, this.specificChannel ? this.specificChannel.ccsTree() : null);
  };

  PCCPrefixStackElement.prototype._getAction = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCPrefixStackElement.prototype.getResults = function() {
    var container, pRes;

    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, new CCSPrefix(this._getAction(), pRes.data));
    return container;
  };

  PCCPrefixStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCPrefixStackElement;

})(PCCUnaryStackElement);

PCCInputStackElement = (function(_super) {
  __extends(PCCInputStackElement, _super);

  function PCCInputStackElement(channel, specificChannel, container) {
    this.container = container;
    PCCInputStackElement.__super__.constructor.call(this, channel, specificChannel);
  }

  PCCInputStackElement.prototype._getAction = function() {
    return new CCSInput(this._getChannel(), this.container ? this.container.identifier : null);
  };

  return PCCInputStackElement;

})(PCCPrefixStackElement);

PCCOutputStackElement = (function(_super) {
  __extends(PCCOutputStackElement, _super);

  function PCCOutputStackElement(channel, sepcificChannel, container) {
    this.container = container;
    PCCOutputStackElement.__super__.constructor.call(this, channel, sepcificChannel);
  }

  PCCOutputStackElement.prototype._getAction = function() {
    return new CCSOutput(this._getChannel(), this.container ? this.container.ccsTree() : null);
  };

  return PCCOutputStackElement;

})(PCCPrefixStackElement);

PCCConditionStackElement = (function(_super) {
  __extends(PCCConditionStackElement, _super);

  function PCCConditionStackElement(conditionContainer) {
    this.conditionContainer = conditionContainer;
    PCCConditionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCConditionStackElement.prototype.getResults = function() {
    var container, pRes;

    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, new CCSCondition(this.conditionContainer.ccsTree(), pRes.data));
    return container;
  };

  PCCConditionStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCConditionStackElement;

})(PCCUnaryStackElement);

PCCRestrictionStackElement = (function(_super) {
  __extends(PCCRestrictionStackElement, _super);

  function PCCRestrictionStackElement(restrictedChannels) {
    this.restrictedChannels = restrictedChannels;
    PCCRestrictionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCRestrictionStackElement.prototype.getResults = function() {
    var container, pRes;

    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS, new CCSRestriction(pRes.data, this.restrictedChannels));
    return container;
  };

  PCCRestrictionStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCRestrictionStackElement;

})(PCCUnaryStackElement);

PCCApplicationStackElement = (function(_super) {
  __extends(PCCApplicationStackElement, _super);

  function PCCApplicationStackElement(processName, argContainers) {
    this.processName = processName;
    if (argContainers === void 0) {
      argContainers = [];
    }
    if (argContainers) {
      this.argContainers = argContainers.slice(0);
    }
    PCCApplicationStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCApplicationStackElement.prototype.getResults = function() {
    var c, more, values;

    more = this.next ? this.next.getResults() : new PCCStackResultContainer();
    values = (function() {
      var _i, _len, _ref8, _results;

      _ref8 = this.argContainers;
      _results = [];
      for (_i = 0, _len = _ref8.length; _i < _len; _i++) {
        c = _ref8[_i];
        _results.push(c.ccsTree());
      }
      return _results;
    }).call(this);
    more.addResult(PCCStackResult.TYPE_CCSPROCESS, new CCSProcessApplication(this.processName, values));
    return more;
  };

  PCCApplicationStackElement.prototype.isCompletedProcess = function() {
    return true;
  };

  return PCCApplicationStackElement;

})(PCCUnaryStackElement);

PCCApplicationPlaceholderStackElement = (function(_super) {
  __extends(PCCApplicationPlaceholderStackElement, _super);

  function PCCApplicationPlaceholderStackElement(frame) {
    this.frame = frame;
    PCCApplicationPlaceholderStackElement.__super__.constructor.call(this, null, null);
  }

  PCCApplicationPlaceholderStackElement.prototype.set = function(processName, argContainers) {
    if (argContainers == null) {
      argContainers = [];
    }
    if (this.processName || this.argContainers) {
      throw new Error("Placeholder values can't be set twice!");
    }
    this.processName = processName;
    this.argContainers = argContainers.slice(0);
    return null;
  };

  PCCApplicationPlaceholderStackElement.prototype.getResults = function() {
    if (!this.processName || !this.argContainers) {
      throw new Error("Placeholder without values!");
    }
    return PCCApplicationPlaceholderStackElement.__super__.getResults.apply(this, arguments);
  };

  return PCCApplicationPlaceholderStackElement;

})(PCCApplicationStackElement);

PCCBinaryCCSStackElement = (function(_super) {
  __extends(PCCBinaryCCSStackElement, _super);

  function PCCBinaryCCSStackElement() {
    _ref8 = PCCBinaryCCSStackElement.__super__.constructor.apply(this, arguments);
    return _ref8;
  }

  PCCBinaryCCSStackElement.prototype._createCCSProcess = function() {
    throw new Error("Abstract and not implemented!");
  };

  PCCBinaryCCSStackElement.prototype.getResults = function() {
    var left, leftContainer, more, right, rightContainer;

    more = this.topStack ? this.topStack.getResults() : new PCCStackResultContainer();
    leftContainer = this.leftStack.getResults();
    left = leftContainer.getResult();
    if (left.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    rightContainer = this.rightStack.getResults();
    right = rightContainer.getResult();
    if (right.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    rightContainer.removeResult();
    leftContainer.appendContainer(rightContainer);
    leftContainer.appendContainer(more);
    leftContainer.replaceResult(PCCStackResult.TYPE_CCSPROCESS, this._createCCSProcess(left.data, right.data));
    return leftContainer;
  };

  PCCBinaryCCSStackElement.prototype.isCompletedProcess = function() {
    if (this.leftStack && this.rightStack) {
      return this.leftStack.isCompletedProcess() && this.rightStack.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCBinaryCCSStackElement;

})(PCCBinaryStackElement);

PCCChoiceStackElement = (function(_super) {
  __extends(PCCChoiceStackElement, _super);

  function PCCChoiceStackElement() {
    _ref9 = PCCChoiceStackElement.__super__.constructor.apply(this, arguments);
    return _ref9;
  }

  PCCChoiceStackElement.prototype._createCCSProcess = function(left, right) {
    return new CCSChoice(left, right);
  };

  return PCCChoiceStackElement;

})(PCCBinaryCCSStackElement);

PCCParallelStackElement = (function(_super) {
  __extends(PCCParallelStackElement, _super);

  function PCCParallelStackElement() {
    _ref10 = PCCParallelStackElement.__super__.constructor.apply(this, arguments);
    return _ref10;
  }

  PCCParallelStackElement.prototype._createCCSProcess = function(left, right) {
    return new CCSParallel(left, right);
  };

  return PCCParallelStackElement;

})(PCCBinaryCCSStackElement);

PCCSequenceStackElement = (function(_super) {
  __extends(PCCSequenceStackElement, _super);

  function PCCSequenceStackElement() {
    _ref11 = PCCSequenceStackElement.__super__.constructor.apply(this, arguments);
    return _ref11;
  }

  PCCSequenceStackElement.prototype._createCCSProcess = function(left, right) {
    return new CCSSequence(left, right);
  };

  return PCCSequenceStackElement;

})(PCCBinaryCCSStackElement);

PCCSystemProcessStackElement = (function(_super) {
  __extends(PCCSystemProcessStackElement, _super);

  function PCCSystemProcessStackElement() {
    _ref12 = PCCSystemProcessStackElement.__super__.constructor.apply(this, arguments);
    return _ref12;
  }

  PCCSystemProcessStackElement.prototype.getResults = function() {
    var container, pRes;

    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    return pRes;
  };

  return PCCSystemProcessStackElement;

})(PCCUnaryStackElement);

PCCProcessDefinitionStackElement = (function(_super) {
  __extends(PCCProcessDefinitionStackElement, _super);

  function PCCProcessDefinitionStackElement(processName, argContainers) {
    this.processName = processName;
    if (argContainers == null) {
      argContainers = [];
    }
    this.argContainers = argContainers.slice(0);
    PCCProcessDefinitionStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcessDefinitionStackElement.prototype.getResults = function() {
    var argNames, c, container, def, pRes;

    container = this.next.getResults();
    pRes = container.getResult();
    if (pRes.type !== PCCStackResult.TYPE_CCSPROCESS) {
      throw new Error("Unexpected result type!");
    }
    argNames = (function() {
      var _i, _len, _ref13, _results;

      _ref13 = this.argContainers;
      _results = [];
      for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
        c = _ref13[_i];
        _results.push(c.identifier);
      }
      return _results;
    }).call(this);
    def = new CCSProcessDefinition(this.processName, pRes.data, argNames);
    container.replaceResult(PCCStackResult.TYPE_CCSPROCESS_DEFINITION, def);
    return container;
  };

  return PCCProcessDefinitionStackElement;

})(PCCUnaryStackElement);

PCCProcessFrameStackElement = (function(_super) {
  __extends(PCCProcessFrameStackElement, _super);

  function PCCProcessFrameStackElement(frame) {
    this.frame = frame;
    PCCProcessFrameStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcessFrameStackElement.prototype.getCurrentProcessFrame = function() {
    return this.frame;
  };

  PCCProcessFrameStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;

    result = this.frame.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;

    result = this.frame.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCProcessFrameStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;

    result = this.frame.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCProcessFrameStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCProcessFrameStackElement;

})(PCCUnaryStackElement);

PCCScopeStackElement = (function(_super) {
  __extends(PCCScopeStackElement, _super);

  function PCCScopeStackElement() {
    _ref13 = PCCScopeStackElement.__super__.constructor.apply(this, arguments);
    return _ref13;
  }

  PCCScopeStackElement.prototype.isCompletedProcess = function() {
    if (this.next) {
      return this.next.isCompletedProcess();
    } else {
      return false;
    }
  };

  return PCCScopeStackElement;

})(PCCProcessFrameStackElement);

PCCClassStackElement = (function(_super) {
  __extends(PCCClassStackElement, _super);

  function PCCClassStackElement(classInfo) {
    this.classInfo = classInfo;
    PCCClassStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCClassStackElement.prototype.getCurrentControlElement = function() {
    return this.classInfo;
  };

  PCCClassStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;

    result = this.classInfo.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCClassStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;

    result = this.classInfo.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCClassStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;

    result = this.classInfo.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCClassStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCClassStackElement;

})(PCCUnaryStackElement);

PCCGlobalStackElement = (function(_super) {
  __extends(PCCGlobalStackElement, _super);

  function PCCGlobalStackElement(global) {
    this.global = global;
    PCCGlobalStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCGlobalStackElement.prototype.getCurrentControlElement = function() {
    return this.global;
  };

  PCCGlobalStackElement.prototype.compilerGetVariable = function(compiler, identifier) {
    var result;

    result = this.global.compilerGetVariable(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerGetVariable.apply(this, arguments);
    }
  };

  PCCGlobalStackElement.prototype.compilerGetProcedure = function(compiler, identifier) {
    var result;

    result = this.global.compilerGetProcedure(compiler, identifier);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerGetProcedure.apply(this, arguments);
    }
  };

  PCCGlobalStackElement.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var result;

    result = this.global.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context);
    if (result) {
      return result;
    } else {
      return PCCGlobalStackElement.__super__.compilerHandleNewVariableWithDefaultValueCallback.apply(this, arguments);
    }
  };

  return PCCGlobalStackElement;

})(PCCUnaryStackElement);

PCCProcedureStackElement = (function(_super) {
  __extends(PCCProcedureStackElement, _super);

  function PCCProcedureStackElement(procedure) {
    this.procedure = procedure;
    PCCProcedureStackElement.__super__.constructor.apply(this, arguments);
  }

  PCCProcedureStackElement.prototype.getCurrentControlElement = function() {
    return this.procedure;
  };

  return PCCProcedureStackElement;

})(PCCUnaryStackElement);

PCCCompilerStack = (function() {
  function PCCCompilerStack(initialElement) {
    this.topElement = initialElement;
    this.topElement.__PCCCompilerStack = this;
    this.topElement.getStack = function() {
      return this.__PCCCompilerStack;
    };
  }

  PCCCompilerStack.prototype.setTopElement = function(e) {
    return this.topElement = e;
  };

  PCCCompilerStack.prototype.getCurrentProcessFrame = function() {
    return this.topElement.getCurrentProcessFrame();
  };

  PCCCompilerStack.prototype.getCurrentControlElement = function() {
    return this.topElement.getCurrentControlElement();
  };

  PCCCompilerStack.prototype.pushElement = function(e) {
    this.topElement.setNext(e);
    return this.topElement = e;
  };

  PCCCompilerStack.prototype.isCurrentProcessCompleted = function() {
    return this.topElement.isCompletedProcess();
  };

  PCCCompilerStack.prototype.compilerGetVariable = function(compiler, identifier) {
    var _ref14;

    return (_ref14 = this.topElement) != null ? _ref14.compilerGetVariable(compiler, identifier) : void 0;
  };

  PCCCompilerStack.prototype.compilerGetProcedure = function(compiler, identifier) {
    var _ref14;

    return (_ref14 = this.topElement) != null ? _ref14.compilerGetProcedure(compiler, identifier) : void 0;
  };

  PCCCompilerStack.prototype.compilerHandleNewVariableWithDefaultValueCallback = function(compiler, variable, callback, context) {
    var _ref14;

    return (_ref14 = this.topElement) != null ? _ref14.compilerHandleNewVariableWithDefaultValueCallback(compiler, variable, callback, context) : void 0;
  };

  return PCCCompilerStack;

})();

PCCStackElement.prototype.getStack = function() {
  return this.parent.getStack();
};

PCCStackResult = (function() {
  function PCCStackResult(type, data) {
    this.type = type;
    this.data = data;
  }

  return PCCStackResult;

})();

PCCStackResultContainer = (function() {
  function PCCStackResultContainer() {
    this.results = [];
  }

  PCCStackResultContainer.prototype.addResult = function(type, data) {
    return this.results.unshift(new PCCStackResult(type, data));
  };

  PCCStackResultContainer.prototype.replaceResult = function(type, data) {
    return this.results[0] = new PCCStackResult(type, data);
  };

  PCCStackResultContainer.prototype.getResult = function() {
    return this.results[0];
  };

  PCCStackResultContainer.prototype.removeResult = function() {
    return this.results.shift();
  };

  PCCStackResultContainer.prototype.appendContainer = function(container) {
    return this.results = this.results.concat(container.results);
  };

  return PCCStackResultContainer;

})();

PCCStackResult.TYPE_UNSPECIFIC = 0;

PCCStackResult.TYPE_CCSPROCESS = 1;

PCCStackResult.TYPE_CCSPROCESS_DEFINITION = 2;

PCNode.prototype.compile = function(compiler) {
  throw new Error("Abstract method!");
};

PCNode.prototype._childrenCompile = function(compiler) {
  var c, _i, _len, _ref14, _results;

  _ref14 = this.children;
  _results = [];
  for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
    c = _ref14[_i];
    _results.push(c.compile(compiler));
  }
  return _results;
};

PCProgram.prototype.compile = function(compiler) {
  compiler.beginProgram();
  this._childrenCompile(compiler);
  return compiler.endProgram();
};

PCMainAgent.prototype.compile = function(compiler) {
  var i_r;

  compiler.beginMainAgent();
  i_r = new PCCConstantContainer(-1);
  compiler.getProcessFrame().addLocalVariable(new PCCVariableInfo(null, "r", null, true), i_r);
  this._childrenCompile(compiler);
  compiler.emitStop();
  return compiler.endMainAgent();
};

PCProcedureDecl.prototype.compile = function(compiler) {
  var guard, proc;

  compiler.beginProcedure(this.name);
  proc = compiler.getProcedureWithName(this.name);
  if (proc.isMonitorProcedure()) {
    guard = compiler.getVariableWithName("guard", null, true);
    compiler.emitOutput("lock", guard.getContainer(compiler));
  }
  this.getBody().compile(compiler);
  proc.emitExit(compiler);
  compiler.endProcedure();
  return [];
};

PCFormalParameter.prototype.compile = function(compiler) {
  throw new Error("Not implemented!");
};

PCMonitor.prototype.compile = function(compiler) {
  compiler.beginClass(this.name);
  this._childrenCompile(compiler);
  return compiler.endClass();
};

PCStruct.prototype.compile = function(compiler) {
  compiler.beginClass(this.name);
  this._childrenCompile(compiler);
  return compiler.endClass();
};

PCConditionDecl.prototype.compile = function(compiler) {
  var context, variable;

  context = {
    target: this,
    compiler: compiler
  };
  variable = new PCCVariableInfo(this, this.name, new PCTType(PCTType.CONDITION));
  compiler.handleNewVariableWithDefaultValueCallback(variable);
  return [];
};

PCConditionDecl.prototype.compileDefaultValue = function(compiler) {
  var result;

  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput("wait_create", null, result);
  return result;
};

PCDecl.prototype.compile = function(compiler) {
  var type, vd, _i, _len, _ref14;

  type = this.children[0];
  _ref14 = this.getDeclarators();
  for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
    vd = _ref14[_i];
    vd.compile(compiler);
  }
  return [];
};

PCVariableDeclarator.prototype.compile = function(compiler) {
  var context, variable;

  context = {
    target: this,
    compiler: compiler
  };
  variable = new PCCVariableInfo(this, this.name, this.getTypeNode().getType(compiler).type);
  return compiler.handleNewVariableWithDefaultValueCallback(variable);
};

PCVariableDeclarator.prototype.compileDefaultValue = function(compiler) {
  var type;

  type = this.getTypeNode().getType(compiler).type;
  if (this.getInitializer()) {
    return this.getInitializer().compile(compiler, type);
  } else {
    return type.createContainer(compiler);
  }
};

PCVariableInitializer.prototype.compile = function(compiler, type) {
  var c, cc;

  if (this.isArray()) {
    cc = (function() {
      var _i, _len, _ref14, _results;

      _ref14 = this.children;
      _results = [];
      for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
        c = _ref14[_i];
        _results.push(c.compile(compiler, type.elementsType));
      }
      return _results;
    }).call(this);
    return type.createContainer(compiler, cc);
  } else {
    return type.createContainer(compiler, this.children[0].compile(compiler));
  }
};

PCExpression.prototype.compile = function(compiler) {
  throw new Error("Not implemented!");
};

PCExpression.prototype.getValueForArrayAtIndex = function(compiler, instanceContainer, indexContainer) {
  var result;

  compiler.emitOutput("array_access", instanceContainer, indexContainer);
  result = compiler.getFreshContainer(instanceContainer.ccsType.getSubtype());
  compiler.emitInput("array_get", instanceContainer, result);
  return result;
};

PCStartExpression.prototype.compile = function(compiler) {
  return this.children[0].compileSend(compiler);
};

PCAssignExpression.prototype.compile = function(compiler) {
  var c;

  c = this.getExpression().compile(compiler);
  if (this.operator === "+=") {
    c = new PCCBinaryContainer(this.getDestination().compile(compiler), c, "+");
  } else if (this.operator === "*=") {
    c = new PCCBinaryContainer(this.getDestination().compile(compiler), c, "*");
  } else if (this.operator === "/=") {
    c = new PCCBinaryContainer(this.getDestination().compile(compiler), c, "/");
  } else if (this.operator !== "=") {
    throw new Error("Unknown assign operator");
  }
  this.getDestination().assignContainer(compiler, c);
  return c;
};

PCAssignDestination.prototype.compile = function(compiler) {
  var arrayIndexCount, i, res, v, _i;

  arrayIndexCount = this.children.length;
  v = compiler.getVariableWithName(this.identifier, null);
  res = v.getContainer(compiler);
  for (i = _i = 0; _i < arrayIndexCount; i = _i += 1) {
    res = this.getValueForArrayAtIndex(compiler, ai, this.children[i].compile(compiler));
  }
  return res;
};

PCAssignDestination.prototype.setValueForArrayAtIndex = function(compiler, instanceContainer, indexContainer, valueContainer) {
  compiler.emitOutput("array_access", instanceContainer, indexContainer);
  compiler.emitOutput("array_set", instanceContainer, valueContainer);
  return valueContainer;
};

PCAssignDestination.prototype.assignContainer = function(compiler, c) {
  var ai, arrayIndexCount, i, v, _i, _ref14;

  arrayIndexCount = this.children.length;
  v = compiler.getVariableWithName(this.identifier, null);
  if (arrayIndexCount === 0) {
    return v.setContainer(compiler, c);
  } else {
    ai = v.getContainer(compiler);
    for (i = _i = 0, _ref14 = arrayIndexCount - 2; _i <= _ref14; i = _i += 1) {
      ai = this.getValueForArrayAtIndex(compiler, ai, this.children[i].compile(compiler));
    }
    return this.setValueForArrayAtIndex(compiler, ai, this.children[arrayIndexCount - 1].compile(compiler), c);
  }
};

PCSendExpression.prototype.compile = function(compiler) {
  var c, control, p1, p2, v;

  c = this.children[0].compile(compiler);
  v = this.children[1].compile(compiler);
  if (this.children[0].getType(compiler).capacity <= 0) {
    control = compiler.emitChoice();
    compiler.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), ">="));
    compiler.emitOutput("put", c, v);
    p1 = compiler.emitProcessApplicationPlaceholder();
    control.setBranchFinished();
    compiler.emitCondition(new PCCBinaryContainer(c, new PCCConstantContainer(0), "<"));
    compiler.emitOutput("receive", c, v);
    p2 = compiler.emitProcessApplicationPlaceholder();
    control.setBranchFinished();
    compiler.emitMergeOfProcessFramesOfPlaceholders([p1, p2]);
  } else {
    compiler.emitOutput("put", c, v);
  }
  return v;
};

PCConditionalExpression.prototype.compile = function(compiler) {
  var b, c, control, lp, rp;

  b = this.children[0].compile(compiler);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  c = this.children[1].compile(compiler);
  compiler.protectContainer(c);
  lp = compiler.emitProcessApplicationPlaceholder();
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  c = this.children[2].compile(compiler);
  compiler.protectContainer(c);
  rp = compiler.emitProcessApplicationPlaceholder();
  compiler.emitMergeOfProcessFramesOfPlaceholders([lp, rp]);
  return compiler.unprotectContainer();
};

PCOrExpression.prototype.compile = function(compiler) {
  var left, right;

  left = this.children[0].compile(compiler);
  compiler.protectContainer(left);
  right = this.children[1].compile(compiler);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, "||");
};

PCAndExpression.prototype.compile = function(compiler) {
  var left, right;

  left = this.children[0].compile(compiler);
  compiler.protectContainer(left);
  right = this.children[1].compile(compiler);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, "&&");
};

PCEqualityExpression.prototype.compile = function(compiler) {
  var left, right;

  left = this.children[0].compile(compiler);
  compiler.protectContainer(left);
  right = this.children[1].compile(compiler);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PCRelationalExpression.prototype.compile = function(compiler) {
  var left, right;

  left = this.children[0].compile(compiler);
  compiler.protectContainer(left);
  right = this.children[1].compile(compiler);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PCAdditiveExpression.prototype.compile = function(compiler) {
  var left, right;

  left = this.children[0].compile(compiler);
  compiler.protectContainer(left);
  right = this.children[1].compile(compiler);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PCMultiplicativeExpression.prototype.compile = function(compiler) {
  var left, right;

  left = this.children[0].compile(compiler);
  compiler.protectContainer(left);
  right = this.children[1].compile(compiler);
  left = compiler.unprotectContainer();
  return new PCCBinaryContainer(left, right, this.operator);
};

PCUnaryExpression.prototype.compile = function(compiler) {
  return new PCCUnaryContainer(this.operator, this.children[0].compile(compiler));
};

PCPostfixExpression.prototype.compile = function(compiler) {
  var c, op;

  op = (function() {
    if (this.operator === "++") {
      return "+";
    } else if (this.operator === "--") {
      return "-";
    } else {
      throw new Error("Unknown postfix operator");
    }
  }).call(this);
  c = new PCCBinaryContainer(this.children[0].compile(compiler), new PCCConstantContainer(1), op);
  this.children[0].assignContainer(compiler, c);
  return c;
};

PCReceiveExpression.prototype.compile = function(compiler) {
  var c, res;

  c = this.children[0].compile(compiler);
  res = compiler.getFreshContainer(c.ccsType.getSubtype());
  compiler.emitInput("receive", c, res);
  return res;
};

PCProcedureCall.prototype.compile = function(compiler, instanceContainer, className) {
  var args, c, control, proc, res, _i, _j, _len, _len1, _ref14, _ref15;

  proc = compiler.getProcedureWithName(this.procedureName, className);
  if (instanceContainer) {
    compiler.protectContainer(instanceContainer);
  }
  _ref14 = this.children;
  for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
    c = _ref14[_i];
    compiler.protectContainer(c.compile(compiler));
  }
  control = compiler.emitSequence();
  args = [];
  _ref15 = this.children;
  for (_j = 0, _len1 = _ref15.length; _j < _len1; _j++) {
    c = _ref15[_j];
    args.unshift(compiler.unprotectContainer());
  }
  if (instanceContainer) {
    instanceContainer = compiler.unprotectContainer();
  }
  args = proc.getAllArgumentContainers(compiler, args, instanceContainer);
  compiler.emitProcessApplication(proc.getProcessName(), args);
  control.setBranchFinished();
  if (proc.returnType.kind !== PCTType.VOID) {
    res = compiler.getFreshContainer(proc.returnType.getCCSType());
    compiler.emitInput("rreturn", null, res);
    return res;
  } else {
    return null;
  }
};

PCProcedureCall.prototype.compileSend = function(compiler, instanceContainer, className) {
  var args, c, proc, result, _i, _j, _k, _len, _len1, _len2, _ref14, _ref15;

  proc = compiler.getProcedureWithName(this.procedureName, className);
  if (instanceContainer) {
    compiler.protectContainer(instanceContainer);
  }
  _ref14 = this.children;
  for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
    c = _ref14[_i];
    compiler.protectContainer(c.compile(compiler));
  }
  args = [];
  _ref15 = this.children;
  for (_j = 0, _len1 = _ref15.length; _j < _len1; _j++) {
    c = _ref15[_j];
    args.unshift(compiler.unprotectContainer());
  }
  if (instanceContainer) {
    instanceContainer = compiler.unprotectContainer();
  }
  args = proc.getAllArgumentContainers(compiler, args, instanceContainer);
  result = compiler.getFreshContainer(PCCType.INT);
  compiler.emitInput(proc.getAgentStarterChannel(), null, result);
  for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
    c = args[_k];
    compiler.emitOutput("start_set_arg", result, c);
  }
  return result;
};

PCClassCall.prototype.compile = function(compiler) {
  var className;

  className = this.children[0].getType(compiler).identifier;
  return this.children[1].compile(compiler, this.children[0].compile(compiler), className);
};

PCClassCall.prototype.compileSend = function(compiler) {
  var className;

  className = this.children[0].getType(compiler).identifier;
  return this.children[1].compileSend(compiler, this.children[0].compile(compiler), className);
};

PCArrayExpression.prototype.compile = function(compiler) {
  var a, res, t;

  a = this.children[0].compile(compiler);
  compiler.protectContainer(a);
  t = this.children[1].compile(compiler);
  a = compiler.unprotectContainer();
  compiler.emitOutput("array_access", a, t);
  res = compiler.getFreshContainer(this.children[0].getType(compiler).type);
  compiler.emitInput("array_get", a, res);
  return res;
};

PCLiteralExpression.prototype.compile = function(compiler) {
  return new PCCConstantContainer(this.value);
};

PCIdentifierExpression.prototype.compile = function(compiler) {
  var v;

  v = compiler.getVariableWithName(this.identifier, null);
  return v.getContainer(compiler);
};

PCStatement.prototype.compile = function(compiler, loopEntry) {
  return this.children[0].compile(compiler, loopEntry);
};

PCBreakStmt.prototype.compile = function(compiler, loopEntry) {
  return [compiler.emitProcessApplicationPlaceholder()];
};

PCContinueStmt.prototype.compile = function(compiler, loopEntry) {
  loopEntry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  return [];
};

PCStmtBlock.prototype.compile = function(compiler, loopEntry) {
  var c;

  return ((function() {
    var _i, _len, _ref14, _results;

    _ref14 = this.children;
    _results = [];
    for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
      c = _ref14[_i];
      _results.push(c.compile(compiler, loopEntry));
    }
    return _results;
  }).call(this)).concatChildren();
};

PCStmtExpression.prototype.compile = function(compiler, loopEntry) {
  this.children[0].compile(compiler);
  return [];
};

PCSelectStmt.prototype.compile = function(compiler, loopEntry) {
  var breaks, control, i, placeholders, _i, _ref14;

  if (this.children.length === 0) {
    return;
  }
  placeholders = [];
  breaks = [];
  for (i = _i = 0, _ref14 = this.children.length - 1; _i < _ref14; i = _i += 1) {
    control = compiler.emitChoice();
    breaks.concat(this.children[i].compile(compiler, loopEntry));
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
    control.setBranchFinished();
  }
  breaks.concat(this.children[this.children.length - 1].compile(compiler, loopEntry));
  placeholders.push(compiler.emitProcessApplicationPlaceholder());
  compiler.emitMergeOfProcessFramesOfPlaceholders(placeholders);
  debugger;
  return breaks;
};

PCCase.prototype.compile = function(compiler, loopEntry) {
  var cond;

  cond = this.getCondition();
  if (cond) {
    cond.compile(compiler);
  }
  return this.getExecution().compile(compiler, loopEntry);
};

PCIfStmt.prototype.compile = function(compiler, loopEntry) {
  var b, breaks, control, placeholders;

  placeholders = [];
  b = this.children[0].compile(compiler);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  breaks = this.children[1].compile(compiler, loopEntry);
  if (!compiler.isCurrentProcessCompleted()) {
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
  }
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  if (this.children.length === 3) {
    breaks = breaks.concat(this.children[2].compile(compiler, loopEntry));
  }
  if (!compiler.isCurrentProcessCompleted()) {
    placeholders.push(compiler.emitProcessApplicationPlaceholder());
  }
  control.setBranchFinished();
  compiler.emitMergeOfProcessFramesOfPlaceholders(placeholders);
  return breaks;
};

PCWhileStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, _i, _len;

  entry = compiler.emitNextProcessFrame();
  b = this.children[0].compile(compiler);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  breaks = this.children[1].compile(compiler, entry);
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  out = compiler.emitNextProcessFrame();
  for (_i = 0, _len = breaks.length; _i < _len; _i++) {
    b = breaks[_i];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PCDoStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, _i, _len;

  entry = compiler.emitNextProcessFrame();
  breaks = this.children[0].compile(compiler, entry);
  b = this.children[1].compile(compiler);
  control = compiler.emitChoice();
  compiler.emitCondition(b);
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  control.setBranchFinished();
  compiler.emitCondition(new PCCUnaryContainer("!", b));
  breaks.push(compiler.emitProcessApplicationPlaceholder());
  control.setBranchFinished();
  out = compiler.emitNextProcessFrame();
  for (_i = 0, _len = breaks.length; _i < _len; _i++) {
    b = breaks[_i];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PCForStmt.prototype.compile = function(compiler) {
  var b, breaks, control, entry, out, statusQuo, u, _i, _j, _len, _len1, _ref14;

  statusQuo = compiler.getProcessFrame();
  if (this.init) {
    this.init.compile(compiler);
  }
  entry = compiler.emitNextProcessFrame();
  breaks = [];
  control = null;
  if (this.expression) {
    b = this.expression.compile(compiler);
    control = compiler.emitChoice();
    compiler.emitCondition(new PCCUnaryContainer("!", b));
    breaks.push(compiler.emitProcessApplicationPlaceholder());
    control.setBranchFinished();
    compiler.emitCondition(b);
  }
  breaks = breaks.concat(this.body.compile(compiler, entry));
  _ref14 = this.update;
  for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
    u = _ref14[_i];
    u.compile(compiler);
  }
  entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
  if (control) {
    control.setBranchFinished();
  }
  out = compiler.emitNextProcessFrame();
  for (_j = 0, _len1 = breaks.length; _j < _len1; _j++) {
    b = breaks[_j];
    out.emitCallProcessFromFrame(compiler, b.frame, b);
  }
  return [];
};

PCForInit.prototype.compile = function(compiler) {
  var c, _i, _len, _ref14;

  _ref14 = this.children;
  for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
    c = _ref14[_i];
    c.compile(compiler);
  }
  return [];
};

PCReturnStmt.prototype.compile = function(compiler, loopEntry) {
  var res;

  if (this.children.length === 1) {
    res = this.children[0].compile(compiler);
    compiler.emitOutput("return", null, res);
  }
  compiler.getCurrentProcedure().emitExit(compiler);
  return [];
};

PCPrimitiveStmt.prototype.compile = function(compiler, loopEntry) {
  var b, c, cond, control, entry, g, v, vars, _i, _len;

  switch (this.kind) {
    case PCPrimitiveStmt.JOIN:
      c = this.children[0].compile(compiler, loopEntry);
      compiler.emitOutput("join_register", c, null);
      compiler.emitOutput("join", c, null);
      break;
    case PCPrimitiveStmt.LOCK:
      c = this.children[0].compile(compiler, loopEntry);
      compiler.emitOutput("lock", c, null);
      break;
    case PCPrimitiveStmt.UNLOCK:
      c = this.children[0].compile(compiler, loopEntry);
      compiler.emitOutput("unlock", c, null);
      break;
    case PCPrimitiveStmt.WAIT:
      if (!(this.children[0] instanceof PCIdentifierExpression)) {
        throw new Error("Unexpected expression!");
      }
      cond = compiler.getVariableWithName(this.children[0].identifier);
      entry = compiler.emitNextProcessFrame();
      b = cond.node.getExpression().compile(compiler);
      control = compiler.emitChoice();
      compiler.emitCondition(new PCCUnaryContainer("!", b));
      c = cond.getContainer(compiler);
      compiler.emitOutput("add", c, null);
      g = compiler.getVariableWithName("guard", null, true).getContainer(compiler);
      compiler.emitOutput("unlock", g, null);
      compiler.emitOutput("wait", c, null);
      compiler.emitOutput("lock", g, null);
      entry.emitCallProcessFromFrame(compiler, compiler.getProcessFrame());
      control.setBranchFinished();
      compiler.emitCondition(b);
      break;
    case PCPrimitiveStmt.SIGNAL:
      c = this.children[0].compile(compiler, loopEntry);
      compiler.emitOutput("signal", c, null);
      break;
    case PCPrimitiveStmt.SIGNAL_ALL:
      c = this.children.length > 0 ? this.children[0].compile(compiler, loopEntry) : null;
      vars = [];
      if (c) {
        if (!(this.children[0] instanceof PCIdentifierExpression)) {
          throw new Error("Unexpected expression!");
        }
        vars = [compiler.getVariableWithName(this.children[0].identifier)];
      } else {
        vars = compiler.getCurrentClass().getAllConditions();
      }
      for (_i = 0, _len = vars.length; _i < _len; _i++) {
        v = vars[_i];
        c = v.getContainer(compiler);
        compiler.emitOutput("signalAll", c, null);
      }
  }
  return [];
};

PCPrintStmt.prototype.compile = function(compiler, loopEntry) {
  var i, out, _i, _ref14;

  if (this.children.length === 0) {
    return;
  }
  out = this.children[0].compile(compiler);
  for (i = _i = 1, _ref14 = this.children.length; _i < _ref14; i = _i += 1) {
    out = new PCCBinaryContainer(out, this.children[i].compile(compiler), "+");
  }
  compiler.emitOutput("println", null, out);
  return [];
};
