// Generated by CoffeeScript 1.7.1
/* ###
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
### */;

/*

	The following classes represent the PseuCo tree. Its implementation is partly incomplete.
	Method _getType is not implemented everywhere and does not perform type checking anywhere at the moment!
	
	toString returns the string representation of the tree with minimal brackets and correctly indented.
 */
var PCAdditiveExpression, PCAndExpression, PCArrayExpression, PCArrayType, PCAssignDestination, PCAssignExpression, PCBaseType, PCBreakStmt, PCCase, PCChannelType, PCClassCall, PCClassType, PCConditionDecl, PCConditionalExpression, PCContinueStmt, PCDecl, PCDeclStmt, PCDoStmt, PCEqualityExpression, PCExpression, PCForInit, PCForStmt, PCFormalParameter, PCIdentifierExpression, PCIfStmt, PCIndent, PCLiteralExpression, PCMainAgent, PCMonitor, PCMultiplicativeExpression, PCNode, PCOrExpression, PCPostfixExpression, PCPrimitiveStmt, PCPrintStmt, PCProcedureCall, PCProcedureDecl, PCProgram, PCReceiveExpression, PCRelationalExpression, PCReturnStmt, PCSelectStmt, PCSendExpression, PCSimpleType, PCStartExpression, PCStatement, PCStmtBlock, PCStmtExpression, PCStruct, PCTArrayType, PCTChannelType, PCTClass, PCTClassType, PCTCycleChecker, PCTEnvironmentController, PCTEnvironmentNode, PCTProcedure, PCTProcedureType, PCTTrace, PCTType, PCTTypeType, PCTVariable, PCUnaryExpression, PCVariableDeclarator, PCVariableInitializer, PCWhileStmt,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PCIndent = "   ";

PCNode = (function() {
  function PCNode() {
    var c, children, column, line, _i, _len, _ref;
    line = arguments[0], column = arguments[1], children = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    this.line = line;
    this.column = column;
    this.children = children;
    this.parent = null;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.parent = this;
    }
  }

  PCNode.prototype.getType = function(env) {
    if (!this._type) {
      this._type = this._getType(env);
      if (!this._type) {
        this._type = true;
      }
    }
    if (this._type === true) {
      return null;
    } else {
      return this._type;
    }
  };

  PCNode.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCNode.prototype._getType = function() {
    throw new Error("Not implemented");
  };

  PCNode.prototype.insideMonitor = function() {
    if (this.parent) {
      return this.parent.insideMonitor();
    } else {
      return false;
    }
  };

  PCNode.prototype.insideProcedure = function() {
    if (this.parent) {
      return this.parent.insideProcedure();
    } else {
      return false;
    }
  };

  PCNode.prototype.usesSendOrReceiveOperator = function() {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.usesSendOrReceiveOperator()) {
        return true;
      }
    }
    return false;
  };

  return PCNode;

})();

PCProgram = (function(_super) {
  __extends(PCProgram, _super);

  function PCProgram() {
    return PCProgram.__super__.constructor.apply(this, arguments);
  }

  PCProgram.prototype.collectClasses = function(env) {
    var c, _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.collectClasses(env));
    }
    return _results;
  };

  PCProgram.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.collectEnvironment(env));
    }
    return _results;
  };

  PCProgram.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child._collectEnvironment(env));
    }
    return _results;
  };

  PCProgram.prototype.toString = function() {
    var o;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(""));
      }
      return _results;
    }).call(this)).join("\n");
  };

  PCProgram.prototype._getType = function() {
    var cycleChecker, declaration, env, trace, _i, _len, _ref;
    env = new PCTEnvironmentController();
    this.collectClasses(env);
    this._collectEnvironment(env);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      declaration = _ref[_i];
      declaration.getType(env);
    }
    try {
      env.getProcedureWithName("#mainAgent");
    } catch (_error) {
      throw new Error("You must define a main agent!");
    }
    cycleChecker = new PCTCycleChecker(env.getAllClasses());
    trace = cycleChecker.cycleTraceForTypes();
    if (trace) {
      throw new Error("Monitor/structure cycle detected: " + trace + "!");
    }
    return null;
  };

  return PCProgram;

})(PCNode);

PCMainAgent = (function(_super) {
  __extends(PCMainAgent, _super);

  function PCMainAgent() {
    return PCMainAgent.__super__.constructor.apply(this, arguments);
  }

  PCMainAgent.prototype.collectClasses = function(env) {
    return null;
  };

  PCMainAgent.prototype.collectEnvironment = function(env) {
    env.beginMainAgent(this);
    this.children[0].collectEnvironment(env);
    return env.endMainAgent();
  };

  PCMainAgent.prototype._collectEnvironment = function(env) {
    env._beginMainAgent(this);
    this.children[0]._collectEnvironment(env);
    return env.endMainAgent();
  };

  PCMainAgent.prototype.toString = function() {
    return "mainAgent " + this.children[0].toString("");
  };

  PCMainAgent.prototype._getType = function(env) {
    env.beginProcedure("#mainAgent");
    this.children[0].getType(env);
    env.endProcedure();
    return new PCTType(PCTType.MAINAGENT);
  };

  PCMainAgent.prototype.insideProcedure = function() {
    return true;
  };

  return PCMainAgent;

})(PCNode);

PCProcedureDecl = (function(_super) {
  __extends(PCProcedureDecl, _super);

  function PCProcedureDecl() {
    var body, column, line, name, parameters, resultType;
    line = arguments[0], column = arguments[1], resultType = arguments[2], name = arguments[3], body = arguments[4], parameters = 6 <= arguments.length ? __slice.call(arguments, 5) : [];
    this.name = name;
    parameters.unshift(line, column, resultType, body);
    PCProcedureDecl.__super__.constructor.apply(this, parameters);
  }

  PCProcedureDecl.prototype.getResultType = function() {
    return this.children[0];
  };

  PCProcedureDecl.prototype.getBody = function() {
    return this.children[1];
  };

  PCProcedureDecl.prototype.getArgumentCount = function() {
    return this.children.length - 2;
  };

  PCProcedureDecl.prototype.getArgumentAtIndex = function(index) {
    return this.children[index + 2];
  };

  PCProcedureDecl.prototype.collectClasses = function(env) {
    return null;
  };

  PCProcedureDecl.prototype.collectEnvironment = function(env) {
    var args, p;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = this.children.slice(2, this.children.length);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i += 1) {
        p = _ref[_i];
        _results.push(p.getVariable(env));
      }
      return _results;
    }).call(this);
    env.beginNewProcedure(this, this.name, this.getResultType().getType(env).type, args);
    this.getBody().collectEnvironment(env);
    return env.endProcedure();
  };

  PCProcedureDecl.prototype._collectEnvironment = function(env) {
    var args, parameter;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = this.children.slice(2);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        parameter = _ref[_i];
        _results.push(parameter.getVariable(env));
      }
      return _results;
    }).call(this);
    env.beginNewProcedure(this, this.name, this.getResultType().getType(env).type, args);
    this.getBody()._collectEnvironment(env);
    return env.endProcedure();
  };

  PCProcedureDecl.prototype.toString = function(indent) {
    var i;
    return "" + indent + (this.getResultType().toString()) + " " + this.name + "(" + (((function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.getArgumentCount(); _i < _ref; i = _i += 1) {
        _results.push(this.getArgumentAtIndex(i).toString());
      }
      return _results;
    }).call(this)).join(", ")) + ") " + (this.getBody().toString(indent));
  };

  PCProcedureDecl.prototype._getType = function(env) {
    var child, proc, _i, _len, _ref;
    proc = env.beginProcedure(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
    }
    if (this.getBody().isReturnExhaustive) {
      env.setReturnExhaustive();
    }
    if (!(this.getResultType().type === PCSimpleType.VOID)) {
      if (!env.isReturnExhaustive()) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "In your procedure it might be possible that for some conditions no value gets returned."
        };
      }
    }
    env.endProcedure();
    return proc;
  };

  PCProcedureDecl.prototype.insideProcedure = function() {
    return true;
  };

  return PCProcedureDecl;

})(PCNode);

PCFormalParameter = (function(_super) {
  __extends(PCFormalParameter, _super);

  function PCFormalParameter(line, column, type, identifier) {
    this.identifier = identifier;
    PCFormalParameter.__super__.constructor.call(this, line, column, type);
  }

  PCFormalParameter.prototype.getVariable = function(env) {
    return new PCTVariable(this, this.identifier, this.children[0].getType(env).type);
  };

  PCFormalParameter.prototype.toString = function() {
    return this.children[0].toString() + " " + this.identifier;
  };

  PCFormalParameter.prototype._getType = function(env) {
    return null;
  };

  return PCFormalParameter;

})(PCNode);

PCMonitor = (function(_super) {
  __extends(PCMonitor, _super);

  function PCMonitor() {
    var declarations, name;
    name = arguments[0], declarations = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.name = name;
    PCMonitor.__super__.constructor.apply(this, declarations);
  }

  PCMonitor.prototype.collectClasses = function(env) {
    return env.processNewClass(this, new PCTClassType(true, this.name));
  };

  PCMonitor.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref;
    env.beginClass(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.collectEnvironment(env);
    }
    return env.endClass();
  };

  PCMonitor.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.beginClass(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.endClass();
  };

  PCMonitor.prototype.toString = function() {
    var o;
    return "monitor " + this.name + " {\n" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n}";
  };

  PCMonitor.prototype._getType = function(env) {
    var child, monitor, variable, _i, _j, _len, _len1, _ref, _ref1;
    env.beginClass(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
    }
    env.endClass();
    monitor = env.getClassWithName(this.name);
    _ref1 = monitor.children;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      variable = _ref1[_j];
      if (variable.type instanceof PCTClassType) {
        monitor.addUseOfClassType(env.getClassWithName(variable.type.identifier));
      }
    }
    return new PCTType(PCTType.VOID);
  };

  PCMonitor.prototype.insideMonitor = function() {
    return true;
  };

  return PCMonitor;

})(PCNode);

PCStruct = (function(_super) {
  __extends(PCStruct, _super);

  function PCStruct() {
    var declarations, name;
    name = arguments[0], declarations = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.name = name;
    PCStruct.__super__.constructor.apply(this, declarations);
  }

  PCStruct.prototype.collectClasses = function(env) {
    return env.processNewClass(this, new PCTClassType(false, this.name));
  };

  PCStruct.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref;
    env.beginClass(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.collectEnvironment(env);
    }
    return env.endClass();
  };

  PCStruct.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.beginClass(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.endClass();
  };

  PCStruct.prototype.toString = function() {
    var o;
    return "struct " + this.name + " {\n" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n}";
  };

  PCStruct.prototype._getType = function(env) {
    var child, struct, variable, _i, _j, _len, _len1, _ref, _ref1;
    env.beginClass(this.name);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
    }
    env.endClass();
    struct = env.getClassWithName(this.name);
    _ref1 = struct.children;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      variable = _ref1[_j];
      if (variable.type instanceof PCTClassType) {
        struct.addUseOfClassType(env.getClassWithName(variable.type.identifier));
      }
    }
    return new PCTType(PCTType.VOID);
  };

  return PCStruct;

})(PCNode);

PCConditionDecl = (function(_super) {
  __extends(PCConditionDecl, _super);

  function PCConditionDecl(line, column, name, expression) {
    this.name = name;
    PCConditionDecl.__super__.constructor.call(this, line, column, expression);
  }

  PCConditionDecl.prototype.getExpression = function() {
    return this.children[0];
  };

  PCConditionDecl.prototype.collectEnvironment = function(env) {
    return env.processNewVariable(new PCTVariable(this, this.name, new PCTType(PCTType.CONDITION)));
  };

  PCConditionDecl.prototype._collectEnvironment = function(env) {
    return this.collectEnvironment(env);
  };

  PCConditionDecl.prototype.toString = function(indent) {
    return "" + indent + "condition " + this.name + " with " + (this.children[0].toString()) + ";";
  };

  PCConditionDecl.prototype._getType = function(env) {
    var type;
    type = this.children[0].getType(env);
    if (!this.insideMonitor()) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Conditions can only be declared inside monitors!"
      };
    }
    if (!type.isEqual(new PCTType(PCTType.BOOL))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Expressions assigned to condition must be boolean, not " + type
      };
    }
    env._processNewVariable(new PCTVariable(this, this.name, new PCTType(PCTType.CONDITION)));
    return null;
  };

  return PCConditionDecl;

})(PCNode);

PCDecl = (function(_super) {
  __extends(PCDecl, _super);

  function PCDecl() {
    var children, isStatement;
    isStatement = arguments[0], children = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.isStatement = isStatement;
    PCDecl.__super__.constructor.apply(this, children);
  }

  PCDecl.prototype.getDeclarators = function() {
    return this.children.slice(1);
  };

  PCDecl.prototype.collectClasses = function(env) {
    return null;
  };

  PCDecl.prototype.collectEnvironment = function(env) {
    var i, _i, _ref, _results;
    this.type = this.children[0].getType(env).type;
    _results = [];
    for (i = _i = 1, _ref = this.children.length; _i < _ref; i = _i += 1) {
      _results.push(this.children[i].collectEnvironment(env, this.type));
    }
    return _results;
  };

  PCDecl.prototype._collectEnvironment = function(env) {
    return this.collectEnvironment(env);
  };

  PCDecl.prototype.toString = function(indent) {
    var res;
    res = indent + this.children[0].toString() + " " + this.children[1].toString();
    if (this.isStatement) {
      res += ";";
    }
    return res;
  };

  PCDecl.prototype._getType = function(env) {
    var child, type, _i, _len, _ref;
    _ref = this.children.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      type = child._getType(env, this.type);
      if ((type != null) && !this.type.isEqual(type)) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "You can't initialize variable of type " + this.type + " with value of type " + type
        };
      }
    }
    return null;
  };

  return PCDecl;

})(PCNode);

PCDeclStmt = (function(_super) {
  __extends(PCDeclStmt, _super);

  function PCDeclStmt() {
    var children;
    children = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    PCDeclStmt.__super__.constructor.apply(this, [true].concat(__slice.call(children)));
  }

  return PCDeclStmt;

})(PCDecl);

PCVariableDeclarator = (function(_super) {
  __extends(PCVariableDeclarator, _super);

  function PCVariableDeclarator(line, column, name, initializer) {
    this.name = name;
    if (initializer) {
      PCVariableDeclarator.__super__.constructor.call(this, line, column, initializer);
    } else {
      PCVariableDeclarator.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
    }
  }

  PCVariableDeclarator.prototype.getInitializer = function() {
    if (this.children.length > 0) {
      return this.children[0];
    } else {
      return null;
    }
  };

  PCVariableDeclarator.prototype.getTypeNode = function() {
    return this.parent.getType();
  };

  PCVariableDeclarator.prototype.collectEnvironment = function(env, type) {
    return env.processNewVariable(new PCTVariable(this, this.name, type));
  };

  PCVariableDeclarator.prototype.toString = function() {
    var res;
    res = this.name;
    if (this.children.length > 0) {
      res += " = " + (this.children[0].toString());
    }
    return res;
  };

  PCVariableDeclarator.prototype._getType = function(env, targetType) {
    if (this.children.length > 0) {
      return this.children[0]._getType(env, targetType);
    } else {
      return null;
    }
  };

  return PCVariableDeclarator;

})(PCNode);

PCVariableInitializer = (function(_super) {
  __extends(PCVariableInitializer, _super);

  function PCVariableInitializer() {
    var children, column, isUncompletedArray, line;
    line = arguments[0], column = arguments[1], isUncompletedArray = arguments[2], children = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    this.isUncompletedArray = isUncompletedArray != null ? isUncompletedArray : false;
    PCVariableInitializer.__super__.constructor.apply(this, [line, column].concat(__slice.call(children)));
  }

  PCVariableInitializer.prototype.isArray = function() {
    return !(this.children[0] instanceof PCExpression);
  };

  PCVariableInitializer.prototype.getTypeNode = function() {
    return this.parent.getTypeNode();
  };

  PCVariableInitializer.prototype.toString = function() {
    var o;
    if (this.children[0] instanceof PCExpression) {
      return "" + (this.children[0].toString());
    } else {
      return "{" + (((function() {
        var _i, _len, _ref, _results;
        _ref = this.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          o = _ref[_i];
          _results.push(o.toString());
        }
        return _results;
      }).call(this)).join(", ")) + (this.isUncompletedArray ? "," : "") + "}";
    }
  };

  PCVariableInitializer.prototype._getType = function(env, targetType) {
    var child, childType, type, _i, _len, _ref;
    if (this.children.length === 0) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Empty array initializations aren't allowed!"
      };
      type = targetType;
    } else {
      if (this.isArray()) {
        type = this.children[0]._getType(env, targetType.elementsType);
        _ref = this.children.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          childType = child._getType(env, targetType.elementsType);
          if (!type.isEqual(childType)) {
            throw {
              "line": this.line,
              "column": this.column,
              "message": "Types of elements of an array must be equal! Found " + type + " and " + childType
            };
          }
        }
        if (this.isUncompletedArray) {
          type = new PCTArrayType(type, targetType.capacity);
        } else {
          type = new PCTArrayType(type, this.children.length);
        }
      } else {
        type = this.children[0].getType(env);
      }
    }
    return type;
  };

  return PCVariableInitializer;

})(PCNode);

PCArrayType = (function(_super) {
  __extends(PCArrayType, _super);

  function PCArrayType(line, column, baseType, size) {
    this.size = size;
    PCArrayType.__super__.constructor.call(this, line, column, baseType);
  }

  PCArrayType.prototype._getType = function(env) {
    return new PCTTypeType(new PCTArrayType(this.children[0].getType(env).type, this.size));
  };

  PCArrayType.prototype.toString = function() {
    var end, front, pos;
    front = "" + this.children[0];
    pos = front.indexOf("[");
    if (pos === -1) {
      return "" + front + "[" + this.size + "]";
    } else {
      end = front.substring(pos);
      front = front.slice(0, pos);
      return "" + front + "[" + this.size + "]" + end;
    }
  };

  return PCArrayType;

})(PCNode);

PCBaseType = (function(_super) {
  __extends(PCBaseType, _super);

  function PCBaseType(line, column) {
    PCBaseType.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  return PCBaseType;

})(PCNode);

PCSimpleType = (function(_super) {
  __extends(PCSimpleType, _super);

  function PCSimpleType(line, column, type) {
    this.type = type;
    if (this.type < 0 || this.type > 5) {
      throw "Unknown type";
    }
    PCSimpleType.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCSimpleType.prototype._getType = function() {
    return new PCTTypeType(new PCTType(PCSimpleType.typeToTypeKind(this.type)));
  };

  PCSimpleType.prototype.toString = function() {
    return PCSimpleType.typeToString(this.type);
  };

  return PCSimpleType;

})(PCBaseType);

PCSimpleType.VOID = 0;

PCSimpleType.BOOL = 1;

PCSimpleType.INT = 2;

PCSimpleType.STRING = 3;

PCSimpleType.MUTEX = 4;

PCSimpleType.AGENT = 5;

PCSimpleType.typeToString = function(type) {
  switch (type) {
    case PCSimpleType.VOID:
      return "void";
    case PCSimpleType.BOOL:
      return "bool";
    case PCSimpleType.INT:
      return "int";
    case PCSimpleType.STRING:
      return "string";
    case PCSimpleType.MUTEX:
      return "mutex";
    case PCSimpleType.AGENT:
      return "agent";
    default:
      throw new Error("Unknown type!");
  }
};

PCSimpleType.typeToTypeKind = function(type) {
  switch (type) {
    case PCSimpleType.MUTEX:
      return PCTType.MUTEX;
    case PCSimpleType.AGENT:
      return PCTType.AGENT;
    case PCSimpleType.VOID:
      return PCTType.VOID;
    case PCSimpleType.BOOL:
      return PCTType.BOOL;
    case PCSimpleType.INT:
      return PCTType.INT;
    case PCSimpleType.STRING:
      return PCTType.STRING;
    default:
      throw new Error("Unknown type!");
  }
};

PCChannelType = (function(_super) {
  __extends(PCChannelType, _super);

  function PCChannelType(line, column, valueType, capacity) {
    this.valueType = valueType;
    this.capacity = capacity;
    PCChannelType.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCChannelType.prototype._getType = function() {
    return new PCTTypeType(new PCTChannelType(new PCTType(PCSimpleType.typeToTypeKind(this.valueType)), this.capacity));
  };

  PCChannelType.prototype.toString = function() {
    return "" + (PCSimpleType.typeToString(this.valueType)) + "chan" + (this.capacity !== PCChannelType.CAPACITY_UNKNOWN ? this.capacity : "");
  };

  return PCChannelType;

})(PCNode);

PCChannelType.CAPACITY_UNKNOWN = -1;

PCClassType = (function(_super) {
  __extends(PCClassType, _super);

  function PCClassType(line, column, className) {
    this.className = className;
    PCClassType.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCClassType.prototype._getType = function(env) {
    return new PCTTypeType(env.getClassWithName(this.className).type);
  };

  PCClassType.prototype.toString = function() {
    return this.className;
  };

  return PCClassType;

})(PCBaseType);

PCExpression = (function(_super) {
  __extends(PCExpression, _super);

  function PCExpression() {
    return PCExpression.__super__.constructor.apply(this, arguments);
  }

  PCExpression.prototype.childToString = function(i, diff) {
    var res;
    if (i == null) {
      i = 0;
    }
    if (diff == null) {
      diff = 0;
    }
    res = this.children[i].toString();
    if (this.getPrecedence() + diff > this.children[i].getPrecedence()) {
      res = "(" + res + ")";
    }
    return res;
  };

  return PCExpression;

})(PCNode);

PCStartExpression = (function(_super) {
  __extends(PCStartExpression, _super);

  function PCStartExpression() {
    return PCStartExpression.__super__.constructor.apply(this, arguments);
  }

  PCStartExpression.prototype.getPrecedence = function() {
    return 42;
  };

  PCStartExpression.prototype.toString = function() {
    return "start " + (this.childToString(0));
  };

  PCStartExpression.prototype._getType = function(env) {
    if (!this.insideProcedure()) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Start primitives are only allowed in procedures!"
      };
    }
    this.children[0].getType(env);
    return new PCTType(PCTType.AGENT);
  };

  return PCStartExpression;

})(PCExpression);

PCAssignExpression = (function(_super) {
  __extends(PCAssignExpression, _super);

  function PCAssignExpression(line, column, destination, operator, expression) {
    this.operator = operator;
    PCAssignExpression.__super__.constructor.call(this, line, column, destination, expression);
  }

  PCAssignExpression.prototype.getDestination = function() {
    return this.children[0];
  };

  PCAssignExpression.prototype.getExpression = function() {
    return this.children[1];
  };

  PCAssignExpression.prototype.getPrecedence = function() {
    return 39;
  };

  PCAssignExpression.prototype.toString = function() {
    return "" + (this.getDestination().toString()) + " " + this.operator + " " + (this.childToString(1));
  };

  PCAssignExpression.prototype._getType = function(env) {
    var dest, err, exp;
    dest = this.children[0].getType(env);
    exp = this.children[1].getType(env);
    err = {
      "line": this.line,
      "column": this.column,
      "message": "You tried to assign " + exp + " to " + dest
    };
    if (this.operator === "+=") {
      if (exp.isEqual(new PCTType(PCTType.STRING))) {
        if (!dest.isEqual(new PCTType(PCTType.STRING))) {
          throw err;
        }
      } else if (exp.isEqaul(new PCTType(PCTType.INT))) {
        if (!dest.isEqual(new PCTType(PCTType.INT)) && !dest.isEqual(new PCTType(PCTType.STRING))) {
          throw err;
        }
      } else {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Operator '+=' is only allowed with integers and strings, but not " + exp
        };
      }
      return dest;
    } else if (this.operator === !"=") {
      if (!dest.isEqual(new PCTType(PCTType.INT))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Operator '" + op + "' is only allowed with integers, but not " + dest
        };
      }
    }
    if (!exp.isAssignableTo(dest)) {
      throw err;
    }
    return dest;
  };

  return PCAssignExpression;

})(PCExpression);

PCAssignDestination = (function(_super) {
  __extends(PCAssignDestination, _super);

  function PCAssignDestination() {
    var arrayIndexExpressions, identifier;
    identifier = arguments[0], arrayIndexExpressions = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.identifier = identifier;
    PCAssignDestination.__super__.constructor.apply(this, arrayIndexExpressions);
  }

  PCAssignDestination.prototype.toString = function() {
    var o;
    return "" + this.identifier + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children.slice(0).reverse();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push("[" + (o.toString()) + "]");
      }
      return _results;
    }).call(this)).join(""));
  };

  PCAssignDestination.prototype._getType = function(env) {
    var child, childType, type, _i, _len, _ref;
    type = env.getVariableWithName(this.identifier, this.line, this.column).type;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      childType = child.getType(env);
      if (!(type instanceof PCTArrayType)) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "You use array access on a non-array: " + type
        };
      }
      if (!childType.isEqual(new PCTType(PCTType.INT))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Array index must be an integer value, not " + childType
        };
      }
      type = type.elementsType;
    }
    return type;
  };

  return PCAssignDestination;

})(PCNode);

PCSendExpression = (function(_super) {
  __extends(PCSendExpression, _super);

  function PCSendExpression() {
    return PCSendExpression.__super__.constructor.apply(this, arguments);
  }

  PCSendExpression.prototype.getPrecedence = function() {
    return 39;
  };

  PCSendExpression.prototype.toString = function() {
    return "" + (this.childToString(0, 1)) + " <! " + (this.childToString(1));
  };

  PCSendExpression.prototype._getType = function(env) {
    var left, right;
    left = this.children[0].getType(env);
    right = this.children[1].getType(env);
    if (!left instanceof PCTChannelType) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Channel expected but found " + left
      };
    }
    if (!left.channeledType.isEqual(right)) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Values of type " + right + " can't be sent over channels for " + left.channeledType
      };
    }
    return right;
  };

  PCSendExpression.prototype.usesSendOrReceiveOperator = function() {
    return true;
  };

  return PCSendExpression;

})(PCExpression);

PCConditionalExpression = (function(_super) {
  __extends(PCConditionalExpression, _super);

  function PCConditionalExpression() {
    return PCConditionalExpression.__super__.constructor.apply(this, arguments);
  }

  PCConditionalExpression.prototype.getPrecedence = function() {
    return 45;
  };

  PCConditionalExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " ? " + (this.children[1].toString()) + " : " + (this.children[2].toString());
  };

  PCConditionalExpression.prototype._getType = function(env) {
    if (!this.children[0].getType(env).isEqual(new PCTType(PCTType.BOOL))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Value of type bool expected instead of " + (this.children[0].getType(env)) + " in conditional expression!"
      };
    }
    if (!this.children[1].getType(env).isEqual(this.children[2].getType(env))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Type of consequence and alternative must be the same! You have " + (this.children[1].getType(env)) + " and " + (this.children[2].getType(env)) + " instead."
      };
    }
    return this.children[1].getType(env);
  };

  return PCConditionalExpression;

})(PCExpression);

PCOrExpression = (function(_super) {
  __extends(PCOrExpression, _super);

  function PCOrExpression() {
    return PCOrExpression.__super__.constructor.apply(this, arguments);
  }

  PCOrExpression.prototype.getPrecedence = function() {
    return 48;
  };

  PCOrExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " || " + (this.childToString(1, 1));
  };

  PCOrExpression.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (!child.getType(env).isEqual(new PCTType(PCTType.BOOL))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Value of type bool expected instead of " + (child.getType(env)) + " in 'or' expression!"
        };
      }
    }
    return new PCTType(PCTType.BOOL);
  };

  return PCOrExpression;

})(PCExpression);

PCAndExpression = (function(_super) {
  __extends(PCAndExpression, _super);

  function PCAndExpression() {
    return PCAndExpression.__super__.constructor.apply(this, arguments);
  }

  PCAndExpression.prototype.getPrecedence = function() {
    return 51;
  };

  PCAndExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " && " + (this.childToString(1, 1));
  };

  PCAndExpression.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (!child.getType(env).isEqual(new PCTType(PCTType.BOOL))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Value of type bool expected instead of " + (child.getType(env)) + " in 'and' expression!"
        };
      }
    }
    return new PCTType(PCTType.BOOL);
  };

  return PCAndExpression;

})(PCExpression);

PCEqualityExpression = (function(_super) {
  __extends(PCEqualityExpression, _super);

  function PCEqualityExpression(line, column, left, operator, right) {
    this.operator = operator;
    PCEqualityExpression.__super__.constructor.call(this, line, column, left, right);
  }

  PCEqualityExpression.prototype.getPrecedence = function() {
    return 54;
  };

  PCEqualityExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  PCEqualityExpression.prototype._getType = function(env) {
    if (!this.children[0].getType(env).isEqual(this.children[1].getType(env))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Types in equality expression must be the same! You have " + (this.children[0].getType(env)) + " and " + (this.children[1].getType(env)) + " instead."
      };
    }
    return new PCTType(PCTType.BOOL);
  };

  return PCEqualityExpression;

})(PCExpression);

PCRelationalExpression = (function(_super) {
  __extends(PCRelationalExpression, _super);

  function PCRelationalExpression(line, column, left, operator, right) {
    this.operator = operator;
    PCRelationalExpression.__super__.constructor.call(this, line, column, left, right);
  }

  PCRelationalExpression.prototype.getPrecedence = function(env) {
    return 57;
  };

  PCRelationalExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  PCRelationalExpression.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (!child.getType(env).isEqual(new PCTType(PCTType.INT))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Value of type int expected instead of " + (child.getType(env)) + " in relational expression!"
        };
      }
    }
    return new PCTType(PCTType.BOOL);
  };

  return PCRelationalExpression;

})(PCExpression);

PCAdditiveExpression = (function(_super) {
  __extends(PCAdditiveExpression, _super);

  function PCAdditiveExpression(line, column, left, operator, right) {
    this.operator = operator;
    PCAdditiveExpression.__super__.constructor.call(this, line, column, left, right);
  }

  PCAdditiveExpression.prototype.getPrecedence = function() {
    return 60;
  };

  PCAdditiveExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  PCAdditiveExpression.prototype._getType = function(env) {
    var child, isString, _i, _len, _ref;
    isString = false;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (!child.getType(env).isEqual(new PCTType(PCTType.INT))) {
        if (child.getType(env).isEqual(new PCTType(PCTType.STRING))) {
          isString = true;
        } else {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "Illegal type in additive expression " + (child.getType(env)) + "!"
          };
        }
      }
    }
    if (isString) {
      return new PCTType(PCTType.STRING);
    } else {
      return new PCTType(PCTType.INT);
    }
  };

  return PCAdditiveExpression;

})(PCExpression);

PCMultiplicativeExpression = (function(_super) {
  __extends(PCMultiplicativeExpression, _super);

  function PCMultiplicativeExpression(line, column, left, operator, right) {
    this.operator = operator;
    PCMultiplicativeExpression.__super__.constructor.call(this, line, column, left, right);
  }

  PCMultiplicativeExpression.prototype.getPrecedence = function() {
    return 63;
  };

  PCMultiplicativeExpression.prototype.toString = function() {
    return "" + (this.childToString(0)) + " " + this.operator + " " + (this.childToString(1, 1));
  };

  PCMultiplicativeExpression.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (!child.getType(env).isEqual(new PCTType(PCTType.INT))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Value of type int expected instead of " + (child.getType(env)) + " in multiplicative expression!"
        };
      }
    }
    return new PCTType(PCTType.INT);
  };

  return PCMultiplicativeExpression;

})(PCExpression);

PCUnaryExpression = (function(_super) {
  __extends(PCUnaryExpression, _super);

  function PCUnaryExpression(line, column, operator, expression) {
    this.operator = operator;
    PCUnaryExpression.__super__.constructor.call(this, line, column, expression);
  }

  PCUnaryExpression.prototype.getPrecedence = function() {
    return 66;
  };

  PCUnaryExpression.prototype.toString = function() {
    return "" + this.operator + (this.childToString(0));
  };

  PCUnaryExpression.prototype._getType = function(env) {
    var type;
    type = this.children[0].getType(env);
    if (this.operator === "+" || this.operator === "-") {
      if (!type.isEqual(new PCTType(PCTType.INT))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Operators '+' and '-' can only be used with integers, not with " + type + "!"
        };
      }
    } else if (this.operator === "!") {
      if (!type.isEqual(new PCTType(PCTType.BOOL))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Operator '!' can only be used with booleans, not with " + type + "!"
        };
      }
    }
    return type;
  };

  return PCUnaryExpression;

})(PCExpression);

PCPostfixExpression = (function(_super) {
  __extends(PCPostfixExpression, _super);

  function PCPostfixExpression(line, column, assignDestination, operator) {
    this.operator = operator;
    PCPostfixExpression.__super__.constructor.call(this, line, column, assignDestination);
  }

  PCPostfixExpression.prototype.getPrecedence = function() {
    return 69;
  };

  PCPostfixExpression.prototype.toString = function() {
    return "" + (this.children[0].toString()) + this.operator;
  };

  PCPostfixExpression.prototype._getType = function(env) {
    if (!this.children[0].getType(env).isEqual(new PCTType(PCTType.INT))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Increment and decrement can only be used with integers, not with " + (this.children[0].getType(env)) + "!"
      };
    }
    return new PCTType(PCTType.INT);
  };

  return PCPostfixExpression;

})(PCExpression);

PCReceiveExpression = (function(_super) {
  __extends(PCReceiveExpression, _super);

  function PCReceiveExpression() {
    return PCReceiveExpression.__super__.constructor.apply(this, arguments);
  }

  PCReceiveExpression.prototype.getPrecedence = function() {
    return 72;
  };

  PCReceiveExpression.prototype.toString = function() {
    return "<? " + (this.childToString(0));
  };

  PCReceiveExpression.prototype._getType = function(env) {
    return this.children[0].getType(env).chanelledType;
  };

  PCReceiveExpression.prototype.usesSendOrReceiveOperator = function() {
    return true;
  };

  return PCReceiveExpression;

})(PCExpression);

PCProcedureCall = (function(_super) {
  __extends(PCProcedureCall, _super);

  function PCProcedureCall() {
    var args, procedureName;
    procedureName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.procedureName = procedureName;
    PCProcedureCall.__super__.constructor.apply(this, args);
  }

  PCProcedureCall.prototype.getProcedure = function(env, className) {
    return (className ? env.getClassWithName(className) : env).getProcedureWithName(this.procedureName, this.line, this.column);
  };

  PCProcedureCall.prototype.getType = function(env, className) {
    if (!className) {
      return PCProcedureCall.__super__.getType.apply(this, arguments);
    } else {
      return this._getType(env, className);
    }
  };

  PCProcedureCall.prototype.getPrecedence = function() {
    return 75;
  };

  PCProcedureCall.prototype.toString = function() {
    var o;
    return "" + this.procedureName + "(" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString());
      }
      return _results;
    }).call(this)).join(", ")) + ")";
  };

  PCProcedureCall.prototype._getType = function(env, className) {
    var arg, i, proc, type, _i, _len, _ref;
    proc = this.getProcedure(env, className);
    if (this.children.length === 0 && proc["arguments"].length > 0) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "No arguments for procedure that requires arguments!"
      };
    }
    if (this.children.length > 0 && proc["arguments"].length === 0) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Arguments were passed to procedure without arguments!"
      };
    }
    if (this.children.length > proc["arguments"].length) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "More arguments than requiered were passed to procedure!"
      };
    }
    _ref = proc["arguments"];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      arg = _ref[i];
      type = arg.type;
      if (i >= this.children.length) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Procedure expected argument of type " + type + ", but got none!"
        };
      }
      if (!this.children[i].getType(env).isAssignableTo(type)) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "Argument number " + (i + 1) + " should have type " + type + ", but is " + (this.children[i].getType(env))
        };
      }
    }
    return proc.returnType;
  };

  return PCProcedureCall;

})(PCExpression);

PCClassCall = (function(_super) {
  __extends(PCClassCall, _super);

  function PCClassCall() {
    return PCClassCall.__super__.constructor.apply(this, arguments);
  }

  PCClassCall.prototype.getProcedure = function(env) {
    return this.children[1].getProcedure(env, this.children[0].getType(env).identifier);
  };

  PCClassCall.prototype.getPrecedence = function() {
    return 78;
  };

  PCClassCall.prototype.toString = function() {
    return "" + (this.children[0].toString()) + "." + (this.children[1].toString());
  };

  PCClassCall.prototype._getType = function(env) {
    var type;
    type = this.children[0].getType(env);
    if (!(type instanceof PCTClassType)) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Incorrect type left to '.' (point). Expected a monitor or struct object, but found " + type
      };
    }
    return this.children[1].getType(env, this.children[0].getType(env).identifier);
  };

  return PCClassCall;

})(PCExpression);

PCArrayExpression = (function(_super) {
  __extends(PCArrayExpression, _super);

  function PCArrayExpression() {
    return PCArrayExpression.__super__.constructor.apply(this, arguments);
  }

  PCArrayExpression.prototype.getPrecedence = function() {
    return 81;
  };

  PCArrayExpression.prototype.toString = function() {
    var end, front, pos;
    front = "" + this.children[0];
    pos = front.indexOf("[");
    if (pos === -1) {
      return "" + front + "[" + this.children[1] + "]";
    } else {
      end = front.substring(pos);
      front = front.slice(0, pos);
      return "" + front + "[" + this.children[1] + "]" + end;
    }
  };

  PCArrayExpression.prototype._getType = function(env) {
    var childType, type;
    type = this.children[0].getType(env);
    if (!(type instanceof PCTArrayType)) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "You use array access on a non-array: " + type
      };
    }
    childType = this.children[1].getType(env);
    if (!childType.isEqual(new PCTType(PCTType.INT))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Array index must be an integer value, not " + childType
      };
    }
    type = type.elementsType;
    return type;
  };

  return PCArrayExpression;

})(PCExpression);

PCLiteralExpression = (function(_super) {
  __extends(PCLiteralExpression, _super);

  function PCLiteralExpression(line, column, value) {
    this.value = value;
    PCLiteralExpression.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCLiteralExpression.prototype.getPrecedence = function() {
    return 84;
  };

  PCLiteralExpression.prototype.toString = function() {
    switch (typeof this.value) {
      case "boolean":
        if (this.value) {
          return "true";
        } else {
          return "false";
        }
      case "string":
        return "\"" + this.value + "\"";
      default:
        return "" + this.value;
    }
  };

  PCLiteralExpression.prototype._getType = function(env) {
    switch (typeof this.value) {
      case "boolean":
        return new PCTType(PCTType.BOOL);
      case "string":
        return new PCTType(PCTType.STRING);
      default:
        return new PCTType(PCTType.INT);
    }
  };

  return PCLiteralExpression;

})(PCExpression);

PCIdentifierExpression = (function(_super) {
  __extends(PCIdentifierExpression, _super);

  function PCIdentifierExpression(line, column, identifier) {
    this.identifier = identifier;
    PCIdentifierExpression.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCIdentifierExpression.prototype.getPrecedence = function() {
    return 84;
  };

  PCIdentifierExpression.prototype.toString = function() {
    return this.identifier;
  };

  PCIdentifierExpression.prototype._getType = function(env) {
    return env.getVariableWithName(this.identifier, this.line, this.column).type;
  };

  return PCIdentifierExpression;

})(PCExpression);

PCStatement = (function(_super) {
  __extends(PCStatement, _super);

  function PCStatement() {
    return PCStatement.__super__.constructor.apply(this, arguments);
  }

  PCStatement.prototype.collectEnvironment = function(env) {
    return this.children.length > 0 && this.children[0].collectEnvironment(env);
  };

  PCStatement.prototype._collectEnvironment = function(env) {
    return this.children.length > 0 && this.children[0]._collectEnvironment(env);
  };

  PCStatement.prototype.toString = function(indent, expectsNewBlock) {
    var addIndent, res;
    addIndent = expectsNewBlock === true && (this.children.length === 0 || !(this.children[0] instanceof PCStmtBlock));
    if (addIndent) {
      indent += PCIndent;
    }
    if (this.children.length === 0) {
      res = indent + ";";
    } else {
      res = this.children[0].toString(indent);
      if (this.children[0] instanceof PCStmtExpression) {
        res += ";";
      }
    }
    if (addIndent) {
      res = "\n" + res;
    }
    return res;
  };

  PCStatement.prototype._getType = function(env) {
    if (this.children.length > 0) {
      this.children[0].getType(env);
    }
    return new PCTType(PCTType.VOID);
  };

  return PCStatement;

})(PCNode);

PCBreakStmt = (function(_super) {
  __extends(PCBreakStmt, _super);

  function PCBreakStmt(line, column) {
    PCBreakStmt.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCBreakStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCBreakStmt.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCBreakStmt.prototype.toString = function(indent) {
    return indent + "break";
  };

  PCBreakStmt.prototype._getType = function(env) {
    return new PCTType(PCTType.VOID);
  };

  return PCBreakStmt;

})(PCNode);

PCContinueStmt = (function(_super) {
  __extends(PCContinueStmt, _super);

  function PCContinueStmt(line, column) {
    PCContinueStmt.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
  }

  PCContinueStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCContinueStmt.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCContinueStmt.prototype.toString = function(indent) {
    return indent + "continue";
  };

  PCContinueStmt.prototype._getType = function(env) {
    return new PCTType(PCTType.VOID);
  };

  return PCContinueStmt;

})(PCNode);

PCStmtBlock = (function(_super) {
  __extends(PCStmtBlock, _super);

  function PCStmtBlock() {
    return PCStmtBlock.__super__.constructor.apply(this, arguments);
  }

  PCStmtBlock.prototype.collectEnvironment = function(env) {
    var c, _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.collectEnvironment(env));
    }
    return _results;
  };

  PCStmtBlock.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.openEnvironment(this);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.closeEnvironment();
  };

  PCStmtBlock.prototype.toString = function(indent) {
    var o;
    return "" + indent + "{\n" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(indent + PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n" + indent + "}";
  };

  PCStmtBlock.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    env.getEnvironment(this, this.__id);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
      if (child instanceof PCStatement && (child.children[0] != null) && child.children[0] instanceof PCStmtBlock) {
        if (child.children[0].isReturnExhaustive) {
          env.setReturnExhaustive();
        }
      }
    }
    env.closeEnvironment();
    return new PCTType(PCTType.VOID);
  };

  return PCStmtBlock;

})(PCNode);

PCStmtExpression = (function(_super) {
  __extends(PCStmtExpression, _super);

  function PCStmtExpression() {
    return PCStmtExpression.__super__.constructor.apply(this, arguments);
  }

  PCStmtExpression.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCStmtExpression.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCStmtExpression.prototype.toString = function(indent) {
    return indent + this.children[0].toString();
  };

  PCStmtExpression.prototype._getType = function(env) {
    return this.children[0].getType(env);
  };

  return PCStmtExpression;

})(PCNode);

PCSelectStmt = (function(_super) {
  __extends(PCSelectStmt, _super);

  function PCSelectStmt() {
    return PCSelectStmt.__super__.constructor.apply(this, arguments);
  }

  PCSelectStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCSelectStmt.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.openEnvironment(this);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.closeEnvironment();
  };

  PCSelectStmt.prototype.toString = function(indent) {
    var o;
    return "" + indent + "select {\n" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(indent + PCIndent));
      }
      return _results;
    }).call(this)).join("\n")) + "\n" + indent + "}";
  };

  PCSelectStmt.prototype._getType = function(env) {
    var child, retExhaust, _i, _len, _ref;
    env.getEnvironment(this, this.__id);
    retExhaust = true;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
      retExhaut &= child.isReturnExhaustive;
    }
    if (retExhaust) {
      env.setReturnExhaustive();
    }
    env.closeEnvironment();
    if (retExhaust) {
      env.setReturnExhaustive();
    }
    return new PCTType(PCTType.VOID);
  };

  return PCSelectStmt;

})(PCNode);

PCCase = (function(_super) {
  __extends(PCCase, _super);

  function PCCase(line, column, execution, condition) {
    if (condition) {
      PCCase.__super__.constructor.call(this, line, column, execution, condition);
    } else {
      PCCase.__super__.constructor.call(this, line, column, execution);
    }
  }

  PCCase.prototype.getCondition = function() {
    if (this.children.length === 2) {
      return this.children[1];
    } else {
      return null;
    }
  };

  PCCase.prototype.getExecution = function() {
    return this.children[0];
  };

  PCCase.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCCase.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child._collectEnvironment(env));
    }
    return _results;
  };

  PCCase.prototype.toString = function(indent) {
    return "" + indent + (this.children.length === 2 ? "case " + (this.children[1].toString()) : "default") + ": " + (this.children[0].toString(indent, true));
  };

  PCCase.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
    }
    if (this.children.length > 1 && !this.children[0].usesSendOrReceiveOperator()) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "case condition requires at least one send or receive operation."
      };
    }
    if (this.children[0] instanceof PCStatement && (this.children[0].children[0] != null) && this.children[0].children[0] instanceof PCStmtBlock) {
      this.isReturnExhaustive = this.children[0].children[0].isReturnExhaustive;
    }
    return new PCTType(PCTType.VOID);
  };

  return PCCase;

})(PCNode);

PCIfStmt = (function(_super) {
  __extends(PCIfStmt, _super);

  function PCIfStmt() {
    return PCIfStmt.__super__.constructor.apply(this, arguments);
  }

  PCIfStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCIfStmt.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.openEnvironment(this);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.closeEnvironment();
  };

  PCIfStmt.prototype.toString = function(indent) {
    return "" + indent + "if (" + (this.children[0].toString()) + ") " + (this.children[1].toString(indent, true)) + (this.children[2] ? "\n" + indent + "else " + (this.children[2].toString(indent, true)) : "");
  };

  PCIfStmt.prototype._getType = function(env) {
    var expType;
    expType = this.children[0].getType(env);
    if (!expType.isEqual(new PCTType(PCTType.BOOL))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Type of condition must be bool not " + expType
      };
    }
    env.getEnvironment(this, this.__id);
    this.children[1].getType(env);
    if (this.children.length > 2) {
      this.children[2].getType(env);
    }
    if (this.children[1] instanceof PCStatement && (this.children[1].children[0] != null) && this.children[1].children[0] instanceof PCStmtBlock) {
      if (this.children[2] != null) {
        if (this.children[2] instanceof PCStatement && (this.children[2].children[0] != null) && this.children[2].children[0] instanceof PCStmtBlock) {
          if (this.children[1].children[0].isReturnExhaustive && this.children[2].children[0].isReturnExhaustive) {
            env.setReturnExhaustive();
          }
        }
      } else {
        if (this.children[1].children[0].isReturnExhaustive) {
          env.setReturnExhaustive();
        }
      }
    }
    env.closeEnvironment();
    if (this.isReturnExhaustive) {
      env.setReturnExhaustive();
    }
    return new PCTType(PCTType.VOID);
  };

  return PCIfStmt;

})(PCNode);

PCWhileStmt = (function(_super) {
  __extends(PCWhileStmt, _super);

  function PCWhileStmt() {
    return PCWhileStmt.__super__.constructor.apply(this, arguments);
  }

  PCWhileStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCWhileStmt.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.openEnvironment(this);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.closeEnvironment();
  };

  PCWhileStmt.prototype.toString = function(indent) {
    return "" + indent + "while (" + (this.children[0].toString()) + ") " + (this.children[1].toString(indent, true));
  };

  PCWhileStmt.prototype._getType = function(env) {
    var expType;
    expType = this.children[0].getType(env);
    if (!expType.isEqual(new PCTType(PCTType.BOOL))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Type of condition must be bool not " + expType
      };
    }
    env.getEnvironment(this, this.__id);
    this.children[1].getType(env);
    env.closeEnvironment();
    return new PCTType(PCTType.VOID);
  };

  return PCWhileStmt;

})(PCNode);

PCDoStmt = (function(_super) {
  __extends(PCDoStmt, _super);

  function PCDoStmt() {
    return PCDoStmt.__super__.constructor.apply(this, arguments);
  }

  PCDoStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCDoStmt.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref;
    env.openEnvironment(this);
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child._collectEnvironment(env);
    }
    return env.closeEnvironment();
  };

  PCDoStmt.prototype.toString = function(indent) {
    return "" + indent + "do " + (this.children[0].toString(indent, true)) + "\n" + indent + "while (" + (this.children[1].toString()) + ")";
  };

  PCDoStmt.prototype._getType = function(env) {
    var expType;
    env.getEnvironment(this, this.__id);
    this.children[0].getType(env);
    env.closeEnvironment();
    expType = this.children[1].getType(env);
    if (!expType.isEqual(new PCTType(PCTType.BOOL))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Type of condition must be bool not " + expType
      };
    }
    return new PCTType(PCTType.VOID);
  };

  return PCDoStmt;

})(PCNode);

PCForStmt = (function(_super) {
  __extends(PCForStmt, _super);

  function PCForStmt() {
    var body, children, column, expression, init, line, update;
    line = arguments[0], column = arguments[1], body = arguments[2], init = arguments[3], expression = arguments[4], update = 6 <= arguments.length ? __slice.call(arguments, 5) : [];
    this.body = body;
    this.init = init;
    this.expression = expression;
    this.update = update;
    children = this.update.concat([this.body]);
    if (this.expression) {
      children.unshift(this.expression);
    }
    if (this.init) {
      children.unshift(this.init);
    }
    PCForStmt.__super__.constructor.apply(this, [line, column].concat(__slice.call(children)));
  }

  PCForStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCForStmt.prototype._collectEnvironment = function(env) {
    env.openEnvironment(this);
    this.init._collectEnvironment(env);
    this.body._collectEnvironment(env);
    return env.closeEnvironment();
  };

  PCForStmt.prototype.toString = function(indent) {
    var o;
    return "" + indent + "for (" + (this.init ? this.init.toString() : "") + "; " + (this.expression ? this.expression.toString() : "") + "; " + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.update;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(""));
      }
      return _results;
    }).call(this)).join(", ")) + ") " + (this.body.toString(indent, true));
  };

  PCForStmt.prototype._getType = function(env) {
    var expType, update, _i, _len, _ref;
    env.getEnvironment(this, this.__id);
    if (this.init) {
      this.init.getType(env);
    }
    if (this.expression != null) {
      expType = this.expression.getType(env);
    }
    if ((expType != null) && !expType.isEqual(new PCTType(PCTType.BOOL))) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Type of condition must be bool not " + expType
      };
    }
    _ref = this.update;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      update = _ref[_i];
      update.getType(env);
    }
    this.body.getType(env);
    env.closeEnvironment();
    return new PCTType(PCTType.VOID);
  };

  return PCForStmt;

})(PCNode);

PCForInit = (function(_super) {
  __extends(PCForInit, _super);

  function PCForInit() {
    return PCForInit.__super__.constructor.apply(this, arguments);
  }

  PCForInit.prototype.toString = function() {
    var o;
    return "" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString(""));
      }
      return _results;
    }).call(this)).join(", "));
  };

  PCForInit.prototype._collectEnvironment = function(env) {
    var child, _i, _len, _ref, _results;
    _ref = this.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child._collectEnvironment(env));
    }
    return _results;
  };

  PCForInit.prototype._getType = function(env) {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.getType(env);
    }
    return new PCTType(PCTType.VOID);
  };

  return PCForInit;

})(PCNode);

PCReturnStmt = (function(_super) {
  __extends(PCReturnStmt, _super);

  function PCReturnStmt() {
    return PCReturnStmt.__super__.constructor.apply(this, arguments);
  }

  PCReturnStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCReturnStmt.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCReturnStmt.prototype.toString = function(indent) {
    return "" + indent + "return" + (this.children.length === 1 ? " " + (this.children[0].toString()) : "") + ";";
  };

  PCReturnStmt.prototype._getType = function(env) {
    var expectedType, type;
    if (this.children.length > 0) {
      type = this.children[0].getType(env);
    }
    if (type == null) {
      type = new PCTType(PCTType.VOID);
    }
    expectedType = env.getExpectedReturnValue();
    if (!type.isEqual(expectedType)) {
      throw {
        "line": this.line,
        "column": this.column,
        "message": "Expression of type " + type + " doesn't match expected return type " + expectedType + " for procedure."
      };
    }
    return env.setReturnExhaustive();
  };

  return PCReturnStmt;

})(PCNode);

PCPrimitiveStmt = (function(_super) {
  __extends(PCPrimitiveStmt, _super);

  function PCPrimitiveStmt(line, column, kind, expression) {
    this.kind = kind;
    if (expression) {
      PCPrimitiveStmt.__super__.constructor.call(this, line, column, expression);
    } else {
      PCPrimitiveStmt.__super__.constructor.apply(this, [line, column].concat(__slice.call([])));
    }
  }

  PCPrimitiveStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCPrimitiveStmt.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCPrimitiveStmt.prototype.toString = function(indent) {
    return "" + indent + (PCPrimitiveStmt.kindToString(this.kind)) + (this.children.length === 1 ? " " + (this.children[0].toString()) : "") + ";";
  };

  PCPrimitiveStmt.prototype._getType = function(env) {
    if (this.children.length > 0) {
      this._type = this.children[0].getType(env);
    }
    switch (this.kind) {
      case PCPrimitiveStmt.JOIN:
        if (!this._type.isEqual(new PCTType(PCTType.AGENT))) {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "join must be applied on agents, not " + this._type + "!"
          };
        }
        break;
      case PCPrimitiveStmt.LOCK:
      case PCPrimitiveStmt.UNLOCK:
        if (!this._type.isEqual(new PCTType(PCTType.MUTEX))) {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "lock and unlock must be applied on mutex objects, not " + this._type + "!"
          };
        }
        break;
      case PCPrimitiveStmt.WAIT:
        if (!this.insideMonitor()) {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "waitForCondition can only be used in monitors!"
          };
        }
        if (!this._type.isEqual(new PCTType(PCTType.Bool)) && !this._type.isEqual(new PCTType(PCTType.CONDITION))) {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "waitForCondition must be applied on condition or boolean objects, not " + this._type + "!"
          };
        }
        break;
      case PCPrimitiveStmt.SIGNAL:
      case PCPrimitiveStmt.SIGNAL_ALL:
        if (!this.insideMonitor()) {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "signal and signalAll can only be used in monitors!"
          };
        }
        if (this.children.length > 0 && !this._type.isEqual(new PCTType(PCTType.CONDITION))) {
          throw {
            "line": this.line,
            "column": this.column,
            "message": "signal and signalAll must be applied on condition objects, not " + this._type + "!"
          };
        }
    }
    return new PCTType(PCTType.VOID);
  };

  return PCPrimitiveStmt;

})(PCNode);

PCPrimitiveStmt.JOIN = 0;

PCPrimitiveStmt.LOCK = 1;

PCPrimitiveStmt.UNLOCK = 2;

PCPrimitiveStmt.WAIT = 3;

PCPrimitiveStmt.SIGNAL = 4;

PCPrimitiveStmt.SIGNAL_ALL = 5;

PCPrimitiveStmt.kindToString = function(kind) {
  switch (kind) {
    case PCPrimitiveStmt.JOIN:
      return "join";
    case PCPrimitiveStmt.LOCK:
      return "lock";
    case PCPrimitiveStmt.UNLOCK:
      return "unlock";
    case PCPrimitiveStmt.WAIT:
      return "waitForCondition";
    case PCPrimitiveStmt.SIGNAL:
      return "signal";
    case PCPrimitiveStmt.SIGNAL_ALL:
      return "signal all";
  }
};

PCPrintStmt = (function(_super) {
  __extends(PCPrintStmt, _super);

  function PCPrintStmt() {
    return PCPrintStmt.__super__.constructor.apply(this, arguments);
  }

  PCPrintStmt.prototype.collectEnvironment = function(env) {
    return null;
  };

  PCPrintStmt.prototype._collectEnvironment = function(env) {
    return null;
  };

  PCPrintStmt.prototype.toString = function(indent) {
    var o;
    return "" + indent + "println(" + (((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.toString());
      }
      return _results;
    }).call(this)).join(", ")) + ");";
  };

  PCPrintStmt.prototype._getType = function(env) {
    var child, type, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      type = child.getType(env);
      if (!type.isEqual(new PCTType(PCTType.STRING)) && !type.isEqual(new PCTType(PCTType.INT))) {
        throw {
          "line": this.line,
          "column": this.column,
          "message": "println can only process strings and integers, but no " + type + "!"
        };
      }
    }
    return new PCTType(PCTType.VOID);
  };

  return PCPrintStmt;

})(PCNode);


/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/*
	This class represents PseuCo's types.
	May be partly incomplete as type checking is not yet completely supported by the PseuCo tree.
 */

PCTType = (function() {
  function PCTType(kind) {
    this.kind = kind;
    if (this.kind < 0 || this.kind > 14) {
      throw new Error("Unknown kind of type!");
    }
  }

  PCTType.prototype.isEqual = function(type) {
    return type.kind === this.kind;
  };

  PCTType.prototype.isAssignableTo = function(type) {
    if (this.kind === PCTType.WILDCARD) {
      return false;
    }
    return this.isEqual(type) || type.kind === PCTType.WILDCARD;
  };

  PCTType.prototype.toString = function() {
    switch (this.kind) {
      case PCTType.INT:
        return "int";
      case PCTType.BOOL:
        return "bool";
      case PCTType.STRING:
        return "string";
      case PCTType.CHANNEL:
        return "channel";
      case PCTType.ARRAY:
        return "array";
      case PCTType.MONITOR:
        return "monitor";
      case PCTType.STRUCTURE:
        return "struct";
      case PCTType.MUTEX:
        return "mutex";
      case PCTType.CONDITION:
        return "condition";
      case PCTType.PROCEDURE:
        return "procedure";
      case PCTType.TYPE:
        return "type";
      case PCTType.MAINAGENT:
        return "mainAgent";
      case PCTType.AGENT:
        return "agent";
      case PCTType.WILDCARD:
        return "wildcard";
      default:
        return "void";
    }
  };

  return PCTType;

})();

PCTType.VOID = 0;

PCTType.BOOL = 1;

PCTType.INT = 2;

PCTType.STRING = 3;

PCTType.CHANNEL = 4;

PCTType.ARRAY = 5;

PCTType.MONITOR = 6;

PCTType.STRUCT = 7;

PCTType.MUTEX = 8;

PCTType.CONDITION = 9;

PCTType.PROCEDURE = 10;

PCTType.TYPE = 11;

PCTType.MAINAGENT = 12;

PCTType.AGENT = 13;

PCTType.WILDCARD = 14;

PCTArrayType = (function(_super) {
  __extends(PCTArrayType, _super);

  function PCTArrayType(elementsType, capacity) {
    this.elementsType = elementsType;
    this.capacity = capacity;
    PCTArrayType.__super__.constructor.call(this, PCTType.ARRAY);
  }

  PCTArrayType.prototype.isEqual = function(type) {
    var capacityFulfilled;
    capacityFulfilled = type.capacity === this.capacity || this.capacity === 0 || type.capacity === 0;
    return type.kind === this.kind && capacityFulfilled && this.elementsType.isEqual(type.elementsType);
  };

  PCTArrayType.prototype.toString = function() {
    return "" + (this.elementsType.toString()) + "[" + this.capacity + "]";
  };

  return PCTArrayType;

})(PCTType);

PCTChannelType = (function(_super) {
  __extends(PCTChannelType, _super);

  function PCTChannelType(channelledType, capacity) {
    this.channelledType = channelledType;
    this.capacity = capacity;
    PCTChannelType.__super__.constructor.call(this, PCTType.CHANNEL);
  }

  PCTChannelType.prototype.isEqual = function(type) {
    return this.kind === type.kind && this.capacity === type.capacity && this.channelledType.isEqual(type.channelledType);
  };

  PCTChannelType.prototype.isAssignableTo = function(type) {
    return this.kind === type.kind && (this.capacity === type.capacity || type.capacity === 0) && this.channelledType.isEqual(type.channelledType);
  };

  PCTChannelType.prototype.getApplicableCapacity = function() {
    if (this.capacity === PCChannelType.CAPACITY_UNKNOWN) {
      return 0;
    } else {
      return this.capacity;
    }
  };

  PCTChannelType.prototype.toString = function() {
    if (this.capacity === PCChannelType.CAPACITY_UNKNOWN) {
      return "handshake " + (this.channelledType.toString()) + " " + PCTChannelType.__super__.toString.apply(this, arguments);
    } else {
      return "" + (this.channelledType.toString()) + " " + PCTChannelType.__super__.toString.apply(this, arguments) + " of capacity " + this.capacity;
    }
  };

  return PCTChannelType;

})(PCTType);

PCTClassType = (function(_super) {
  __extends(PCTClassType, _super);

  function PCTClassType(isMonitor, identifier) {
    this.identifier = identifier;
    PCTClassType.__super__.constructor.call(this, (isMonitor ? PCTType.MONITOR : PCTType.STRUCT));
  }

  PCTClassType.prototype.isMonitor = function() {
    return this.kind === PCTType.MONITOR;
  };

  PCTClassType.prototype.isEqual = function(type) {
    return this.kind === type.kind && this.identifier === type.identifier;
  };

  PCTClassType.prototype.toString = function() {
    return "" + PCTClassType.__super__.toString.apply(this, arguments) + " " + this.identifier;
  };

  return PCTClassType;

})(PCTType);

PCTProcedureType = (function(_super) {
  __extends(PCTProcedureType, _super);

  function PCTProcedureType(returnType, argumentTypes) {
    this.returnType = returnType;
    this.argumentTypes = argumentTypes;
    PCTProcedureType.__super__.constructor.call(this, PCTType.PROCEDURE);
  }

  PCTProcedureType.prototype.isEqual = function(type) {
    var i, _i, _ref;
    if (type.argumentTypes.length !== this.argumentTypes) {
      return false;
    }
    for (i = _i = 0, _ref = this.argumentTypes.length; _i < _ref; i = _i += 1) {
      if (!type.argumentTypes[i].isEqual(this.argumentTypes[i])) {
        return false;
      }
    }
    return type.returnType.isEqual(this.returnType);
  };

  PCTProcedureType.prototype.toString = function() {
    var args, t;
    args = ((function() {
      var _i, _len, _ref, _results;
      _ref = this.argumentTypes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(t.toString());
      }
      return _results;
    }).call(this)).join(" x ");
    return "" + (this.returnType.toString()) + " -> (" + args + ")";
  };

  return PCTProcedureType;

})(PCTType);

PCTTypeType = (function(_super) {
  __extends(PCTTypeType, _super);

  function PCTTypeType(type) {
    this.type = type;
    PCTTypeType.__super__.constructor.call(this, PCTType.TYPE);
  }

  PCTTypeType.prototype.isEqual = function(type) {
    return this.kind === type.kind && this.type.isEqual(type.type);
  };

  return PCTTypeType;

})(PCTType);


/*
PseuCo Compiler  
Copyright (C) 2013  
Saarland University (www.uni-saarland.de)  
Sebastian Biewer (biewer@splodge.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/*
	ToDo
 */

PCTEnvironmentController = (function() {
  function PCTEnvironmentController() {
    this.root = new PCTEnvironmentNode(null, "");
    this.classes = {};
    this._envStack = this.root;
    this.blockCounter = 1;
  }

  PCTEnvironmentController.prototype.getGlobal = function() {
    return this.root;
  };

  PCTEnvironmentController.prototype.openEnvironment = function(node) {
    var child;
    node.__id = this.blockCounter++;
    child = new PCTEnvironmentNode(node, "#" + node.__id);
    child.__id = node.__id;
    this._envStack.addChild(child);
    this._envStack = child;
    return child;
  };

  PCTEnvironmentController.prototype.getEnvironment = function(node, id) {
    node = this._envStack.getBlockWithId(id);
    if (!node) {
      throw new Error("Block not found!");
    }
    this._envStack = node;
    return node;
  };

  PCTEnvironmentController.prototype.closeEnvironment = function() {
    if (!this._envStack instanceof PCTEnvironmentNode) {
      throw new Error("No open environment!");
    }
    this._envStack.node.isReturnExhaustive = this._envStack.isReturnExhaustive();
    return this._envStack = this._envStack.parent;
  };

  PCTEnvironmentController.prototype.getClassWithName = function(name) {
    var result;
    result = this.classes[name];
    if (result === void 0) {
      throw new Error("Unknown class '" + name + "'");
    }
    return result;
  };

  PCTEnvironmentController.prototype.getAllClasses = function() {
    return this.root.getAllClasses();
  };

  PCTEnvironmentController.prototype.getVariableWithName = function(name, line, column) {
    return this._envStack.getVariableWithName(name, line, column);
  };

  PCTEnvironmentController.prototype.getProcedureWithName = function(name, line, column) {
    return this._envStack.getProcedureWithName(name, line, column);
  };

  PCTEnvironmentController.prototype.getExpectedReturnValue = function() {
    return this._envStack.getExpectedReturnValue();
  };

  PCTEnvironmentController.prototype.isReturnExhaustive = function() {
    return this._envStack.isReturnExhaustive();
  };

  PCTEnvironmentController.prototype.setReturnExhaustive = function() {
    return this._envStack.setReturnExhaustive();
  };

  PCTEnvironmentController.prototype.unsetReturnExhaustive = function() {
    return this._envStack.unsetReturnExhaustive();
  };

  PCTEnvironmentController.prototype.processNewClass = function(node, classType) {
    var tnode;
    tnode = new PCTClass(node, classType);
    return this._processNewClass(tnode);
  };

  PCTEnvironmentController.prototype._processNewClass = function(node) {
    if (this.classes[node.getName()]) {
      throw new Error("Class already registered!");
    }
    this._envStack.addChild(node);
    return this.classes[node.getName()] = node;
  };

  PCTEnvironmentController.prototype.beginClass = function(className) {
    var node;
    node = this.getClassWithName(className);
    if (!node) {
      throw new Error("Node must not be null!");
    }
    this._envStack = node;
    return node;
  };

  PCTEnvironmentController.prototype.endClass = function() {
    if (!this._envStack instanceof PCTClass) {
      throw new Error("No class did begin!");
    }
    this._envStack.node.isReturnExhaustive = this._envStack.isReturnExhaustive();
    return this._envStack = this._envStack.parent;
  };

  PCTEnvironmentController.prototype.beginNewProcedure = function(node, procedureName, returnType, args) {
    var tnode;
    tnode = new PCTProcedure(node, procedureName, returnType, args);
    return this._beginNewProcedure(tnode);
  };

  PCTEnvironmentController.prototype._beginNewProcedure = function(node) {
    this._envStack.addChild(node);
    return this.beginProcedure(node.getName());
  };

  PCTEnvironmentController.prototype.beginProcedure = function(procedureName) {
    var node;
    try {
      node = this._envStack.getProcedureWithName(procedureName);
      this._envStack = node;
      return node;
    } catch (_error) {
      if (!node) {
        throw new Error("Node must not be null!");
      }
    }
  };

  PCTEnvironmentController.prototype.endProcedure = function() {
    if (!this._envStack instanceof PCTProcedure) {
      throw new Error("No procedure did begin!");
    }
    this._envStack.node.isReturnExhaustive = this._envStack.isReturnExhaustive();
    return this._envStack = this._envStack.parent;
  };

  PCTEnvironmentController.prototype.beginMainAgent = function(node) {
    try {
      this._envStack.getProcedureWithName("#mainAgent");
    } catch (_error) {
      this.beginNewProcedure(node, "#mainAgent", new PCTType(PCTType.VOID), []);
      return;
    }
    return this.beginProcedure("#mainAgent");
  };

  PCTEnvironmentController.prototype._beginMainAgent = function(node) {
    try {
      this._envStack.getProcedureWithName("#mainAgent");
    } catch (_error) {
      this.beginNewProcedure(node, "#mainAgent", new PCTType(PCTType.VOID), []);
      return;
    }
    throw {
      "line": node.line,
      "column": node.column,
      "message": "Main agent can't be declared twice!"
    };
  };

  PCTEnvironmentController.prototype.endMainAgent = function() {
    return this.endProcedure();
  };

  PCTEnvironmentController.prototype.processNewVariable = function(variable) {
    return this._processNewVariable(variable);
  };

  PCTEnvironmentController.prototype._processNewVariable = function(node) {
    this._envStack.addChild(node);
    return node;
  };

  return PCTEnvironmentController;

})();

PCTEnvironmentNode = (function() {
  function PCTEnvironmentNode(node, label) {
    this.node = node;
    this.label = label;
    this.parent = null;
    this.children = [];
    this.variables = {};
    this.procedures = {};
    this.blocks = {};
    this.isRetExhaust = false;
  }

  PCTEnvironmentNode.prototype.addChild = function(child) {
    this.children.push(child);
    child.parent = this;
    child.isRetExhaust = this.isRetExhaust;
    if (child instanceof PCTProcedure) {
      this.procedures[child.getName()] = child;
    } else if (child instanceof PCTVariable) {
      this.variables[child.getIdentifier()] = child;
    } else if (child instanceof PCTEnvironmentNode) {
      this.blocks[child.__id] = child;
    }
    return child;
  };

  PCTEnvironmentNode.prototype.getVariableWithName = function(name, line, column) {
    if (this.variables[name] == null) {
      if (this.parent == null) {
        throw {
          "line": line,
          "column": column,
          "message": "Variable '" + name + "' wasn't declared."
        };
      }
      return this.parent.getVariableWithName(name, line, column);
    } else {
      return this.variables[name];
    }
  };

  PCTEnvironmentNode.prototype.getProcedureWithName = function(name, line, column) {
    if (this.procedures[name] == null) {
      if (this.parent == null) {
        throw {
          "line": line,
          "column": column,
          "message": "Procedure '" + name + "' wasn't declared."
        };
      }
      return this.parent.getProcedureWithName(name, line, column);
    } else {
      return this.procedures[name];
    }
  };

  PCTEnvironmentNode.prototype.getBlockWithId = function(id) {
    return this.blocks[id];
  };

  PCTEnvironmentNode.prototype.getComposedLabel = function() {
    return "" + (this.parent ? "" + (this.parent.getComposedLabel()) + "_" : "") + this.label;
  };

  PCTEnvironmentNode.prototype.getAllClasses = function() {
    var c, result, _i, _len, _ref;
    result = [];
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (c instanceof PCTClass) {
        result.push(c);
      }
    }
    return result;
  };

  PCTEnvironmentNode.prototype.getExpectedReturnValue = function() {
    if (this instanceof PCTProcedure) {
      return this.returnType;
    } else {
      if (this.parent != null) {
        return this.parent.getExpectedReturnValue();
      } else {
        throw new Error("Return statements are only allowed inside procedures!");
      }
    }
  };

  PCTEnvironmentNode.prototype.isReturnExhaustive = function() {
    return this.isRetExhaust;
  };

  PCTEnvironmentNode.prototype.setReturnExhaustive = function() {
    return this.isRetExhaust = true;
  };

  PCTEnvironmentNode.prototype.unsetReturnExhaustive = function() {
    return this.isRetExhaust = false;
  };

  return PCTEnvironmentNode;

})();

PCTClass = (function(_super) {
  __extends(PCTClass, _super);

  function PCTClass(node, type) {
    this.type = type;
    this.usedClassTypes = [];
    PCTClass.__super__.constructor.call(this, node, this.type.identifier);
  }

  PCTClass.prototype.getName = function() {
    return this.label;
  };

  PCTClass.prototype.isMonitor = function() {
    return this.type.isMonitor();
  };

  PCTClass.prototype.addUseOfClassType = function(type) {
    return this.usedClassTypes.push(type);
  };

  PCTClass.prototype.getUsedClassTypes = function() {
    var result, type, _i, _len, _ref;
    result = [];
    _ref = this.usedClassTypes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      result.push(type);
    }
    return result;
  };

  return PCTClass;

})(PCTEnvironmentNode);

PCTProcedure = (function(_super) {
  __extends(PCTProcedure, _super);

  function PCTProcedure(node, name, returnType, _arguments) {
    var arg, _i, _len, _ref;
    this.returnType = returnType;
    this["arguments"] = _arguments;
    PCTProcedure.__super__.constructor.call(this, node, name);
    _ref = this["arguments"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      this.variables[arg.getName()] = arg;
    }
  }

  PCTProcedure.prototype.getName = function() {
    return this.label;
  };

  PCTProcedure.prototype.isClassProcedure = function() {
    return this.parent instanceof PCClass;
  };

  PCTProcedure.prototype.isMonitorProcedure = function() {
    return this.parent instanceof PCClass && this.parent.isMonitor();
  };

  return PCTProcedure;

})(PCTEnvironmentNode);

PCTVariable = (function() {
  function PCTVariable(node, name, type) {
    this.node = node;
    this.type = type;
    if (typeof this.node === "string") {
      debugger;
    }
    this.label = name;
    this.parent = null;
  }

  PCTVariable.prototype.getName = function() {
    return this.label;
  };

  PCTVariable.prototype.getIdentifier = function() {
    return this.label;
  };

  PCTVariable.prototype.getComposedLabel = function() {
    return "" + (this.parent ? "" + (this.parent.getComposedLabel()) + "_" : "") + this.label;
  };

  return PCTVariable;

})();

PCTCycleChecker = (function() {
  function PCTCycleChecker(classTypes) {
    var type, _i, _len;
    if (classTypes == null) {
      throw new Error("List of class types must not be empty!");
    }
    this.classTypes = {};
    for (_i = 0, _len = classTypes.length; _i < _len; _i++) {
      type = classTypes[_i];
      this.classTypes[type.getName()] = type;
    }
  }

  PCTCycleChecker.prototype.cycleTraceForTypes = function() {
    var name, trace, type, _ref;
    while (Object.keys(this.classTypes).length > 0) {
      _ref = this.classTypes;
      for (name in _ref) {
        type = _ref[name];
        trace = this.cycleTraceForType(type, {}, new PCTTrace(null));
        if (trace) {
          return trace.toString();
        }
      }
    }
    return null;
  };

  PCTCycleChecker.prototype.cycleTraceForType = function(type, alreadyReachable, trace) {
    var result, t, _i, _len, _ref;
    trace.add(type);
    if (alreadyReachable[type.getName()] != null) {
      return trace;
    }
    alreadyReachable[type.getName()] = type;
    if (!delete this.classTypes[type.getName()]) {
      return null;
    }
    _ref = type.getUsedClassTypes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      result = this.cycleTraceForType(t, alreadyReachable, new PCTTrace(trace));
      if (result != null) {
        return result;
      }
    }
    return null;
  };

  return PCTCycleChecker;

})();

PCTTrace = (function() {
  function PCTTrace(trace) {
    var elem, _i, _len, _ref;
    this.elements = [];
    if (trace != null) {
      _ref = trace.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        this.elements.push(elem);
      }
    }
  }

  PCTTrace.prototype.add = function(element) {
    return this.elements.push(element);
  };

  PCTTrace.prototype.toString = function() {
    var element, result;
    result = "" + (this.elements.length > 0 ? this.elements[0].getName() : void 0);
    "" + ((function() {
      var _i, _len, _ref, _results;
      _ref = this.elements.slice(1);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i += 1) {
        element = _ref[_i];
        _results.push(result += " -> " + element.getName());
      }
      return _results;
    }).call(this));
    return result;
  };

  return PCTTrace;

})();
